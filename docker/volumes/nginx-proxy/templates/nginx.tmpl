{{ $CurrentContainer := where $ "ID" .Docker.CurrentContainerID | first }}

{{ $external_http_port := coalesce $.Env.HTTP_PORT "80" }}
{{ $external_https_port := coalesce $.Env.HTTPS_PORT "443" }}

{{ define "upstream" }}
  {{ if .Address }}
  server {{ .Address }}:{{ .Port }} max_fails=3 fail_timeout=30s;
  {{ else }}
  server 127.0.0.1 down;
  {{ end }}
  keepalive 64;
{{ end }}

# If we receive Upgrade, set Connection to "upgrade"; otherwise, delete any
# Connection header that may have been passed to this server
map $http_upgrade $proxy_connection {
  default upgrade;
  '' close;
}

# Apply fix for very long server names
server_names_hash_bucket_size 128;

# Default dhparam
{{ if (exists "/etc/nginx/dhparam/dhparam.pem") }}
ssl_dhparam /etc/nginx/dhparam/dhparam.pem;
{{ end }}

# Set appropriate X-Forwarded-Ssl header
map $scheme $proxy_x_forwarded_ssl {
  default off;
  https on;
}

gzip_types text/plain text/css application/javascript application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;

log_format vhost '$host $remote_addr - $remote_user [$time_local] '
                 '"$request" $status $body_bytes_sent '
                 '"$http_referer" "$http_user_agent"';

access_log off;

{{ if $.Env.RESOLVERS }}
resolver {{ $.Env.RESOLVERS }};
{{ end }}

# HTTP 1.1 support
proxy_http_version 1.1;
proxy_buffering off;
proxy_set_header Host $http_host;
proxy_set_header X-Forwarded-Proto https;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-NginX-Proxy true;
proxy_set_header ssl-protocol-version $ssl_protocol;

# Mitigate httpoxy attack (see README for details)
proxy_set_header Proxy "";

server {
  server_name _; # This is just an invalid value which will never trigger on a real hostname.
  listen {{ $external_http_port }};
  return 503;
}

server {
  server_name _; # This is just an invalid value which will never trigger on a real hostname.
  listen 443 ssl;
  access_log /var/log/nginx/access.log vhost;
  return 503;
  ssl_session_cache shared:SSL:50m;
  ssl_session_tickets off;
  ssl_certificate /etc/nginx/certs/docker.dev-franceconnect.fr.crt;
  ssl_certificate_key /etc/nginx/certs/docker.dev-franceconnect.fr.key;
}

{{ range $host, $containers := groupByMulti $ "Env.VIRTUAL_HOST" "," }}

{{ $host := trim $host }}
{{ $is_regexp := hasPrefix "~" $host }}
{{ $upstream_name := when $is_regexp (sha1 $host) $host }}

# {{ $host }}
upstream {{ $upstream_name }} {

{{ range $container := $containers }}
  {{ range $knownNetwork := $CurrentContainer.Networks }}
    {{ range $containerNetwork := $container.Networks }}
      {{ if (and (ne $containerNetwork.Name "ingress") (or (eq $knownNetwork.Name $containerNetwork.Name) (eq $knownNetwork.Name "host"))) }}
        {{ $port := coalesce $container.Env.VIRTUAL_PORT "80" }}
        {{ $address := where $container.Addresses "Port" $port | first }}
        {{ template "upstream" (dict "Container" $container "Address" $containerNetwork.IP "Port" $port) }}
      {{ end }}
    {{ end }}
  {{ end }}
{{ end }}
}

server {
  listen {{ $external_http_port }};
  server_name {{ $host }};

  location / {
    return 301 https://$host$request_uri;
  }
}

server {
  ### BASIC OPTIONS
  listen {{ $external_https_port }} ssl;
  server_name {{ $host }};
  # Enable this if your want HSTS (recommended)
  add_header Strict-Transport-Security max-age=15768000;
  ###

  ### TLS OPTIONS
  # certs sent to the client in SERVER HELLO are concatenated in ssl_certificate
  ssl_certificate /etc/nginx/certs/docker.dev-franceconnect.fr.crt;
  ssl_certificate_key /etc/nginx/certs/docker.dev-franceconnect.fr.key;
  # Check TLS client
  ssl_verify_client optional;
  ssl_client_certificate /etc/nginx/client_certs/certif-client.pem;
  ###

  ### LOGS
  access_log /var/log/nginx/{{ $upstream_name }}.access.log main;
  error_log /var/log/nginx/{{ $upstream_name }}.error.log error;
  ###

  ### PROXY PASS TO UPSTREAM AND ADD HEADERS VIA -COMMON.VHOST.CONF FILE
{{ range $container := $containers }}
  {{ if $container.Env.SSL_CLIENT_PROTECTED_URIS }}
    {{ range $protected_uri := split $container.Env.SSL_CLIENT_PROTECTED_URIS "," }}
  location {{ $protected_uri }} {
    # URL protégée : requiert certificat client valide.
    if ($ssl_client_verify != "SUCCESS") {
      return 403;
    }
    proxy_pass http://{{ trim $upstream_name }};
    include includes/common.vhost.conf;
    proxy_read_timeout 30;
  }

    {{ end }}
  {{ end }}
{{ end }}

  location / {
    proxy_pass http://{{ trim $upstream_name }};
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    include includes/common.vhost.conf;
    proxy_read_timeout 86400;
  }

  location /favicon.ico {
    deny all;
  }

  ###

}
{{ end }}
