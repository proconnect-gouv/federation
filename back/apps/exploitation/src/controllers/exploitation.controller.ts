import { encode } from 'querystring';

import { Controller, Get, Query, Req, Res } from '@nestjs/common';

import { ConfigService } from '@fc/config';
import { CryptographyService } from '@fc/cryptography';
import { IdentityProviderAdapterEnvService } from '@fc/identity-provider-adapter-env';
import { LoggerLevelNames, LoggerService } from '@fc/logger';
import { IOidcIdentity, OidcSession } from '@fc/oidc';
import {
  OidcClientConfig,
  OidcClientService,
  OidcClientSession,
} from '@fc/oidc-client';
import {
  ISessionService,
  Session,
  SessionCsrfService,
  SessionNotFoundException,
  SessionService,
} from '@fc/session';

import { ExploitationRoutes } from '../enums';

@Controller()
export class ExploitationController {
  // Dependency injection can require more than 4 parameters
  /* eslint-disable-next-line max-params */
  constructor(
    private readonly config: ConfigService,
    private readonly crypto: CryptographyService,
    private readonly oidcClient: OidcClientService,
    private readonly logger: LoggerService,
    private readonly identityProvider: IdentityProviderAdapterEnvService,
    private readonly sessionService: SessionService,
    private readonly csrfService: SessionCsrfService,
  ) {
    this.logger.setContext(this.constructor.name);
  }

  @Get(ExploitationRoutes.OIDC_CLIENT_GET_AUTHORIZE_URL)
  async getAuthorizeUrl(
    /**
     * @todo Adaptation for now, correspond to the oidc-provider side.
     * Named "OidcClient" because we need a future shared session between our libs oidc-provider and oidc-client
     * without a direct dependance like now.
     * @author Hugues
     * @date 2021-04-16
     * @ticket FC-xxx
     */
    @Session('OidcClient')
    sessionOidc: ISessionService<OidcClientSession>,
  ): Promise<string> {
    // Only one provider is available with `@fc/identity-provider-env`
    const [provider] = await this.identityProvider.getList();

    const { acr, claims, scope } =
      this.config.get<OidcClientConfig>('OidcClient');

    const { nonce, state } =
      await this.oidcClient.utils.buildAuthorizeParameters();

    const authorizationUrl: string =
      await this.oidcClient.utils.getAuthorizeUrl({
        // oidc parameter
        // eslint-disable-next-line @typescript-eslint/naming-convention
        acr_values: acr,
        claims,
        nonce,
        idpId: provider.uid,
        scope,
        state,
      });

    const sessionIdLength = 32;
    const sessionId: string = this.crypto.genRandomString(sessionIdLength);

    await sessionOidc.set({
      idpId: provider.uid,
      sessionId,
      idpState: state,
      idpNonce: nonce,
    });

    return authorizationUrl;
  }

  /**
   * @TODO #308 ETQ DEV je veux éviter que deux appels Http soient réalisés au lieu d'un à la discovery Url dans le cadre d'oidc client
   * @see https://gitlab.dev-franceconnect.fr/france-connect/fc/-/issues/308
   */
  // needed for controller
  // eslint-disable-next-line max-params
  @Get(ExploitationRoutes.OIDC_CLIENT_CALLBACK)
  async getOidcCallback(
    @Req() req,
    @Res() res,
    @Query() query,
    /**
     * @todo Adaptation for now, correspond to the oidc-provider side.
     * Named "OidcClient" because we need a future shared session between our libs oidc-provider and oidc-client
     * without a direct dependance like now.
     * @author Hugues
     * @date 2021-04-16
     * @ticket FC-xxx
     */
    @Session('OidcClient')
    sessionOidc: ISessionService<OidcClientSession>,
  ) {
    /**
     * @todo Adaptation for now, we should probably find a better way to handle
     * errors on the oidc callback on the mock.
     * @Todo Since nodev16 should use the <URLSearchParams> API instead of querystring.encode
     *
     * @author Stéphane/Matthieu
     * @date 2021-05-12
     * @ticket FC-xxx
     */
    if (query.error) {
      const loginUri = `/login?${encode(query)}`;

      this.logger.trace({ query, loginUri }, LoggerLevelNames.WARN);

      return res.redirect(loginUri);
    }
    const session: OidcSession = await sessionOidc.get();

    if (!session) {
      throw new SessionNotFoundException('OidcClient');
    }

    const { idpId, idpNonce, idpState } = session;

    const tokenParams = {
      state: idpState,
      nonce: idpNonce,
    };
    const { accessToken, idToken, acr, amr } =
      await this.oidcClient.getTokenFromProvider(idpId, tokenParams, req);

    const userInfoParams = {
      accessToken,
      idpId,
    };

    const identity: IOidcIdentity =
      await this.oidcClient.getUserInfosFromProvider(userInfoParams, req);

    /**
     * @todo
     *    action: Check the data returns from FC.
     *
     * @author Arnaud
     * @date 19/03/2020
     * @ticket FC-244 (identity, DTO, Mock, FS)
     */
    const identityExchange: OidcSession = {
      idpIdentity: identity,
      idpAcr: acr,
      amr,
      idpAccessToken: accessToken,
      idpIdToken: idToken,
    };

    await sessionOidc.set({ ...identityExchange });

    // BUSINESS: Redirect to business page
    const redirect = '/';

    this.logger.trace({
      route: ExploitationRoutes.OIDC_CLIENT_CALLBACK,
      method: 'GET',
      name: 'ExploitationRoutes.OIDC_CLIENT_CALLBACK',
      identityExchange,
      redirect,
    });

    res.redirect(redirect);
  }

  @Get(ExploitationRoutes.OIDC_CLIENT_LOAD_USER_INFOS)
  async loadUserInfos(
    @Session('OidcClient')
    sessionOidc: ISessionService<OidcClientSession>,
  ): Promise<{
    connected: boolean;
    userinfos: Partial<IOidcIdentity>;
  }> {
    const idpIdentity = await sessionOidc.get('idpIdentity');

    return {
      connected: idpIdentity ? true : false,
      userinfos: idpIdentity,
    };
  }

  @Get(ExploitationRoutes.OIDC_CLIENT_GET_END_SESSION_URL)
  async getEndSessionUrl(
    /**
     * @todo Adaptation for now, correspond to the oidc-provider side.
     * Named "OidcClient" because we need a future shared session between our libs oidc-provider and oidc-client
     * without a direct dependance like now.
     * @author Hugues
     * @date 2021-04-16
     * @ticket FC-xxx
     */
    @Session('OidcClient')
    sessionOidc: ISessionService<OidcClientSession>,
    @Query('post_logout_redirect_uri')
    postLogoutRedirectUri?: string,
  ): Promise<string | void> {
    const { idpIdToken, idpState, idpId } = await sessionOidc.get();

    const endSessionUrl: string =
      await this.oidcClient.getEndSessionUrlFromProvider(
        idpId,
        idpState,
        idpIdToken,
        postLogoutRedirectUri,
      );

    return endSessionUrl;
  }

  @Get(ExploitationRoutes.OIDC_CLIENT_LOGOUT_CALLBACK)
  async logoutCallback(@Req() req, @Res() res) {
    /**
     * @TODO #192 ETQ Dev, je complète la session pendant la cinématique des mocks
     * @see https://gitlab.dev-franceconnect.fr/france-connect/fc/-/issues/192
     */

    this.logger.trace({
      route: ExploitationRoutes.OIDC_CLIENT_LOGOUT_CALLBACK,
      method: 'GET',
      name: 'MockServiceProviderRoutes.LOGOUT_CALLBACK',
      redirect: '/',
    });

    // delete oidc session
    await this.sessionService.reset(req, res);

    // BUSINESS: Redirect to business page
    const redirect = '/';

    return res.redirect(redirect);
  }

  @Get(ExploitationRoutes.CSRF_TOKEN)
  async getCsrfToken(
    @Session('OidcClient')
    sessionOidc: ISessionService<OidcClientSession>,
  ): Promise<{ csrfToken: string }> {
    const csrfToken = this.csrfService.get();
    await this.csrfService.save(sessionOidc, csrfToken);

    return { csrfToken };
  }
}
