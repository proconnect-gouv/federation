import { encode } from 'querystring';

import {
  Controller,
  Get,
  Param,
  Query,
  Req,
  Res,
  UsePipes,
  ValidationPipe,
} from '@nestjs/common';

import { ConfigService } from '@fc/config';
import { CryptographyService } from '@fc/cryptography';
import { IdentityProviderAdapterEnvService } from '@fc/identity-provider-adapter-env';
import { LoggerLevelNames, LoggerService } from '@fc/logger';
import { IOidcIdentity, OidcSession } from '@fc/oidc';
import {
  GetOidcCallback,
  OidcClientConfig,
  OidcClientService,
  OidcClientSession,
} from '@fc/oidc-client';
import { ISessionService, Session } from '@fc/session';

import { ExploitationRoutes } from '../enums';

@Controller()
export class ExploitationController {
  // Dependency injection can require more than 4 parameters
  /* eslint-disable-next-line max-params */
  constructor(
    private readonly config: ConfigService,
    private readonly crypto: CryptographyService,
    private readonly oidcClient: OidcClientService,
    private readonly logger: LoggerService,
    private readonly identityProvider: IdentityProviderAdapterEnvService,
  ) {
    this.logger.setContext(this.constructor.name);
  }

  @Get(ExploitationRoutes.OIDC_CLIENT_GET_AUTHORIZE_URL)
  async getAuthorizeUrl(
    /**
     * @todo Adaptation for now, correspond to the oidc-provider side.
     * Named "OidcClient" because we need a future shared session between our libs oidc-provider and oidc-client
     * without a direct dependance like now.
     * @author Hugues
     * @date 2021-04-16
     * @ticket FC-xxx
     */
    @Session('OidcClient')
    sessionOidc: ISessionService<OidcClientSession>,
  ): Promise<string> {
    // Only one provider is available with `@fc/identity-provider-env`
    const [provider] = await this.identityProvider.getList();

    const { acr, claims, scope } =
      this.config.get<OidcClientConfig>('OidcClient');

    const { nonce, state } =
      await this.oidcClient.utils.buildAuthorizeParameters();

    const authorizationUrl: string =
      await this.oidcClient.utils.getAuthorizeUrl({
        // oidc parameter
        // eslint-disable-next-line @typescript-eslint/naming-convention
        acr_values: acr,
        claims,
        nonce,
        providerUid: provider.uid,
        scope,
        state,
      });

    const sessionIdLength = 32;
    const sessionId: string = this.crypto.genRandomString(sessionIdLength);

    await sessionOidc.set({
      sessionId,
      idpState: state,
      idpNonce: nonce,
    });

    return authorizationUrl;
  }

  /**
   * @TODO #308 ETQ DEV je veux éviter que deux appels Http soient réalisés au lieu d'un à la discovery Url dans le cadre d'oidc client
   * @see https://gitlab.dev-franceconnect.fr/france-connect/fc/-/issues/308
   */
  // needed for controller
  // eslint-disable-next-line max-params
  @Get(ExploitationRoutes.OIDC_CLIENT_CALLBACK)
  @UsePipes(new ValidationPipe({ whitelist: true }))
  async getOidcCallback(
    @Req() req,
    @Res() res,
    @Query() query,
    @Param() params: GetOidcCallback,
    /**
     * @todo Adaptation for now, correspond to the oidc-provider side.
     * Named "OidcClient" because we need a future shared session between our libs oidc-provider and oidc-client
     * without a direct dependance like now.
     * @author Hugues
     * @date 2021-04-16
     * @ticket FC-xxx
     */
    @Session('OidcClient')
    sessionOidc: ISessionService<OidcClientSession>,
  ) {
    /**
     * @todo Adaptation for now, we should probably find a better way to handle
     * errors on the oidc callback on the mock.
     * @Todo Since nodev16 should use the <URLSearchParams> API instead of querystring.encode
     *
     * @author Stéphane/Matthieu
     * @date 2021-05-12
     * @ticket FC-xxx
     */
    if (query.error) {
      const loginUri = `/login?${encode(query)}`;

      this.logger.trace({ query, loginUri }, LoggerLevelNames.WARN);

      return res.redirect(loginUri);
    }

    const { providerUid } = params;
    const { idpState, idpNonce } = await sessionOidc.get();

    const tokenParams = {
      providerUid,
      idpState,
      idpNonce,
    };
    const { accessToken, idToken, acr, amr } =
      await this.oidcClient.getTokenFromProvider(tokenParams, req);

    const userInfoParams = {
      accessToken,
      providerUid,
    };

    const identity: IOidcIdentity =
      await this.oidcClient.getUserInfosFromProvider(userInfoParams, req);

    /**
     * @todo
     *    action: Check the data returns from FC.
     *
     * @author Arnaud
     * @date 19/03/2020
     * @ticket FC-244 (identity, DTO, Mock, FS)
     */
    const identityExchange: OidcSession = {
      idpIdentity: identity,
      idpAcr: acr,
      amr,
      idpAccessToken: accessToken,
      idpIdToken: idToken,
    };

    await sessionOidc.set({ ...identityExchange });

    // BUSINESS: Redirect to business page
    const redirect = '/';

    this.logger.trace({
      route: ExploitationRoutes.OIDC_CLIENT_CALLBACK,
      method: 'GET',
      name: 'ExploitationRoutes.OIDC_CLIENT_CALLBACK',
      identityExchange,
      redirect,
    });

    res.redirect(redirect);
  }

  @Get(ExploitationRoutes.OIDC_CLIENT_LOAD_USER_INFOS)
  async loadUserInfos(
    @Session('OidcClient')
    sessionOidc: ISessionService<OidcClientSession>,
  ): Promise<{ connected: boolean; userinfos: string }> {
    const idpIdentity = await sessionOidc.get('idpIdentity');

    return {
      connected: idpIdentity ? true : false,
      userinfos: JSON.stringify(idpIdentity, null, 2),
    };
  }
}
