import { Test, TestingModule } from '@nestjs/testing';
import { DataProviderController } from './data-provider.controller';
import { DataProviderService } from './data-provider.service';
import {
  dataProviderServiceMock,
  scopeAndLabelMock,
  reqMock,
  resMock,
  scopeLabelsListMock,
  id,
} from './fixture/data-provider.fixtures';

describe('DataProvider Controller', () => {
  let controller: DataProviderController;
  let service: DataProviderService;

  const params = {
    id: '5da5e10291a8fb354fe51403',
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [DataProviderController],
      providers: [DataProviderService],
    })
      .overrideProvider(DataProviderService)
      .useValue(dataProviderServiceMock)
      .compile();

    controller = module.get<DataProviderController>(DataProviderController);
    service = await module.get<DataProviderService>(DataProviderService);

    jest.resetAllMocks();
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('List method', () => {
    it('should exist', () => {
      expect(controller.list).toBeDefined();
    });

    it('should return an array of scopeLabels', async () => {
      // Setup
      jest
        .spyOn(service, 'getScopesAndLabels')
        .mockImplementation(() => Promise.resolve(scopeLabelsListMock));
      jest
        .spyOn(service, 'getScopeAndLabelCount')
        .mockImplementation(() => Promise.resolve(3));

      // Action
      const result = await controller.list(reqMock);

      // Expected
      expect(result.scopeLabelsCount).toBeDefined();
      expect(result.scopeLabelsCount).toEqual(scopeLabelsListMock.length);
      expect(result.scopesAndLabelsList).toBeDefined();
      expect(result.scopesAndLabelsList[0].label).toBe(
        'Revenu fiscal de référence (DGFIP)',
      );
    });
  });

  describe('label/create', () => {
    describe('GET', () => {
      it('should exist', () => {
        expect(controller.showCreateForm).toBeDefined();
      });

      it('should return the csrf', async () => {
        // action
        const result = await controller.showCreateForm(reqMock);
        // assertion
        expect(result).toEqual({ csrfToken: 'foundationCsrfToken' });
      });
    });

    describe('POST', () => {
      it('should add a new scope label', async () => {
        // Action
        await controller.createScopeAndLabels(
          scopeAndLabelMock,
          reqMock,
          resMock,
        );
        // Expected
        expect(resMock.redirect).toHaveBeenCalledTimes(1);
        expect(resMock.redirect).toHaveBeenCalledWith(
          `${resMock.locals.APP_ROOT}/data-provider/label`,
        );
        expect(reqMock.flash).toHaveBeenCalledWith(
          'success',
          `Le label ${scopeAndLabelMock.label} pour le scope ${scopeAndLabelMock.scope} a été créé avec succès !`,
        );
      });

      it('should return to data-provider/label/create if it fails', async () => {
        // Setup
        const error = new Error('something');
        jest
          .spyOn(service, 'createScopeAndLabels')
          .mockRejectedValueOnce(error);

        // Action
        await controller.createScopeAndLabels(
          scopeAndLabelMock,
          reqMock,
          resMock,
        );
        // Expected
        expect(resMock.redirect).toHaveBeenCalledTimes(1);
        expect(resMock.redirect).toHaveBeenCalledWith(
          `${resMock.locals.APP_ROOT}/data-provider/label/create`,
        );
        expect(reqMock.flash).toHaveBeenCalledWith(
          'globalError',
          "Impossible d'enregistrer le label",
        );
      });
    });
  });

  describe('label/update/:id', () => {
    describe('GET', () => {
      it('should have a showCreateForm method', () => {
        expect(controller.showUpdateForm).toBeDefined();
      });

      it('should render the update form', async () => {
        // Setup
        dataProviderServiceMock.getScopeAndLabel.mockResolvedValueOnce({
          scope: 'myGreatScope',
          label: 'myGreatLabel',
          fd: 'myGreatFD',
        });

        // Action
        const result = await controller.showUpdateForm(id, reqMock);

        // Assertion
        expect(dataProviderServiceMock.getScopeAndLabel).toHaveBeenCalledTimes(
          1,
        );
        expect(dataProviderServiceMock.getScopeAndLabel).toHaveBeenCalledWith(
          id,
        );
        expect(result).toEqual({
          csrfToken: 'foundationCsrfToken',
          scope: 'myGreatScope',
          label: 'myGreatLabel',
          fd: 'myGreatFD',
          id,
        });
      });
    });

    describe('POST', () => {
      it('should exist', () => {
        expect(controller.updateScopeAndLabels).toBeDefined();
      });

      it('should update the scope label entry corresponding to the id param', async () => {
        // Setup
        const updatedScopeLabel = {
          scope: 'Seldon2222',
          label: 'Seldon222 Label (dgfip)',
          fd: 'DGFIP',
        };
        // Action
        await controller.updateScopeAndLabels(
          updatedScopeLabel,
          params.id,
          reqMock,
          resMock,
        );
        // Expected
        expect(resMock.redirect).toHaveBeenCalledTimes(1);
        expect(reqMock.flash).toHaveBeenCalledWith(
          'success',
          `Le label ${updatedScopeLabel.label} a été modifié avec succès !`,
        );
        expect(resMock.redirect).toHaveBeenCalledWith(
          `${resMock.locals.APP_ROOT}/data-provider/label`,
        );
      });

      it('should throw an error if scope label entry can not be update', async () => {
        // Setup
        const updatedScopeLabel = {
          scope: 'Seldon2222',
          label: 'Seldon222 Label (dgfip)',
          fd: 'DGFIP',
        };
        const error = new Error('something');

        jest.spyOn(service, 'updateScopeLabels').mockRejectedValueOnce(error);
        // Action
        await controller.updateScopeAndLabels(
          updatedScopeLabel,
          params.id,
          reqMock,
          resMock,
        );
        // Expected
        expect(resMock.redirect).toHaveBeenCalledTimes(1);
        expect(reqMock.flash).toHaveBeenCalledWith(
          'globalError',
          'Impossible de modifier le label',
        );
        expect(resMock.redirect).toHaveBeenCalledWith(
          `${resMock.locals.APP_ROOT}/data-provider/label/update/5da5e10291a8fb354fe51403`,
        );
      });
    });
  });

  describe('delete method', () => {
    it('should exist', () => {
      expect(controller.deleteScopeAndLabel).toBeDefined();
    });

    it('should delete the corresponding label', async () => {
      // Setup
      const body = {
        scope: 'toto',
        label: 'toto label',
        fd: 'dgfip',
      };

      // Action
      await controller.deleteScopeAndLabel(params.id, reqMock, resMock, body);

      // Expected
      expect(reqMock.flash).toHaveBeenCalledWith(
        'success',
        `Le scope ${body.scope}:  ${body.label} a été supprimé avec succès !`,
      );
      expect(resMock.redirect).toHaveBeenCalledTimes(1);
      expect(resMock.redirect).toHaveBeenCalledWith(
        `${resMock.locals.APP_ROOT}/data-provider/label`,
      );
    });
  });
});
