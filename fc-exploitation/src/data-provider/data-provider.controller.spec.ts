import { ObjectID } from 'mongodb';

import { Test } from '@nestjs/testing';
import { getRepositoryToken, TypeOrmModule } from '@nestjs/typeorm';

import { DataProviderController } from './data-provider.controller';
import { DataProvider } from './data-provider.mongodb.entity';
import { DataProviderService } from './data-provider.service';
import { ScopesService } from '../scopes';
import { IDataProvider } from './interface/data-provider.interface';

const scopeList = ['myscope'];

describe('DataProviderController', () => {
  let dataProviderController: DataProviderController;
  let dataProviderService: DataProviderService;

  const dataProviderRepositoryMock = {
    count: jest.fn(),
  };

  const dataProviderServiceMock = {
    paginate: jest.fn(),
    createDataProvider: jest.fn(),
    findById: jest.fn(),
    update: jest.fn(),
    deleteDataProviderById: jest.fn(),
    // generateNewSecret: jest.fn(),
  };

  const renderMock = {
    render: jest.fn(),
  };

  const res = {
    redirect: jest.fn(),
    status: jest.fn(),
    locals: {
      APP_ROOT: '/foo/bar',
    },
  };

  const dataProviderDtoMock: IDataProvider = {
    title: 'monfd',
    jwks_uri: 'https://monfd.com/jwks',
    active: true,
    scopes: [...scopeList],
  };

  const idParam = '11111111-2222-3333-4444-555555555555';

  const req = {
    flash: jest.fn(),
    params: { id: idParam },
    session: {},
    user: { id: idParam, username: 'mocker' },
    csrfToken: () => 'mygreatcsrftoken',
  };

  const scopesServiceMock = {
    getAll: jest.fn(),
    getScopesGroupedByFd: jest.fn(),
  };

  const claimsServiceMock = {
    getAll: jest.fn(),
  };

  const identityProviderServiceMock = {
    getAll: jest.fn(),
  };

  const scopesGroupMock = {
    fd1: [
      {
        fd: 'fd1',
        scope: 'fd1scope1',
        label: 'fd1scope1 label',
      },
      {
        fd: 'fd1',
        scope: 'fd1scope2',
        label: 'fd1scope2 label',
      },
    ],
    fd2: [
      {
        fd: 'fd2',
        scope: 'fd2scope1',
        label: 'fd2scope1 label',
      },
    ],
  };

  const userMock = 'toto';

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [],
      providers: [
        DataProviderController,
        {
          provide: getRepositoryToken(DataProvider, 'fc-mongo'),
          useValue: dataProviderRepositoryMock,
        },
        {
          provide: DataProviderService,
          useValue: dataProviderServiceMock,
        },
        {
          provide: ScopesService,
          useValue: scopesServiceMock,
        },
      ],
    }).compile();

    dataProviderController = await module.get<DataProviderController>(
      DataProviderController,
    );

    dataProviderService = await module.get<DataProviderService>(
      DataProviderService,
    );

    jest.resetAllMocks();

    // renderMock.render.mockReturnValueOnce(true);
    // res.status.mockReturnValueOnce(renderMock);
    // identityProviderServiceMock.getAll.mockResolvedValue(identityProvidersMock);
  });

  describe('list()', () => {
    it('returns the list of the available data providers', async () => {
      // Setup
      const page = '0';
      const limit = '10';
      const action = '';
      const search = '';

      // Mocking Items
      const itemTest1: DataProvider = {
        id: new ObjectID('5d35b91e70332098440d0f85'),
        uid: '6f21b751-ed06-48b6-a59c-36e1300a368a',
        title: 'dataprovider1',
        active: true,
        client_id: '76eded44d32b40c0cb1006065',
        client_secret:
          '6925fb8143c76eded44d32b40c0cb1006065f7f003de52712b78985704f39950',
        jwks_uri: 'https://monfd.com/jwks',
        secretCreatedAt: new Date(),
        createdAt: new Date(),
        updatedBy: userMock,
        scopes: [...scopeList],
      };

      // Mocking return value of DataProviderService.paginate()
      jest.spyOn(dataProviderService, 'paginate').mockResolvedValue({
        items: [itemTest1],
        itemCount: 1,
        total: 1,
        pageCount: 0,
        next: '',
        previous: '',
        totalItems: 1,
      });

      dataProviderRepositoryMock.count.mockResolvedValue(1);

      // Actions
      const spList = await dataProviderController.list(
        req,
        search,
        action,
        page,
        limit,
      );

      // Expected
      expect(spList.dataProviders).toMatchObject([itemTest1]);
      expect(spList.activeDataProvidersCount).toEqual(1);
    });
  });

  describe('createDataProvider()', () => {
    it('should call correct params when creating a data provider', async () => {
      // when
      await dataProviderController.createDataProvider(
        dataProviderDtoMock,
        req,
        res,
      );

      // then
      expect(dataProviderServiceMock.createDataProvider).toHaveBeenCalledTimes(
        1,
      );
      expect(dataProviderServiceMock.createDataProvider).toHaveBeenCalledWith(
        {
          ...dataProviderDtoMock,
        },
        req.user.username,
      );
    });
  });

  describe('showCreationForm()', () => {
    beforeEach(() => {
      scopesServiceMock.getScopesGroupedByFd.mockResolvedValue(scopesGroupMock);
    });

    it('Should get data provider creation and render view', async () => {
      // when
      const result = await dataProviderController.showCreationForm(req);

      // then
      expect(result).toEqual({
        csrfToken: 'mygreatcsrftoken',
        scopesGroupedByFd: scopesGroupMock,
      });
    });
  });

  describe('findOne(), get a data provider', () => {
    const dataProviderData = {
      id: idParam,
      title: 'ProConnect TEST find one',
      jwks_uri: 'https://example.com/jwks',
      active: true,
      scopes: [...scopeList],
    };

    it('should get a data Provider and render update view', async () => {
      // setup
      const dpMock = {
        ...dataProviderData,
      };
      dataProviderServiceMock.findById.mockResolvedValue(dpMock);
      scopesServiceMock.getScopesGroupedByFd.mockResolvedValue(scopesGroupMock);
      // action
      const result = await dataProviderController.findOne(idParam, req);
      // expect
      expect(req.flash).toHaveBeenCalledTimes(1);
      expect(req.flash).toHaveBeenCalledWith('values', {
        ...dpMock,
      });
      expect(result).toEqual({
        id: idParam,
        csrfToken: 'mygreatcsrftoken',
        scopesGroupedByFd: scopesGroupMock,
      });
    });

    it('should not load the data provider if coming from a failed update', async () => {
      // a failed update will have set the session flash values
      const session = {
        flash: { values: [{ title: 'previous' }], errors: ['some error'] },
      };

      await dataProviderController.findOne(idParam, {
        ...req,
        session,
      });

      expect(dataProviderServiceMock.findById).not.toHaveBeenCalled();
      expect(req.flash).not.toHaveBeenCalled();
    });
  });

  describe('dataProviderUpdate()', () => {
    it('should update a dataProvider and return to the dataProvider page', async () => {
      await dataProviderController.dataProviderUpdate(
        dataProviderDtoMock,
        idParam,
        req,
        res,
      );
      expect(dataProviderServiceMock.update).toHaveBeenCalledWith(
        idParam,
        dataProviderDtoMock,
        req.user.username,
      );
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/data-provider/${idParam}`,
      );
    });

    it("should redirect to the dataProvider if we can't update the dataProvider", async () => {
      dataProviderServiceMock.update.mockRejectedValue(new Error());

      // action
      await dataProviderController.dataProviderUpdate(
        dataProviderDtoMock,
        idParam,
        req,
        res,
      );

      // assertion
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/data-provider/${idParam}`,
      );
    });
  });

  describe('Delete data provider', () => {
    it('Should redirect if data provider is removed', async () => {
      // set up
      const id = 'dp-id';
      const body = { title: 'dp-title' };

      // action
      dataProviderServiceMock.deleteDataProviderById.mockResolvedValue({});
      await dataProviderController.deleteDataProvider(id, req, res, body);

      // expect
      expect(
        dataProviderServiceMock.deleteDataProviderById,
      ).toHaveBeenCalledWith(id, req.user.username);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/data-provider`,
      );
      expect(req.flash).toHaveBeenCalledWith(
        'success',
        `Le fournisseur de données ${body.title} a été supprimé avec succès !`,
      );
    });

    it('In case of error, should not redirect the user but set the res status to 500', async () => {
      // set up
      const id = 'dp-id';
      const body = { title: 'dp-title' };
      dataProviderServiceMock.deleteDataProviderById.mockRejectedValue(
        new Error('Try again buddy'),
      );

      // action
      await dataProviderController.deleteDataProvider(id, req, res, body);

      // expect
      expect(req.flash).toHaveBeenCalledWith('globalError', 'Try again buddy');
      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.redirect).not.toHaveBeenCalled();
    });
  });

  describe('GenerateNewSecret View', () => {
    //   it('should get a data Provider and render generate client secret view', async () => {
    //     claimsServiceMock.getAll.mockResolvedValue(claimsListMock);
    //     const dataProvider = {
    //       IPServerAddressesAndRanges: ['1.1.1.1'],
    //       active: 'true',
    //       email: ['v@b.com'],
    //       emails: 'v@b.com',
    //       ipsRanges: '1.1.1.1',
    //       key: 'cb55015c-7fb5-49b4-9006-e523552bc3e7',
    //       name: 'ProConnect Generate Secret 9',
    //       postLogoutUri: 'https://proConnect.com',
    //       post_logout_redirect_uris: ['https://proConnect.com'],
    //       redirectUri: 'https://proConnect.com',
    //       redirect_uris: ['https://proConnect.com'],
    //       site: 'https://proConnect8888.com',
    //       status: 'public',
    //       scopes: [...scopeList],
    //       trustedIdentity: false,
    //     };
    //     dataProviderServiceMock.findById.mockResolvedValue(dataProvider);
    //     scopesServiceMock.getScopesGroupedByFd.mockResolvedValue(scopesGroupMock);
    //     const result = await dataProviderController.findOne(idParam, req);
    //     expect(req.flash).toHaveBeenCalledTimes(1);
    //     expect(req.flash).toHaveBeenCalledWith('values', {
    //       ...dataProvider,
    //     });
    //     expect(result).toEqual({
    //       id: idParam,
    //       csrfToken: 'mygreatcsrftoken',
    //       scopesGroupedByFd: scopesGroupMock,
    //     });
    //   });
  });

  describe('Generate a new client secret', () => {
    //   it('Should redirect after generation of a client secret', async () => {
    //     // set up
    //     const dataProvider = {
    //       IPServerAddressesAndRanges: ['1.1.1.1'],
    //       active: 'true',
    //       email: ['v@b.com'],
    //       emails: 'v@b.com',
    //       ipsRanges: '1.1.1.1',
    //       key: 'cb55015c-7fb5-49b4-9006-e523552bc3e7',
    //       name: 'FranceConnect TEST 9',
    //       postLogoutUri: 'https://FranceConnect.com',
    //       post_logout_redirect_uris: ['https://FranceConnect.com'],
    //       redirectUri: 'https://FranceConnect.com',
    //       redirect_uris: ['https://FranceConnect.com'],
    //       site: 'https://FranceConnect8888.com',
    //       status: 'public',
    //       client_secret:
    //         '$2b$10$EO3FnI3YKfnnvUlvr084wegEgEPeRPRMdE2VJwMHpAsNkaMv1n9pG',
    //       scopes: [...scopeList],
    //       trustedIdentity: false,
    //     };
    //     const generateNewClientSecretDTO = {
    //       name: 'aaa, bbb, ccc',
    //       key: 'clientID',
    //       client_secret: 'ancien secret hash',
    //     };
    //     const key = 'key';
    //     // action
    //     dataProviderServiceMock.generateNewSecret.mockReturnValueOnce(
    //       dataProvider,
    //     );
    //     await dataProviderController.generateNewClientSecret(
    //       key,
    //       generateNewClientSecretDTO,
    //       req,
    //       res,
    //     );
    //     // expect
    //     expect(
    //       dataProviderServiceMock.generateNewSecret,
    //     ).toHaveBeenCalledTimes(1);
    //     expect(res.redirect).toHaveBeenCalledWith(
    //       `${res.locals.APP_ROOT}/data-provider`,
    //     );
    //   });
    //   it('Should redirect after generation of a client secret', async () => {
    //     // set up
    //     const generateNewClientSecretDTO = {
    //       name: 'aaa, bbb, ccc',
    //       key: 'clientID',
    //       client_secret: 'ancien secret hash',
    //     };
    //     const key = 'key';
    //     // action
    //     dataProviderServiceMock.generateNewSecret.mockRejectedValueOnce(
    //       new Error(),
    //     );
    //     await dataProviderController.generateNewClientSecret(
    //       key,
    //       generateNewClientSecretDTO,
    //       req,
    //       res,
    //     );
    //     // expect
    //     expect(
    //       dataProviderServiceMock.generateNewSecret,
    //     ).toHaveBeenCalledTimes(1);
    //     expect(res.status).toHaveBeenCalledWith(500);
    //     expect(res.redirect).toHaveBeenCalledTimes(0);
    //   });
  });
});
