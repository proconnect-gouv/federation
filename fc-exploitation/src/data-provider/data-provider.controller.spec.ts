import { ObjectID } from 'mongodb';
import { Test, TestingModule } from '@nestjs/testing';
import { IScopes, scopesMock, scopesListMock, ScopesService } from '../scopes';
import { DataProviderController } from './data-provider.controller';
import { reqMock, resMock } from './fixture/data-provider.fixtures';

const id: ObjectID = new ObjectID('5d9c677da8bb151b00720451');

const ScopesServiceMock = {
  create: jest.fn(),
  update: jest.fn(),
  delete: jest.fn(),
  count: jest.fn(),
  getAllScopes: jest.fn(),
  getScopesByType: jest.fn(),
  getScopesById: jest.fn(),
};

describe('DataProvider Controller', () => {
  let controller: DataProviderController;
  let scopeService: ScopesService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [DataProviderController],
      providers: [ScopesService],
    })
      .overrideProvider(ScopesService)
      .useValue(ScopesServiceMock)
      .compile();

    controller = module.get<DataProviderController>(DataProviderController);
    scopeService = await module.get<ScopesService>(ScopesService);

    jest.resetAllMocks();
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('list()', () => {
    it('should exist', () => {
      expect(controller.list).toBeDefined();
    });

    it('should return an array of scopes', async () => {
      // Setup
      jest
        .spyOn(scopeService, 'getAllScopes')
        .mockImplementation(() => Promise.resolve(scopesListMock));
      jest
        .spyOn(scopeService, 'count')
        .mockImplementation(() => Promise.resolve(3));

      // Action
      const result = await controller.list(reqMock);

      // Expected
      expect(result.scopesCount).toBeDefined();
      expect(result.scopesCount).toEqual(scopesListMock.length);
      expect(result.scopesAndLabelsList).toBeDefined();
      expect(result.scopesAndLabelsList[0].label).toBe(
        'Revenu fiscal de référence (IDENTITY)',
      );
    });
  });

  describe('label/create', () => {
    describe('GET', () => {
      it('should exist', () => {
        expect(controller.showCreateForm).toBeDefined();
      });

      it('should return the csrf', async () => {
        // action
        const result = await controller.showCreateForm(reqMock);
        // assertion
        expect(result).toEqual({ csrfToken: 'foundationCsrfToken' });
      });
    });

    describe('createScopeAndLabels()', () => {
      it('should add a new scope label', async () => {
        // Action
        await controller.createScopeAndLabels(scopesMock, reqMock, resMock);
        // Expected
        expect(resMock.redirect).toHaveBeenCalledTimes(1);
        expect(resMock.redirect).toHaveBeenCalledWith(
          `${resMock.locals.APP_ROOT}/data-provider/label`,
        );
        expect(reqMock.flash).toHaveBeenCalledWith(
          'success',
          `Le label ${scopesMock.label} pour le scope ${scopesMock.scope} a été créé avec succès !`,
        );
      });

      it('should return to data-provider/label/create if it fails', async () => {
        // Setup
        const error = new Error('something');
        jest.spyOn(scopeService, 'create').mockRejectedValueOnce(error);

        // Action
        await controller.createScopeAndLabels(scopesMock, reqMock, resMock);
        // Expected
        expect(resMock.redirect).toHaveBeenCalledTimes(1);
        expect(resMock.redirect).toHaveBeenCalledWith(
          `${resMock.locals.APP_ROOT}/data-provider/label/create`,
        );
        expect(reqMock.flash).toHaveBeenCalledWith(
          'globalError',
          "Impossible d'enregistrer le label",
        );
      });
    });
  });

  describe('label/update/:id', () => {
    describe('GET', () => {
      it('should have a showCreateForm method', () => {
        expect(controller.showUpdateForm).toBeDefined();
      });

      it('should render the update form', async () => {
        // Setup
        ScopesServiceMock.getScopesById.mockResolvedValueOnce({
          scope: 'myGreatScope',
          label: 'myGreatLabel',
          fd: 'myGreatFD',
        });

        // Action
        const result = await controller.showUpdateForm(id, reqMock);

        // Assertion
        expect(ScopesServiceMock.getScopesById).toHaveBeenCalledTimes(1);
        expect(ScopesServiceMock.getScopesById).toHaveBeenCalledWith(id);
        expect(result).toEqual({
          csrfToken: 'foundationCsrfToken',
          scope: 'myGreatScope',
          label: 'myGreatLabel',
          fd: 'myGreatFD',
          id,
        });
      });
    });

    describe('updateScopeAndLabels()', () => {
      it('should exist', () => {
        expect(controller.updateScopeAndLabels).toBeDefined();
      });

      it('should update the scope label entry corresponding to the id param', async () => {
        // Setup
        const updatedScopeLabel: IScopes = {
          id: new ObjectID('5d9c677da8bb151b00720451'),
          fd: 'DGFIP',
          scope: 'Seldon2222',
          label: 'Seldon222 Label (dgfip)',
        };
        // Action
        await controller.updateScopeAndLabels(
          updatedScopeLabel,
          id,
          reqMock,
          resMock,
        );
        // Expected
        expect(resMock.redirect).toHaveBeenCalledTimes(1);
        expect(reqMock.flash).toHaveBeenCalledWith(
          'success',
          `Le label ${updatedScopeLabel.label} a été modifié avec succès !`,
        );
        expect(resMock.redirect).toHaveBeenCalledWith(
          `${resMock.locals.APP_ROOT}/data-provider/label`,
        );
      });

      it('should throw an error if scope label entry can not be update', async () => {
        // Setup
        const updatedScopeLabel: IScopes = {
          id: new ObjectID('5d9c677da8bb151b00720451'),
          fd: 'DGFIP',
          scope: 'Seldon2222',
          label: 'Seldon222 Label (dgfip)',
        };
        const error = new Error('something');

        jest.spyOn(scopeService, 'update').mockRejectedValueOnce(error);
        // Action
        await controller.updateScopeAndLabels(
          updatedScopeLabel,
          id,
          reqMock,
          resMock,
        );
        // Expected
        expect(resMock.redirect).toHaveBeenCalledTimes(1);
        expect(reqMock.flash).toHaveBeenCalledWith(
          'globalError',
          'Impossible de modifier le label',
        );
        expect(resMock.redirect).toHaveBeenCalledWith(
          `${resMock.locals.APP_ROOT}/data-provider/label/update/5d9c677da8bb151b00720451`,
        );
      });
    });
  });

  describe('deleteScopeAndLabel()', () => {
    it('should exist', () => {
      expect(controller.deleteScopeAndLabel).toBeDefined();
    });

    it('should delete the corresponding label', async () => {
      // Setup
      const body = {
        scope: 'toto',
        label: 'toto label',
        fd: 'dgfip',
      };

      // Action
      await controller.deleteScopeAndLabel(id, reqMock, resMock, body);

      // Expected
      expect(reqMock.flash).toHaveBeenCalledWith(
        'success',
        `Le scope ${body.scope}:  ${body.label} a été supprimé avec succès !`,
      );
      expect(resMock.redirect).toHaveBeenCalledTimes(1);
      expect(resMock.redirect).toHaveBeenCalledWith(
        `${resMock.locals.APP_ROOT}/data-provider/label`,
      );
    });
  });

  it('should throw an error if scope label entry can not be update', async () => {
    // Setup
    const body = {
      scope: 'toto',
      label: 'toto label',
      fd: 'dgfip',
    };
    const error = new Error('something');

    jest.spyOn(scopeService, 'delete').mockRejectedValueOnce(error);
    // Action
    await controller.deleteScopeAndLabel(id, reqMock, resMock, body);

    // Expected
    expect(resMock.redirect).toHaveBeenCalledTimes(1);
    expect(reqMock.flash).toHaveBeenCalledWith('globalError', 'something');
    expect(resMock.redirect).toHaveBeenCalledWith(
      `${resMock.locals.APP_ROOT}/data-provider/label`,
    );
  });

  it('call scopeService.delete', async () => {
    // Setup
    const body = {
      scope: 'toto',
      label: 'toto label',
      fd: 'dgfip',
    };
    const error = new Error('something');

    jest.spyOn(scopeService, 'delete').mockRejectedValueOnce(error);

    // Action
    await controller.deleteScopeAndLabel(id, reqMock, resMock, body);

    // Expected
    expect(scopeService.delete).toHaveBeenCalledTimes(1);
    expect(scopeService.delete).toHaveBeenCalledWith(id, reqMock.user.username);
  });
});
