import { ObjectID } from 'mongodb';

import { Test } from '@nestjs/testing';
import { getRepositoryToken, TypeOrmModule } from '@nestjs/typeorm';

import { DataProviderController } from './data-provider.controller';
import { DataProvider } from './data-provider.mongodb.entity';
import { DataProviderService } from './data-provider.service';
import { ScopesService } from '../scopes';
import { IDataProvider } from './interface/data-provider.interface';

const scopeList = ['myscope'];

describe('DataProviderController', () => {
  let dataProviderController: DataProviderController;
  let dataProviderService: DataProviderService;

  const dataProviderRepositoryMock = {
    count: jest.fn(),
  };

  const dataProviderServiceMock = {
    paginate: jest.fn(),
    createDataProvider: jest.fn(),
    findById: jest.fn(),
    update: jest.fn(),
    deleteDataProviderById: jest.fn(),
    generateNewSecret: jest.fn(),
  };

  const renderMock = {
    render: jest.fn(),
  };

  const res = {
    redirect: jest.fn(),
    status: jest.fn(),
    locals: {
      APP_ROOT: '/foo/bar',
    },
  };

  const dataProviderDtoMock: IDataProvider = {
    title: 'monfd',
    jwks_uri: 'https://monfd.com/jwks',
    active: true,
    scopes: [...scopeList],
    checktoken_signed_response_alg: 'ES256',
    checktoken_encrypted_response_alg: 'RSA-OAEP',
    checktoken_encrypted_response_enc: 'A256GCM',
  };

  const idParam = '11111111-2222-3333-4444-555555555555';

  const req = {
    flash: jest.fn(),
    params: { id: idParam },
    session: {},
    user: { id: idParam, username: 'mocker' },
    csrfToken: () => 'mygreatcsrftoken',
  };

  const scopesServiceMock = {
    getAll: jest.fn(),
    getScopesGroupedByFd: jest.fn(),
  };

  const claimsServiceMock = {
    getAll: jest.fn(),
  };

  const identityProviderServiceMock = {
    getAll: jest.fn(),
  };

  const scopesGroupMock = {
    fd1: [
      {
        fd: 'fd1',
        scope: 'fd1scope1',
        label: 'fd1scope1 label',
      },
      {
        fd: 'fd1',
        scope: 'fd1scope2',
        label: 'fd1scope2 label',
      },
    ],
    fd2: [
      {
        fd: 'fd2',
        scope: 'fd2scope1',
        label: 'fd2scope1 label',
      },
    ],
  };

  const userMock = 'toto';

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [],
      providers: [
        DataProviderController,
        {
          provide: getRepositoryToken(DataProvider, 'fc-mongo'),
          useValue: dataProviderRepositoryMock,
        },
        {
          provide: DataProviderService,
          useValue: dataProviderServiceMock,
        },
        {
          provide: ScopesService,
          useValue: scopesServiceMock,
        },
      ],
    }).compile();

    dataProviderController = await module.get<DataProviderController>(
      DataProviderController,
    );

    dataProviderService = await module.get<DataProviderService>(
      DataProviderService,
    );

    jest.resetAllMocks();

    // renderMock.render.mockReturnValueOnce(true);
    // res.status.mockReturnValueOnce(renderMock);
    // identityProviderServiceMock.getAll.mockResolvedValue(identityProvidersMock);
  });

  describe('list()', () => {
    it('returns the list of the available data providers', async () => {
      // Setup
      const page = '0';
      const limit = '10';
      const action = '';
      const search = '';

      // Mocking Items
      const itemTest1: DataProvider = {
        id: new ObjectID('5d35b91e70332098440d0f85'),
        uid: '6f21b751-ed06-48b6-a59c-36e1300a368a',
        title: 'dataprovider1',
        active: true,
        client_id: '76eded44d32b40c0cb1006065',
        client_secret:
          '6925fb8143c76eded44d32b40c0cb1006065f7f003de52712b78985704f39950',
        jwks_uri: 'https://monfd.com/jwks',
        secretCreatedAt: new Date(),
        createdAt: new Date(),
        updatedBy: userMock,
        scopes: [...scopeList],
      };

      // Mocking return value of DataProviderService.paginate()
      jest.spyOn(dataProviderService, 'paginate').mockResolvedValue({
        items: [itemTest1],
        itemCount: 1,
        total: 1,
        pageCount: 0,
        next: '',
        previous: '',
        totalItems: 1,
      });

      dataProviderRepositoryMock.count.mockResolvedValue(1);

      // Actions
      const spList = await dataProviderController.list(
        req,
        search,
        action,
        page,
        limit,
      );

      // Expected
      expect(spList.dataProviders).toMatchObject([itemTest1]);
      expect(spList.activeDataProvidersCount).toEqual(1);
    });
  });

  describe('createDataProvider()', () => {
    it('should call correct params when creating a data provider', async () => {
      // when
      await dataProviderController.createDataProvider(
        dataProviderDtoMock,
        req,
        res,
      );

      // then
      expect(dataProviderServiceMock.createDataProvider).toHaveBeenCalledTimes(
        1,
      );
      expect(dataProviderServiceMock.createDataProvider).toHaveBeenCalledWith(
        {
          ...dataProviderDtoMock,
        },
        req.user.username,
      );
    });
  });

  describe('showCreationForm()', () => {
    beforeEach(() => {
      scopesServiceMock.getScopesGroupedByFd.mockResolvedValue(scopesGroupMock);
    });

    it('Should get data provider creation and render view', async () => {
      // when
      const result = await dataProviderController.showCreationForm(req);

      // then
      expect(result).toEqual({
        csrfToken: 'mygreatcsrftoken',
        scopesGroupedByFd: scopesGroupMock,
      });
    });
  });

  describe('findOne(), get a data provider', () => {
    const dataProviderData = {
      id: idParam,
      title: 'ProConnect TEST find one',
      jwks_uri: 'https://example.com/jwks',
      active: true,
      scopes: [...scopeList],
    };

    it('should get a data Provider and render update view', async () => {
      // setup
      const dpMock = {
        ...dataProviderData,
      };
      dataProviderServiceMock.findById.mockResolvedValue(dpMock);
      scopesServiceMock.getScopesGroupedByFd.mockResolvedValue(scopesGroupMock);
      // action
      const result = await dataProviderController.findOne(idParam, req);
      // expect
      expect(req.flash).toHaveBeenCalledTimes(1);
      expect(req.flash).toHaveBeenCalledWith('values', {
        ...dpMock,
      });
      expect(result).toEqual({
        id: idParam,
        csrfToken: 'mygreatcsrftoken',
        scopesGroupedByFd: scopesGroupMock,
      });
    });

    it('should not load the data provider if coming from a failed update', async () => {
      // a failed update will have set the session flash values
      const session = {
        flash: { values: [{ title: 'previous' }], errors: ['some error'] },
      };

      await dataProviderController.findOne(idParam, {
        ...req,
        session,
      });

      expect(dataProviderServiceMock.findById).not.toHaveBeenCalled();
      expect(req.flash).not.toHaveBeenCalled();
    });
  });

  describe('dataProviderUpdate()', () => {
    it('should update a dataProvider and return to the dataProvider page', async () => {
      await dataProviderController.dataProviderUpdate(
        dataProviderDtoMock,
        idParam,
        req,
        res,
      );
      expect(dataProviderServiceMock.update).toHaveBeenCalledWith(
        idParam,
        dataProviderDtoMock,
        req.user.username,
      );
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/data-provider/${idParam}`,
      );
    });

    it("should redirect to the dataProvider if we can't update the dataProvider", async () => {
      dataProviderServiceMock.update.mockRejectedValue(new Error());

      // action
      await dataProviderController.dataProviderUpdate(
        dataProviderDtoMock,
        idParam,
        req,
        res,
      );

      // assertion
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/data-provider/${idParam}`,
      );
    });
  });

  describe('Delete data provider', () => {
    it('Should redirect if data provider is removed', async () => {
      // set up
      const id = 'dp-id';
      const body = { title: 'dp-title' };

      // action
      dataProviderServiceMock.deleteDataProviderById.mockResolvedValue({});
      await dataProviderController.deleteDataProvider(id, req, res, body);

      // expect
      expect(
        dataProviderServiceMock.deleteDataProviderById,
      ).toHaveBeenCalledWith(id, req.user.username);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/data-provider`,
      );
      expect(req.flash).toHaveBeenCalledWith(
        'success',
        `Le fournisseur de données ${body.title} a été supprimé avec succès !`,
      );
    });

    it('In case of error, should not redirect the user but set the res status to 500', async () => {
      // set up
      const id = 'dp-id';
      const body = { title: 'dp-title' };
      dataProviderServiceMock.deleteDataProviderById.mockRejectedValue(
        new Error('Try again buddy'),
      );

      // action
      await dataProviderController.deleteDataProvider(id, req, res, body);

      // expect
      expect(req.flash).toHaveBeenCalledWith('globalError', 'Try again buddy');
      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.redirect).not.toHaveBeenCalled();
    });
  });

  describe('GenerateNewSecret View', () => {
    it('should get a data provider and render generate client secret view', async () => {
      const dataProviderData = {
        active: 'true',
        title: 'dp-title',
        client_id: 'dp-client-id',
        client_secret: 'dp-client-secret',
      };
      dataProviderServiceMock.findById.mockResolvedValue(dataProviderData);

      const result = await dataProviderController.findOne(idParam, req);

      expect(req.flash).toHaveBeenCalledWith('values', {
        ...dataProviderData,
      });
      expect(result).toEqual({
        id: idParam,
        csrfToken: 'mygreatcsrftoken',
      });
    });
  });

  describe('generateNewSecret', () => {
    it('should redirect after generation of a client secret', async () => {
      // set up
      dataProviderServiceMock.generateNewSecret.mockResolvedValue({});

      // action
      await dataProviderController.generateNewClientSecret(
        idParam,
        { title: 'dp-title' },
        req,
        res,
      );

      // expect
      expect(dataProviderServiceMock.generateNewSecret).toHaveBeenCalledWith(
        idParam,
        req.user.username,
      );
      expect(req.flash).toHaveBeenCalledWith(
        'success',
        `Le nouveau client secret du fournisseur de données dp-title a été généré avec succès !`,
      );
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/data-provider`,
      );
    });

    it('in case of error, should not redirect the user but set the res status to 500', async () => {
      // set up
      const id = 'dp-id';
      const body = { title: 'dp-title' };
      dataProviderServiceMock.generateNewSecret.mockRejectedValue(
        new Error('Try again buddy'),
      );

      // action
      await dataProviderController.generateNewClientSecret(
        idParam,
        { title: 'dp-title' },
        req,
        res,
      );

      // expect
      expect(req.flash).toHaveBeenCalledWith('globalError', 'Try again buddy');
      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.redirect).not.toHaveBeenCalled();
    });
  });
});
