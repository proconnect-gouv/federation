import { Model } from 'mongoose';
import { Repository } from 'mongodb';

import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { InjectModel } from '@nestjs/mongoose';

import { DataProvider } from './data-provider.mongodb.entity';
import { IOptions } from '@fc/shared/pagination/interface/options-query-mongodb.interface';
import { IDataProvider } from './interface/data-provider.interface';

@Injectable()
export class DataProviderService {
  constructor(
    @InjectRepository(DataProvider, 'fc-mongo')
    private readonly dataProviderRepository: Repository<DataProvider>,
    @InjectModel('DataProvider')
    private readonly dataProviderModel: Model<IDataProvider>,
  ) {}

  // private track(log: ICrudTrack) {
  //   this.logger.businessEvent(log);
  // }

  // async createDataProvider(
  //   dataProviderCreation: IDataProvider,
  //   user: string,
  // ) {
  //   const key: string = this.secretAdapter.generateKey();

  //   const entityId =
  //     dataProviderCreation.entityId || this.secretAdapter.generateKey();

  //   const transformToLegacy = this.transformIntoLegacy(dataProviderCreation);
  //   const now = new Date();

  //   const saveOperation = await this.dataProviderRepository.insertOne({
  //     ...transformToLegacy,
  //     // Set by default
  //     active: dataProviderCreation.active,
  //     client_secret: this.secretManager.encrypt(
  //       this.secretAdapter.generateSecret(),
  //     ),
  //     secretCreatedAt: now,
  //     createdAt: now,
  //     updatedAt: now,
  //     secretUpdatedAt: now,
  //     updatedBy: user,
  //     secretUpdatedBy: user,
  //     key,
  //     entityId,
  //     // DEPRECATED
  //     credentialFlow: false,
  //   });

  //   this.track({
  //     entity: 'data-provider',
  //     action: 'create',
  //     user,
  //     name: key,
  //     id: saveOperation.insertedId,
  //   });

  //   return saveOperation;
  // }

  // async findById(id: string): Promise<DataProvider> {
  //   const dataProvider = await this.dataProviderRepository.findOne(id);
  //   dataProvider.client_secret = this.secretManager.decrypt(
  //     dataProvider.client_secret,
  //   );
  //   return dataProvider;
  // }

  // async update(
  //   id: string,
  //   input: IDataProvider,
  //   user: string,
  // ): Promise<IDataProvider> {
  //   const dataProvider = await this.dataProviderRepository.findOne(id);

  //   dataProvider.name = input.name;
  //   dataProvider.redirect_uris = input.redirectUri;
  //   dataProvider.post_logout_redirect_uris = input.redirectUriLogout;
  //   dataProvider.site = input.site;
  //   dataProvider.type = input.type;
  //   dataProvider.email = input.emails.join('\n');
  //   dataProvider.active = input.active;
  //   dataProvider.IPServerAddressesAndRanges = input.ipAddresses;
  //   dataProvider.updatedAt = new Date();
  //   dataProvider.updatedBy = user;
  //   dataProvider.userinfo_signed_response_alg =
  //     input.userinfo_signed_response_alg;
  //   dataProvider.id_token_signed_response_alg =
  //     input.id_token_signed_response_alg;
  //   dataProvider.claims = input.claims;

  //   /*
  //    * Since we have "legacy SPs" with no scope at all, we want to describe some rules
  //    * to update the scopes:
  //    * - If the user, send scopes (input.scopes) or the SP already has scopes (dataProvider.scopes)
  //    * we want at least the scope "openid".
  //    * - If the user doesn't send scopes but the SP already have scopes, we want at least the scope "openid".
  //    * - If the user doesn't send scope AND the SP doesn't have scopes, we do not want to update scopes because
  //    * this SP is legacy and we do not want any filter.
  //    * - If the user send scope AND the SP doesn't have scopes, we want least the scope "openid".
  //    */
  //   if (input.scopes || dataProvider.scopes) {
  //     const uniqueScopes = new Set(['openid', ...(input.scopes || [])]);

  //     dataProvider.scopes = [...uniqueScopes];
  //   }

  //   this.track({
  //     entity: 'data-provider',
  //     action: 'update',
  //     user,
  //     id,
  //     name: dataProvider.key,
  //   });

  //   return this.dataProviderRepository.save(dataProvider);
  // }

  // /**
  //  * Due to multiple bugs in typeorm with mongodb,
  //  * we have a hard time retrieving multiple sp by id.
  //  *
  //  * Dirty costly solution: iterate through given ids
  //  */
  // async deleteManyDataProvidersById(ids: string[], user: string) {
  //   ids.forEach(id => this.deleteDataProviderById(id, user));
  // }

  // async deleteDataProviderById(id: string, user: string): Promise<boolean> {
  //   const dataProvider = await this.dataProviderRepository.findOne(id);

  //   await this.dataProviderRepository.delete(id);

  //   this.track({
  //     entity: 'data-provider',
  //     action: 'delete',
  //     user,
  //     id,
  //     name: dataProvider.key,
  //   });

  //   return dataProvider;
  // }

  // async generateNewSecret(
  //   dataProviderID: string,
  //   currentUser: string,
  // ): Promise<DataProvider> {
  //   const dataProvider = await this.dataProviderRepository.findOne(
  //     dataProviderID,
  //   );

  //   const unEncryptedSecret = await this.secretAdapter.generateSecret();

  //   const newClientSecret = await this.secretManager.encrypt(unEncryptedSecret);

  //   const pastClientSecret = dataProvider.client_secret;
  //   const now = new Date();

  //   dataProvider.past_client_secret = pastClientSecret;
  //   dataProvider.client_secret = newClientSecret;
  //   dataProvider.updatedAt = now;
  //   dataProvider.secretUpdatedAt = now;
  //   dataProvider.secretUpdatedBy = currentUser;

  //   return this.dataProviderRepository.save(dataProvider);
  // }

  async paginate(option: IOptions) {
    const parameters: IOptions = {
      page: option.page,
      limit: option.limit,
      defaultLimit: option.defaultLimit,
      userSearch: option.userSearch,
    };

    if (option.sort) {
      parameters.sort = option.sort;
    }

    if (option.action) {
      parameters.action = option.action;
    }

    return this.dataProviderModel.paginate({}, option.route, parameters);
  }
}
