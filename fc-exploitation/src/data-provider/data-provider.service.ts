import { Model } from 'mongoose';
import { MongoRepository } from 'typeorm';

import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { InjectModel } from '@nestjs/mongoose';

import { DataProvider } from './data-provider.mongodb.entity';
import { IOptions } from '@fc/shared/pagination/interface/options-query-mongodb.interface';
import { IDataProvider } from './interface/data-provider.interface';
import { ICrudTrack } from '../interfaces';
import { LoggerService } from '@fc/shared/logger/logger.service';
import { SecretAdapter } from '../utils/secret.adapter';
import { SecretManagerService } from '../utils/secret-manager.service';

@Injectable()
export class DataProviderService {
  constructor(
    @InjectRepository(DataProvider, 'fc-mongo')
    private readonly dataProviderRepository: MongoRepository<DataProvider>,
    @InjectModel('DataProvider')
    private readonly dataProviderModel: Model<IDataProvider>,
    private readonly secretAdapter: SecretAdapter,
    private readonly secretManager: SecretManagerService,
    private readonly logger: LoggerService,
  ) {}

  private track(log: ICrudTrack) {
    this.logger.businessEvent(log);
  }

  async createDataProvider(dataProviderCreation: IDataProvider, user: string) {
    const uid: string = this.secretAdapter.generateKey();

    const now = new Date();

    const saveOperation = await this.dataProviderRepository.insertOne({
      ...dataProviderCreation,
      uid,
      client_id: this.secretAdapter.generateKey(),
      client_secret: this.secretManager.encrypt(
        this.secretAdapter.generateSecret(),
      ),
      secretCreatedAt: now,
      createdAt: now,
      updatedAt: now,
      secretUpdatedAt: now,
      updatedBy: user,
      secretUpdatedBy: user,
    });

    this.track({
      entity: 'data-provider',
      action: 'create',
      user,
      name: dataProviderCreation.title,
      id: saveOperation.insertedId?.toString(),
    });

    return saveOperation;
  }

  async findById(id: string): Promise<DataProvider> {
    const dataProvider: DataProvider = await this.dataProviderRepository.findOne(
      id,
    );
    dataProvider.client_secret = this.secretManager.decrypt(
      dataProvider.client_secret,
    );
    return dataProvider;
  }

  async update(
    id: string,
    input: IDataProvider,
    user: string,
  ): Promise<DataProvider> {
    const dataProvider = await this.dataProviderRepository.findOne(id);

    dataProvider.active = input.active;
    dataProvider.title = input.title;
    dataProvider.scopes = input.scopes;
    dataProvider.jwks_uri = input.jwks_uri;
    dataProvider.checktoken_signed_response_alg =
      input.checktoken_signed_response_alg;
    dataProvider.checktoken_encrypted_response_alg =
      input.checktoken_encrypted_response_alg;
    dataProvider.checktoken_encrypted_response_enc =
      input.checktoken_encrypted_response_enc;
    dataProvider.updatedAt = new Date();
    dataProvider.updatedBy = user;

    this.track({
      entity: 'data-provider',
      action: 'update',
      user,
      id,
      name: dataProvider.title,
    });

    return this.dataProviderRepository.save(dataProvider);
  }

  async deleteDataProviderById(id: string, user: string) {
    const dataProvider = await this.dataProviderRepository.findOne(id);

    await this.dataProviderRepository.delete(id);

    this.track({
      entity: 'data-provider',
      action: 'delete',
      user,
      id,
      name: dataProvider.title,
    });
  }

  async generateNewSecret(
    dataProviderID: string,
    currentUser: string,
  ): Promise<DataProvider> {
    const dataProvider = await this.dataProviderRepository.findOne(
      dataProviderID,
    );

    const unEncryptedSecret = this.secretAdapter.generateSecret();

    const newClientSecret = this.secretManager.encrypt(unEncryptedSecret);

    const pastClientSecret = dataProvider.client_secret;
    const now = new Date();

    dataProvider.past_client_secret = pastClientSecret;
    dataProvider.client_secret = newClientSecret;
    dataProvider.updatedAt = now;
    dataProvider.secretUpdatedAt = now;
    dataProvider.secretUpdatedBy = currentUser;

    return this.dataProviderRepository.save(dataProvider);
  }

  async paginate(option: IOptions) {
    const parameters: IOptions = {
      page: option.page,
      limit: option.limit,
      defaultLimit: option.defaultLimit,
      userSearch: option.userSearch,
    };

    if (option.sort) {
      parameters.sort = option.sort;
    }

    if (option.action) {
      parameters.action = option.action;
    }

    return this.dataProviderModel.paginate({}, option.route, parameters);
  }
}
