import { Repository } from 'typeorm';

import {
  Controller,
  Get,
  Render,
  Req,
  Query,
  Post,
  UseInterceptors,
  UsePipes,
  ValidationPipe,
  Body,
  Res,
  Param,
  Patch,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { UserRole } from '@fc/shared/user/roles.enum';
import { Roles } from '@fc/shared/authentication/decorator/roles.decorator';
import { DataProvider } from './data-provider.mongodb.entity';

import { DataProviderService } from './data-provider.service';
import { ScopesService } from '../scopes';
import { FormErrorsInterceptor } from '@fc/shared/form/interceptor/form-errors.interceptor';
import { DataProviderDto } from './dto/data-provider.dto';
import { IDataProvider } from './interface/data-provider.interface';
// import { DeleteDataProviderDto } from './dto/delete-data-provider.dto';
// import { GenerateNewClientSecretDTO } from './dto/generate-new-client-secret.dto';

@Controller('data-provider')
export class DataProviderController {
  constructor(
    @InjectRepository(DataProvider, 'fc-mongo')
    private readonly dataProviderRepository: Repository<DataProvider>,
    private readonly dataProviderService: DataProviderService,
    private readonly scopesService: ScopesService,
  ) {}

  /**
   *
   * @param req
   * @param search
   * @param sort
   * @param action
   * @param pageQuery
   * @param limitQuery
   */
  @Get()
  @Roles(UserRole.OPERATOR, UserRole.SECURITY)
  @Render('data-provider/list')
  async list(
    @Req() req,
    @Query('search') search: string,
    @Query('sort') sort: string,
    @Query('action') action: string,
    @Query('page') pageQuery: string = '1',
    @Query('limit') limitQuery: string = '10',
  ): Promise<{
    dataProviders: DataProvider[];
    total: number;
    activeDataProvidersCount: number;
    csrfToken: string;
    page: number;
    limit: number;
    sort: string;
    action: string;
    userSearch: string;
  }> {
    const activeDataProvidersCount = await this.dataProviderRepository.count({
      active: true,
    });

    const page = parseInt(pageQuery, 10);
    const limit = parseInt(limitQuery, 10);
    const csrfToken = req.csrfToken();
    const userSearch = search;

    const dataProviders = await this.dataProviderService.paginate({
      page,
      limit,
      route: '/data-provider',
      sort,
      action,
      defaultLimit: 10,
      userSearch,
    });
    return {
      dataProviders: dataProviders.items,
      total: dataProviders.total,
      activeDataProvidersCount,
      csrfToken,
      page,
      limit,
      sort,
      action,
      userSearch,
    };
  }

  /**
   * Fournit le formulaire de création d'un fournisseur de données.
   *
   * @param {ParameterDecorator} req
   * @return {string} csrf token
   */
  @Get('create')
  @Render('data-provider/creation')
  @Roles(UserRole.OPERATOR)
  async showCreationForm(@Req() req) {
    const csrfToken = req.csrfToken();
    const scopesGroupedByFd = await this.scopesService.getScopesGroupedByFd();

    const response = {
      csrfToken,
      scopesGroupedByFd,
    };

    return response;
  }

  /**
   * Récupère les données du formulaire de création d'un fournisseur de données
   * @param createDataProviderDto
   * @param req
   * @param res
   */
  @Post('create')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor(`/data-provider/create`))
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async createDataProvider(
    @Body() createDataProviderDto: DataProviderDto,
    @Req() req,
    @Res() res,
  ) {
    try {
      const dataProvider: IDataProvider = createDataProviderDto;

      await this.dataProviderService.createDataProvider(
        dataProvider,
        req.user.username,
      );
    } catch (error) {
      req.flash(
        'globalError',
        "Impossible d'enregistrer le fournisseur de données",
      );
      req.flash('values', createDataProviderDto);

      return res.redirect(`${res.locals.APP_ROOT}/data-provider/create`);
    }
    req.flash(
      'success',
      `Le fournisseur de données ${createDataProviderDto.title} a été créé avec succès !`,
    );

    return res.redirect(`${res.locals.APP_ROOT}/data-provider`);
  }

  /**
   *  Permet d'afficher la page d'un data-provider à modifier
   * @param id
   * @param req
   * @param res
   */
  @Get(':id')
  @Roles(UserRole.OPERATOR)
  @Render('data-provider/update')
  async findOne(@Param('id') id, @Req() req) {
    const csrfToken = req.csrfToken();

    // Only load the dataProvider from the database if there are no errors in the session flash.
    // This is to ensure that if there are errors, we keep the user inputs in the
    // form instead of overwriting them with the data from the database.
    if (!req.session?.flash?.errors) {
      const dataProvider = await this.dataProviderService.findById(id);
      req.flash('values', dataProvider);
    }

    const scopesGroupedByFd = await this.scopesService.getScopesGroupedByFd();

    const response = {
      csrfToken,
      id,
      scopesGroupedByFd,
    };

    return response;
  }

  /**
   *
   * @param dataProviderUpdate
   * @param id
   * @param req
   * @param res
   */
  @Patch(':id')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor(`/data-provider/:id`))
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async dataProviderUpdate(
    @Body() dataProviderUpdate: DataProviderDto,
    @Param('id') id,
    @Req() req,
    @Res() res,
  ) {
    try {
      await this.dataProviderService.update(
        id,
        dataProviderUpdate,
        req.user.username,
      );
    } catch (error) {
      req.flash(
        'globalError',
        'Impossible de mettre à jour le fournisseur de données',
      );
      req.flash('values', dataProviderUpdate);
      return res.redirect(`${res.locals.APP_ROOT}/data-provider/${id}`);
    }
    req.flash(
      'success',
      `Le fournisseur de données ${dataProviderUpdate.title} a été modifié avec succès !`,
    );

    return res.redirect(`${res.locals.APP_ROOT}/data-provider/${id}`);
  }

  // /**
  //  *
  //  * @param key
  //  * @param req
  //  * @param res
  //  * @param body
  //  */
  // @Delete(':id')
  // @Roles(UserRole.OPERATOR)
  // @UseInterceptors(new FormErrorsInterceptor('/data-provider'))
  // async deleteDataProvider(
  //   @Param('id') id: string,
  //   @Req() req,
  //   @Res() res,
  //   @Body() body,
  // ) {
  //   try {
  //     await this.dataProviderService.deleteDataProviderById(
  //       id,
  //       req.user.username,
  //     );
  //   } catch (error) {
  //     req.flash('globalError', error.message);
  //     return res.status(500);
  //   }
  //   req.flash(
  //     'success',
  //     `Le fournisseur de données ${body.name} a été supprimé avec succès !`,
  //   );
  //   return res.redirect(`${res.locals.APP_ROOT}/data-provider`);
  // }

  // /**
  //  *
  //  * @param deleteDataProviderDto
  //  * @param res
  //  * @param req
  //  */
  // @Post('delete')
  // @Roles(UserRole.OPERATOR)
  // @UsePipes(new ValidationPipe({ transform: true }))
  // @UseInterceptors(new FormErrorsInterceptor('/data-provider'))
  // async deleteDataProviders(
  //   @Body() body: DeleteDataProviderDto,
  //   @Res() res,
  //   @Req() req,
  // ) {
  //   const { deleteItems = [], name } = body;
  //   try {
  //     await this.dataProviderService.deleteManyDataProvidersById(
  //       deleteItems,
  //       req.user.username,
  //     );
  //   } catch (error) {
  //     req.flash('globalError', error.message);
  //     return res.status(500);
  //   }
  //   req.flash(
  //     'success',
  //     `Les fournisseurs de données ${name} ont été supprimés avec succès !`,
  //   );
  //   return res.redirect(`${res.locals.APP_ROOT}/data-provider`);
  // }

  // /**
  //  *
  //  * @param id
  //  * @param req
  //  * @param res
  //  */
  // @Get('update/:id/secret')
  // @Roles(UserRole.OPERATOR)
  // @Render('data-provider/generate-new-client-secret')
  // async generateNewSecret(@Param('id') id: string, @Req() req, @Res() res) {
  //   const csrfToken = req.csrfToken();

  //   /**
  //    * If we have an error to flash, we want to render the last user inputs,
  //    * not the data-provider in database.
  //    */
  //   if (req.session.flash && req.session.flash.errors) {
  //     return {
  //       csrfToken,
  //       id,
  //     };
  //   }

  //   const dataProvider = await this.dataProviderService.findById(id);
  //   return {
  //     csrfToken,
  //     id,
  //     messages: {
  //       values: [dataProvider],
  //     },
  //   };
  // }

  // /**
  //  *
  //  * @param id
  //  * @param generateNewClientSecretDTO
  //  * @param req
  //  * @param res
  //  */
  // @Patch('update/:id/secret')
  // @Roles(UserRole.OPERATOR)
  // @UseInterceptors(
  //   new FormErrorsInterceptor('/data-provider/update/:id/secret'),
  // )
  // async generateNewClientSecret(
  //   @Param('id') id: string,
  //   @Body() generateNewClientSecretDTO: GenerateNewClientSecretDTO,
  //   @Req() req,
  //   @Res() res,
  // ) {
  //   try {
  //     await this.dataProviderService.generateNewSecret(
  //       id,
  //       req.user.username,
  //     );
  //   } catch (error) {
  //     req.flash('gobalError', error);
  //     return res.status(500);
  //   }

  //   req.flash(
  //     'success',
  //     `Le nouveau client secret du fournisseur de données ${generateNewClientSecretDTO.name} a été généré avec succés !`,
  //   );

  //   return res.redirect(`${res.locals.APP_ROOT}/data-provider`);
  // }

  // private AddCarriageReturn(input: string[]) {
  //   if (Array.isArray(input)) {
  //     return input.join('\r\n');
  //   }
  //   return input;
  // }

  // private formatEmailFields(emails: string): string {
  //   if (typeof emails !== 'string') {
  //     return '';
  //   }
  //   return emails.replace(/,/g, '\r\n');
  // }
}
