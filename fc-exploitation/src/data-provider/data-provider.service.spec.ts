import { ObjectID } from 'mongodb';

import { Test, TestingModule } from '@nestjs/testing';
import { getModelToken } from '@nestjs/mongoose';
import { getRepositoryToken, TypeOrmModule } from '@nestjs/typeorm';

import { DataProviderService } from './data-provider.service';
import { DataProvider } from './data-provider.mongodb.entity';
import { DataProviderSchema } from './schema/data-provider.schema';
import { ICrudTrack } from '../interfaces';
import { LoggerService } from '@fc/shared/logger/logger.service';
import { SecretAdapter } from '../utils/secret.adapter';
import { SecretManagerService } from '../utils/secret-manager.service';
import { IDataProvider } from './interface/data-provider.interface';
import { action } from 'commander';
import { take } from 'rxjs/operators';

describe('DataProviderService', () => {
  let module: TestingModule;
  let dataProviderService: DataProviderService;

  const secretManagerMocked = {
    encrypt: jest.fn(),
    decrypt: jest.fn(),
    // generateSHA256: jest.fn(),
  };

  const secretAdapterMock = {
    generateSecret: jest.fn(),
    generateKey: jest.fn(),
  };

  const dataProviderRepositoryMock = {
    save: jest.fn(),
    insertOne: jest.fn(),
    find: jest.fn(),
    findAndCount: jest.fn(),
    findOne: jest.fn(),
    delete: jest.fn(),
  };

  const userMock = 'userMockValue';

  const dataProviderMock = ({
    id: new ObjectID('5d35b91e70332098440d0f85'),
    uid: '6f21b751-ed06-48b6-a59c-36e1300a368a',
    title: 'dataprovider1',
    active: true,
    client_id: '76eded44d32b40c0cb1006065',
    client_secret:
      '6925fb8143c76eded44d32b40c0cb1006065f7f003de52712b78985704f39950',
    jwks_uri: 'https://monfd.com/jwks',
    secretCreatedAt: new Date(),
    createdAt: new Date(),
    updatedBy: userMock,
    scopes: [],
  } as unknown) as IDataProvider;

  const dataProviderCreationData: IDataProvider = {
    title: 'new-dataprovider',
    active: true,
    scopes: [],
  };

  const dataProviderUpdateData: IDataProvider = {
    title: 'new-mydp',
    active: true,
    scopes: ['new'],
    jwks_uri: 'https://new-jwks.example.fr',
  };

  const expectedDataProviderUpdated = {
    title: 'new-mydp',
    active: true,
    scopes: ['new'],
    jwks_uri: 'https://new-jwks.example.fr',
    updatedAt: expect.any(Date),
    updatedBy: 'userMockValue',
  };

  const insertResultMock = {
    insertedId: 'insertedIdMock',
    uid: 'uidMock',
    title: 'new-dataprovider',
    active: true,
    scopes: [],
    createdAt: new Date(),
    secretCreatedAt: new Date(),
    secretUpdatedAt: new Date(),
    secretUpdatedBy: userMock,
    updatedAt: new Date(),
    updatedBy: userMock,
  };

  const loggerMock = {
    businessEvent: jest.fn(),
  };

  beforeEach(async () => {
    jest.resetAllMocks();

    module = await Test.createTestingModule({
      imports: [],
      providers: [
        DataProviderService,
        {
          provide: getRepositoryToken(DataProvider, 'fc-mongo'),
          useValue: dataProviderRepositoryMock,
        },
        {
          provide: getModelToken('DataProvider'),
          useValue: DataProviderSchema,
        },
        { provide: LoggerService, useValue: loggerMock },
        { provide: SecretAdapter, useValue: secretAdapterMock },
        { provide: SecretManagerService, useValue: secretManagerMocked },
      ],
    }).compile();

    dataProviderService = await module.get<DataProviderService>(
      DataProviderService,
    );

    dataProviderRepositoryMock.findOne.mockResolvedValue(dataProviderMock);
    dataProviderRepositoryMock.insertOne.mockImplementation(async data => ({
      ...data,
      insertedId: 'insertedIdMock',
    }));
  });

  describe('track', () => {
    it('should call logger.businessEvent', () => {
      // Given
      const logMock = {} as ICrudTrack;
      // When
      // tslint:disable-next-line:no-string-literal
      dataProviderService['track'](logMock);
      // Then
      expect(loggerMock.businessEvent).toHaveBeenCalledTimes(1);
      expect(loggerMock.businessEvent).toHaveBeenCalledWith(logMock);
    });
  });

  describe('dummy', () => {
    it('dummy', () => {
      expect(true).toBeTruthy();
    });
  });

  describe('createDataProvider', () => {
    beforeEach(() => {
      // tslint:disable-next-line:no-string-literal
      dataProviderService['track'] = jest.fn();
      secretAdapterMock.generateKey
        .mockReturnValueOnce('firstKeyMocked')
        .mockReturnValueOnce('secondKeyMocked');
      secretAdapterMock.generateSecret.mockReturnValue('secretMocked');
      secretManagerMocked.encrypt.mockImplementation(
        data => `encrypted-${data}`,
      );
    });

    it('should call insertOne method', async () => {
      // Given
      // When
      await dataProviderService.createDataProvider(
        dataProviderCreationData,
        userMock,
      );

      // Then
      expect(dataProviderRepositoryMock.insertOne).toHaveBeenCalledTimes(1);
      expect(dataProviderRepositoryMock.insertOne).toHaveBeenCalledWith({
        title: 'new-dataprovider',
        active: true,
        scopes: [],
        uid: 'firstKeyMocked',
        client_id: 'secondKeyMocked',
        client_secret: 'encrypted-secretMocked',
        createdAt: expect.any(Date),
        secretCreatedAt: expect.any(Date),
        secretUpdatedAt: expect.any(Date),
        secretUpdatedBy: userMock,
        updatedAt: expect.any(Date),
        updatedBy: userMock,
      });
    });

    it('should call the tracking method', async () => {
      // When
      await dataProviderService.createDataProvider(
        dataProviderCreationData,
        userMock,
      );

      // Then
      // tslint:disable-next-line:no-string-literal
      expect(dataProviderService['track']).toHaveBeenCalledTimes(1);
      // tslint:disable-next-line:no-string-literal
      expect(dataProviderService['track']).toHaveBeenCalledWith({
        entity: 'data-provider',
        action: 'create',
        user: userMock,
        id: 'insertedIdMock',
        name: 'new-dataprovider',
      });
    });
  });

  describe('findById', () => {
    it('should find a data provider in mongodb and decrypt its secret', async () => {
      // setup
      const id = '9d4d6d29bbdfbd203da312f2';
      const encryptedSecret = 'SuperSecret';
      const decryptedSecret = 'decrypted-SuperSecret';
      const dataProvider = {
        id: '9d4d6d29bbdfbd203da312f2',
        client_secret: encryptedSecret,
      };
      dataProviderRepositoryMock.findOne.mockResolvedValueOnce(dataProvider);
      secretManagerMocked.decrypt.mockImplementation(
        cipher => `decrypted-${cipher}`,
      );

      // action
      const result = await dataProviderService.findById(id);

      // expect
      expect(result).toEqual({
        ...dataProvider,
        client_secret: decryptedSecret,
      });
    });
  });

  describe('update()', () => {
    const idToUpdate = '5d4d6d29bbdfbd203da312f2';

    beforeEach(() => {
      // tslint:disable-next-line:no-string-literal
      dataProviderService['track'] = jest.fn();
    });

    it('updates the data provider', async () => {
      // Given
      dataProviderRepositoryMock.findOne.mockResolvedValue({
        title: 'mydp',
        jwks_uri: 'https://jwks.example.fr',
        active: false,
        scopes: ['toto', 'tutu'],
      });

      // When
      await dataProviderService.update(
        idToUpdate,
        dataProviderUpdateData,
        userMock,
      );

      // Then
      expect(dataProviderRepositoryMock.findOne).toHaveBeenCalledWith(
        idToUpdate,
      );
      expect(dataProviderRepositoryMock.save).toHaveBeenCalledWith(
        expectedDataProviderUpdated,
      );

      expect(dataProviderService['track']).toHaveBeenCalledWith({
        entity: 'data-provider',
        action: 'update',
        user: userMock,
        id: idToUpdate,
        name: 'new-mydp',
      });
    });
  });

  describe('delete service provider by id', () => {
    beforeEach(() => {
      // tslint:disable-next-line:no-string-literal
      dataProviderService['track'] = jest.fn();

      dataProviderRepositoryMock.findOne.mockResolvedValue({
        title: 'mydp',
        jwks_uri: 'https://jwks.example.fr',
        active: false,
        scopes: ['toto', 'tutu'],
      });
    });

    it('deletes the data provider', async () => {
      // set up
      const idMock = '123';

      // action
      await dataProviderService.deleteDataProviderById(idMock, userMock);

      // assertion
      expect(dataProviderRepositoryMock.delete).toHaveBeenCalledWith(idMock);
      // tslint:disable-next-line:no-string-literal
      expect(dataProviderService['track']).toHaveBeenCalledWith({
        action: 'delete',
        entity: 'data-provider',
        id: idMock,
        user: userMock,
        name: 'mydp',
      });
    });
  });

  // describe('generate a new client secret', () => {
  //   it('should generate a new client secret', async () => {
  //     const id = '5d4d6d29bbdfbd203da312f2';

  //     dataProviderRepositoryMock.findOne.mockImplementationOnce(() =>
  //       Promise.resolve({
  //         name: 'proConnect',
  //         redirectUri: ['https://proConnect.com'],
  //         redirectUriLogout: ['https://proConnect.com/logout'],
  //         site: 'https://proConnect.com',
  //         ipAddresses: ['192.0.0.0'],
  //         emails: ['v@b2.com'],
  //         active: true,
  //         type: 'private',
  //         key: 'bafe2428-3ab9-4c44-9021-46bde0cd13c5',
  //         client_secret:
  //           '$2b$10$EO3FnI3YKfnnvUlvr084wegEgEPeRPRMdE2VJwMHpAsNkaMv1n9pG',
  //       }),
  //     );

  //     secretManagerMocked.encrypt.mockReturnValueOnce(
  //       '$2b$10$EO3FnI3YKfnnvUlvr084wegEgEPeRPRMdE2VJwMHpAsNkaMv1n9pG',
  //     );

  //     await dataProviderService.generateNewSecret(id, 'user');

  //     expect(secretAdapterMock.generateSecret).toHaveBeenCalledTimes(1);
  //     expect(secretManagerMocked.encrypt).toHaveBeenCalledTimes(1);
  //     expect(dataProviderRepositoryMock.findOne).toHaveBeenCalledTimes(1);
  //     expect(dataProviderRepositoryMock.save).toHaveBeenCalledTimes(1);
  //   });
  // });
});
