import { ObjectID } from 'mongodb';

import { Test, TestingModule } from '@nestjs/testing';
import { getModelToken } from '@nestjs/mongoose';
import { getRepositoryToken, TypeOrmModule } from '@nestjs/typeorm';

import { DataProviderService } from './data-provider.service';
import { DataProvider } from './data-provider.mongodb.entity';
import { DataProviderSchema } from './schema/data-provider.schema';
import { ICrudTrack } from '../interfaces';
import { LoggerService } from '@fc/shared/logger/logger.service';
import { SecretAdapter } from '../utils/secret.adapter';
import { SecretManagerService } from '../utils/secret-manager.service';
import { IDataProvider } from './interface/data-provider.interface';

describe('DataProviderService', () => {
  let module: TestingModule;
  let dataProviderService: DataProviderService;

  const secretManagerMocked = {
    encrypt: jest.fn(),
    decrypt: jest.fn(),
  };

  const secretAdapterMock = {
    generateSecret: jest.fn(),
    generateKey: jest.fn(),
  };

  const dataProviderRepositoryMock = {
    save: jest.fn(),
    insertOne: jest.fn(),
    find: jest.fn(),
    findAndCount: jest.fn(),
    findOne: jest.fn(),
    delete: jest.fn(),
  };

  const userMock = 'userMockValue';

  const dataProviderMock = ({
    _id: new ObjectID('5d35b91e70332098440d0f85'),
    uid: '6f21b751-ed06-48b6-a59c-36e1300a368a',
    title: 'dataprovider1',
    active: true,
    client_id: '76eded44d32b40c0cb1006065',
    client_secret: 'client-secret',
    jwks_uri: 'https://monfd.com/jwks',
    checktoken_signed_response_alg: 'ES256',
    checktoken_encrypted_response_alg: 'RSA-OAEP',
    checktoken_encrypted_response_enc: 'A256GCM',
    secretCreatedAt: new Date(),
    createdAt: new Date(),
    updatedBy: userMock,
    scopes: [],
  } as unknown) as IDataProvider;

  const dataProviderCreationData: IDataProvider = {
    title: 'new-dataprovider',
    active: true,
    scopes: [],
  };

  const dataProviderUpdateData: IDataProvider = {
    title: 'new-mydp',
    active: true,
    scopes: ['new'],
    jwks_uri: 'https://new-jwks.example.fr',
    checktoken_signed_response_alg: 'RS256',
    checktoken_encrypted_response_alg: 'ECDH-ES',
    checktoken_encrypted_response_enc: '',
  };

  const expectedDataProviderUpdated = {
    title: 'new-mydp',
    active: true,
    scopes: ['new'],
    jwks_uri: 'https://new-jwks.example.fr',
    checktoken_signed_response_alg: 'RS256',
    checktoken_encrypted_response_alg: 'ECDH-ES',
    checktoken_encrypted_response_enc: '',
    updatedAt: expect.any(Date),
    updatedBy: 'userMockValue',
  };

  const loggerMock = {
    businessEvent: jest.fn(),
  };

  beforeEach(async () => {
    jest.resetAllMocks();

    module = await Test.createTestingModule({
      imports: [],
      providers: [
        DataProviderService,
        {
          provide: getRepositoryToken(DataProvider, 'fc-mongo'),
          useValue: dataProviderRepositoryMock,
        },
        {
          provide: getModelToken('DataProvider'),
          useValue: DataProviderSchema,
        },
        { provide: LoggerService, useValue: loggerMock },
        { provide: SecretAdapter, useValue: secretAdapterMock },
        { provide: SecretManagerService, useValue: secretManagerMocked },
      ],
    }).compile();

    dataProviderService = await module.get<DataProviderService>(
      DataProviderService,
    );

    dataProviderRepositoryMock.findOne.mockResolvedValue(dataProviderMock);
    dataProviderRepositoryMock.insertOne.mockImplementation(async data => ({
      ...data,
      insertedId: 'insertedIdMock',
    }));
  });

  describe('track', () => {
    it('should call logger.businessEvent', () => {
      // Given
      const logMock = {} as ICrudTrack;
      // When
      // tslint:disable-next-line:no-string-literal
      dataProviderService['track'](logMock);
      // Then
      expect(loggerMock.businessEvent).toHaveBeenCalledTimes(1);
      expect(loggerMock.businessEvent).toHaveBeenCalledWith(logMock);
    });
  });

  describe('dummy', () => {
    it('dummy', () => {
      expect(true).toBeTruthy();
    });
  });

  describe('createDataProvider', () => {
    beforeEach(() => {
      // tslint:disable-next-line:no-string-literal
      dataProviderService['track'] = jest.fn();
      secretAdapterMock.generateKey
        .mockReturnValueOnce('firstKeyMocked')
        .mockReturnValueOnce('secondKeyMocked');
      secretAdapterMock.generateSecret.mockReturnValue('secretMocked');
      secretManagerMocked.encrypt.mockImplementation(
        data => `encrypted-${data}`,
      );
    });

    it('should call insertOne method', async () => {
      // Given
      // When
      await dataProviderService.createDataProvider(
        dataProviderCreationData,
        userMock,
      );

      // Then
      expect(dataProviderRepositoryMock.insertOne).toHaveBeenCalledTimes(1);
      expect(dataProviderRepositoryMock.insertOne).toHaveBeenCalledWith({
        title: 'new-dataprovider',
        active: true,
        scopes: [],
        uid: 'firstKeyMocked',
        client_id: 'secondKeyMocked',
        client_secret: 'encrypted-secretMocked',
        createdAt: expect.any(Date),
        secretCreatedAt: expect.any(Date),
        secretUpdatedAt: expect.any(Date),
        secretUpdatedBy: userMock,
        updatedAt: expect.any(Date),
        updatedBy: userMock,
      });
    });

    it('should call the tracking method', async () => {
      // When
      await dataProviderService.createDataProvider(
        dataProviderCreationData,
        userMock,
      );

      // Then
      // tslint:disable-next-line:no-string-literal
      expect(dataProviderService['track']).toHaveBeenCalledTimes(1);
      // tslint:disable-next-line:no-string-literal
      expect(dataProviderService['track']).toHaveBeenCalledWith({
        entity: 'data-provider',
        action: 'create',
        user: userMock,
        id: 'insertedIdMock',
        name: 'new-dataprovider',
      });
    });
  });

  describe('findById', () => {
    it('should find a data provider in mongodb and decrypt its secret', async () => {
      // setup
      const id = '9d4d6d29bbdfbd203da312f2';
      const encryptedSecret = 'SuperSecret';
      const decryptedSecret = 'decrypted-SuperSecret';
      const dataProvider = {
        id: '9d4d6d29bbdfbd203da312f2',
        client_secret: encryptedSecret,
      };
      dataProviderRepositoryMock.findOne.mockResolvedValueOnce(dataProvider);
      secretManagerMocked.decrypt.mockImplementation(
        cipher => `decrypted-${cipher}`,
      );

      // action
      const result = await dataProviderService.findById(id);

      // expect
      expect(result).toEqual({
        ...dataProvider,
        client_secret: decryptedSecret,
      });
    });
  });

  describe('update()', () => {
    const idToUpdate = '5d4d6d29bbdfbd203da312f2';

    beforeEach(() => {
      // tslint:disable-next-line:no-string-literal
      dataProviderService['track'] = jest.fn();
    });

    it('updates the data provider', async () => {
      // Given
      dataProviderRepositoryMock.findOne.mockResolvedValue({
        title: 'mydp',
        jwks_uri: 'https://jwks.example.fr',
        active: false,
        scopes: ['toto', 'tutu'],
      });

      // When
      await dataProviderService.update(
        idToUpdate,
        dataProviderUpdateData,
        userMock,
      );

      // Then
      expect(dataProviderRepositoryMock.findOne).toHaveBeenCalledWith(
        idToUpdate,
      );
      expect(dataProviderRepositoryMock.save).toHaveBeenCalledWith(
        expectedDataProviderUpdated,
      );

      expect(dataProviderService['track']).toHaveBeenCalledWith({
        entity: 'data-provider',
        action: 'update',
        user: userMock,
        id: idToUpdate,
        name: 'new-mydp',
      });
    });
  });

  describe('delete service provider by id', () => {
    beforeEach(() => {
      // tslint:disable-next-line:no-string-literal
      dataProviderService['track'] = jest.fn();

      dataProviderRepositoryMock.findOne.mockResolvedValue({
        title: 'mydp',
        jwks_uri: 'https://jwks.example.fr',
        active: false,
        scopes: ['toto', 'tutu'],
      });
    });

    it('deletes the data provider', async () => {
      // set up
      const idMock = '123';

      // action
      await dataProviderService.deleteDataProviderById(idMock, userMock);

      // assertion
      expect(dataProviderRepositoryMock.delete).toHaveBeenCalledWith(idMock);
      // tslint:disable-next-line:no-string-literal
      expect(dataProviderService['track']).toHaveBeenCalledWith({
        action: 'delete',
        entity: 'data-provider',
        id: idMock,
        user: userMock,
        name: 'mydp',
      });
    });
  });

  describe('generateNewSecret', () => {
    it('should generate a new client secret', async () => {
      const dpId = 'dp-id';
      dataProviderRepositoryMock.findOne.mockResolvedValue({
        title: 'my-dp',
        client_secret: 'old-secret',
      });
      secretManagerMocked.encrypt.mockImplementation(
        clear => `encrypted(${clear})`,
      );
      secretAdapterMock.generateSecret.mockReturnValue('new-secret');

      await dataProviderService.generateNewSecret(dpId, 'user');

      expect(dataProviderRepositoryMock.findOne).toHaveBeenCalledWith(dpId);
      expect(dataProviderRepositoryMock.save).toHaveBeenCalledWith({
        title: 'my-dp',
        past_client_secret: 'old-secret',
        client_secret: 'encrypted(new-secret)',
        updatedAt: expect.any(Date),
        secretUpdatedAt: expect.any(Date),
        secretUpdatedBy: 'user',
      });
    });
  });
});
