import { Injectable, ServiceUnavailableException } from '@nestjs/common';
import { RabbitmqService } from '@fc/shared/rabbitmq';
import { ConfigService } from 'nestjs-config';
import { v4 as uuid } from 'uuid';
import { SecretManagerService } from './secret-manager.service';

// Command to be executed by consumer
const BROKER_RANDOM_COMMAND = 'CRYPTO_RANDOM';
// Bytes length of generated random string
const RANDOM_LENGTH = 32;
@Injectable()
export class SecretAdapter {
  constructor(
    private readonly broker: RabbitmqService,
    private configService: ConfigService,
    private readonly secretManager: SecretManagerService,
  ) {}

  async generateSecret(): Promise<string> {
    const secret = await this.getSecret();
    const newClientSecret = await this.secretManager.encrypt(secret);
    return newClientSecret;
  }

  async generateKey(): Promise<string> {
    if (await this.useHsm()) {
      return await this.generateWithHsm();
    }

    return uuid();
  }

  private async useHsm(): Promise<boolean> {
    const { useHsm } = await this.configService.get('cryptography-broker');
    return useHsm;
  }

  private async getSecret(): Promise<string> {
    if (await this.useHsm()) {
      return await this.generateWithHsm();
    }
    return this.secretManager.generateSHA256();
  }

  private async generateWithHsm(): Promise<string> {
    try {
      const alea = await this.broker.publish(BROKER_RANDOM_COMMAND, {
        length: RANDOM_LENGTH,
        encoding: 'hex',
      });
      return alea;
    } catch (error) {
      throw new ServiceUnavailableException('HSM not responding', error);
    }
  }
}
