import { TestingModule, Test } from '@nestjs/testing';
import { RabbitmqService } from '@fc/shared/rabbitmq';
import { ServiceUnavailableException } from '@nestjs/common';
import { ConfigService } from 'nestjs-config';
import { SecretAdapter } from './secret.adapter';
import { SecretManagerService } from './secret-manager.service';
jest.mock('uuid'); // allow to mock all module
import { v4 as uuidv4 } from 'uuid';

describe('SecretAdapter', () => {
  let module: TestingModule;
  let service: SecretAdapter;

  const configServiceMock = {
    get: jest.fn(),
  };

  const rabbitmqMock = {
    publish: jest.fn(),
  };

  const secretManagerMocked = {
    encrypt: jest.fn(),
    decrypt: jest.fn(),
    generateSHA256: jest.fn(),
  };

  beforeEach(async () => {
    module = await Test.createTestingModule({
      providers: [
        SecretAdapter,
        SecretManagerService,
        RabbitmqService,
        ConfigService,
      ],
    })
      .overrideProvider(SecretManagerService)
      .useValue(secretManagerMocked)
      .overrideProvider(RabbitmqService)
      .useValue(rabbitmqMock)
      .overrideProvider(ConfigService)
      .useValue(configServiceMock)
      .compile();

    service = await module.get<SecretAdapter>(SecretAdapter);

    jest.resetAllMocks();
    jest.restoreAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('generateSecret', () => {
    it('Should return a new secret', async () => {
      const expected = 'mockReturnSecretEncrypted';

      configServiceMock.get.mockResolvedValue({ useHsm: 'true' });
      rabbitmqMock.publish.mockResolvedValue('rabbitmqRandomMockValue');
      secretManagerMocked.encrypt.mockResolvedValueOnce(
        'mockReturnSecretEncrypted',
      );

      const result = await service.generateSecret();

      expect(secretManagerMocked.encrypt).toHaveBeenCalledTimes(1);
      expect(result).toEqual(expected);
    });
  });

  describe('generateKey', () => {
    it('Should use the secret manager', async () => {
      const expected = '76eded44d32b40c0cb1006065';

      configServiceMock.get.mockResolvedValue({ useHsm: false });
      // uuidv4 is fully mocked by the jest.mock("uuid") on top
      (uuidv4 as jest.Mock).mockReturnValue('76eded44d32b40c0cb1006065');

      // tslint:disable-next-line:no-string-literal
      const result = await service.generateKey();

      expect(uuidv4).toHaveBeenCalledTimes(1);
      expect(rabbitmqMock.publish).toHaveBeenCalledTimes(0);
      expect(result).toEqual(expected);
    });

    it('Should use the hsm', async () => {
      const expected = 'rabbitmqRandomKeyMockValue';

      configServiceMock.get.mockResolvedValue({ useHsm: true });
      rabbitmqMock.publish.mockResolvedValue('rabbitmqRandomKeyMockValue');

      // tslint:disable-next-line:no-string-literal
      const result = await service.generateKey();

      expect(rabbitmqMock.publish).toHaveBeenCalledTimes(1);
      expect(secretManagerMocked.generateSHA256).toHaveBeenCalledTimes(0);
      expect(result).toEqual(expected);
    });
  });

  describe('useHsm', () => {
    it('Should return useHsm env value from config if set to false', async () => {
      const expected = false;

      configServiceMock.get.mockResolvedValue({ useHsm: false });

      // tslint:disable-next-line:no-string-literal
      const result = await service['useHsm']();

      expect(configServiceMock.get).toHaveBeenCalledTimes(1);
      expect(result).toEqual(expected);
      expect(result).toBeFalsy();
    });

    it('Should return useHsm env value from config if set to true', async () => {
      const expected = true;

      configServiceMock.get.mockResolvedValue({ useHsm: true });

      // tslint:disable-next-line:no-string-literal
      const result = await service['useHsm']();

      expect(configServiceMock.get).toHaveBeenCalledTimes(1);
      expect(result).toEqual(expected);
      expect(result).toBeTruthy();
    });
  });

  describe('getSecret', () => {
    it('Should use the secret manager', async () => {
      const expected = 'generateSH256RandomMockValue';
      configServiceMock.get.mockResolvedValue({ useHsm: false });
      secretManagerMocked.generateSHA256.mockResolvedValueOnce(
        'generateSH256RandomMockValue',
      );
      // tslint:disable-next-line:no-string-literal
      const result = await service['getSecret']();

      expect(secretManagerMocked.generateSHA256).toHaveBeenCalledTimes(1);
      expect(rabbitmqMock.publish).toHaveBeenCalledTimes(0);
      expect(result).toEqual(expected);
    });

    it('Should use the hsm', async () => {
      const expected = 'rabbitmqRandomSecretMockValue';

      configServiceMock.get.mockResolvedValue({ useHsm: true });
      rabbitmqMock.publish.mockResolvedValue('rabbitmqRandomSecretMockValue');

      // tslint:disable-next-line:no-string-literal
      const result = await service['getSecret']();

      expect(rabbitmqMock.publish).toHaveBeenCalledTimes(1);
      expect(secretManagerMocked.generateSHA256).toHaveBeenCalledTimes(0);
      expect(result).toEqual(expected);
    });
  });

  describe('generateWithHsm', () => {
    it('Should use the hsm', async () => {
      const expected = 'rabbitmqRandomMockValue';

      // configServiceMock.get.mockResolvedValue({ useHsm: 'true' });
      rabbitmqMock.publish.mockResolvedValue('rabbitmqRandomMockValue');

      // tslint:disable-next-line:no-string-literal
      const result = await service['generateWithHsm']();

      expect(rabbitmqMock.publish).toHaveBeenCalledTimes(1);
      expect(result).toEqual(expected);
    });

    it("Should throw an error if hsm can't be used", async () => {
      const expectedError = new ServiceUnavailableException(
        'HSM not responding',
      );

      rabbitmqMock.publish.mockRejectedValueOnce(expectedError);

      try {
        // tslint:disable-next-line:no-string-literal
        await service['generateWithHsm']();
      } catch (error) {
        expect(error).toBeInstanceOf(ServiceUnavailableException);
      }
    });
  });
});
