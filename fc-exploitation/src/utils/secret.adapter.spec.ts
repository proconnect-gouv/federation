import { TestingModule, Test } from '@nestjs/testing';
import { RabbitmqService } from '@fc/shared/rabbitmq';
import { ConfigService } from 'nestjs-config';
import { SecretAdapter } from './secret.adapter';
import { SecretManagerService } from './secret-manager.service';

describe('SecretAdapter', () => {
  let module: TestingModule;
  let service: SecretAdapter;

  const configServiceMock = {
    get: jest.fn(),
  };

  const rabbitmqMock = {
    publish: jest.fn(),
  };

  const secretManagerMocked = {
    encrypt: jest.fn(),
    decrypt: jest.fn(),
    generateSHA256: jest.fn(),
  };

  beforeEach(async () => {
    module = await Test.createTestingModule({
      providers: [
        SecretAdapter,
        SecretManagerService,
        RabbitmqService,
        ConfigService,
      ],
    })
      .overrideProvider(SecretManagerService)
      .useValue(secretManagerMocked)
      .overrideProvider(RabbitmqService)
      .useValue(rabbitmqMock)
      .overrideProvider(ConfigService)
      .useValue(configServiceMock)
      .compile();

    service = await module.get<SecretAdapter>(SecretAdapter);

    jest.resetAllMocks();
    jest.restoreAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('generateSecret', () => {
    it('Should return a new secret', async () => {
      const expected = 'mockReturnSecretEncrypted';

      configServiceMock.get.mockResolvedValue({ useHsm: 'true' });
      rabbitmqMock.publish.mockResolvedValue('rabbitmqRandomMockValue');
      secretManagerMocked.encrypt.mockResolvedValueOnce(
        'mockReturnSecretEncrypted',
      );

      const result = await service.generateSecret();

      expect(secretManagerMocked.encrypt).toHaveBeenCalledTimes(1);
      expect(result).toEqual(expected);
    });
  });

  describe('getSecret', () => {
    it('Should use the secret manager', async () => {
      const expected = 'generateSH256RandomMockValue';

      configServiceMock.get.mockResolvedValue({ useHsm: 'false' });
      secretManagerMocked.generateSHA256.mockResolvedValueOnce(
        'generateSH256RandomMockValue',
      );

      // tslint:disable-next-line:no-string-literal
      const result = await service['getSecret']();

      expect(secretManagerMocked.generateSHA256).toHaveBeenCalledTimes(1);
      expect(rabbitmqMock.publish).toHaveBeenCalledTimes(0);
      expect(result).toEqual(expected);
    });

    it('Should use the hsm', async () => {
      const expected = 'rabbitmqRandomMockValue';

      configServiceMock.get.mockResolvedValue({ useHsm: 'true' });
      rabbitmqMock.publish.mockResolvedValue('rabbitmqRandomMockValue');

      // tslint:disable-next-line:no-string-literal
      const result = await service['getSecret']();

      expect(rabbitmqMock.publish).toHaveBeenCalledTimes(1);
      expect(secretManagerMocked.generateSHA256).toHaveBeenCalledTimes(0);
      expect(result).toEqual(expected);
    });
  });
});
