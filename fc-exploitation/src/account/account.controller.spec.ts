import { Test } from '@nestjs/testing';
import { getRepositoryToken, TypeOrmModule } from '@nestjs/typeorm';
import { UserRole } from '@fc/shared/user/roles.enum';
import { UserService } from '@fc/shared/user/user.service';
import { User } from '@fc/shared/user/user.entity';
import { CreateUserDto } from './dto/create-user.dto';
import { AccountController } from './account.controller';

describe('AccountController', () => {
  let accountController: AccountController;
  const userService = {
    compareHash: jest.fn(),
    findByUsername: jest.fn(),
    createUser: jest.fn(),
    deleteUserById: jest.fn(),
  };
  const res = {
    redirect: jest.fn(),
    status: jest.fn(),
  };
  const req = {
    flash: jest.fn(),
    user: {
      id: '05e4fadf-fda6-4ad8-ae75-b7f315843827',
    },
    csrfToken: function csrfToken() {
      return 'mygreatcsrftoken';
    },
  };
  const createUserDto = new CreateUserDto(
    'jean_moust',
    'jean@moust.lol',
    'yolo',
    'yolo',
    [UserRole.OPERATOR],
  );
  const userRepository = {
    find: jest.fn(),
  };

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [TypeOrmModule.forFeature([User])],
      controllers: [AccountController],
      providers: [UserService],
    })
      .overrideProvider(UserService)
      .useValue(userService)
      .overrideProvider(getRepositoryToken(User))
      .useValue(userRepository)
      .compile();

    accountController = module.get<AccountController>(AccountController);

    jest.resetAllMocks();
  });

  describe('createUser', () => {
    it('redirects the user when a valid user is provided', async () => {
      await accountController.createUser(createUserDto, req, res);
      expect(res.redirect).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith('/account');
    });

    it('uses the user service to create users', async () => {
      await accountController.createUser(createUserDto, req, res);

      expect(userService.createUser).toHaveBeenCalledTimes(1);
      expect(userService.createUser).toHaveBeenCalledWith(createUserDto);
    });

    describe('list', () => {
      it('returns all the users', async () => {
        // set up
        const mockedUsers = ['toto', 'tata', 'tutu'];
        userRepository.find.mockResolvedValueOnce(mockedUsers);
        // action
        const { users } = await accountController.list(req);
        // assertion
        expect(users).toEqual(mockedUsers);
      });
    });

    describe('delete', () => {
      it('should call deleteUser of the user service with the provided id', async () => {
        // set up
        const id = 'd3d3f8a1-26ea-4a8b-9ed3-336d3777b529';
        // action
        await accountController.deleteUser(id, req, res);
        // assertion
        expect(userService.deleteUserById).toHaveBeenCalledTimes(1);
        expect(userService.deleteUserById).toHaveBeenCalledWith(id);
        expect(res.redirect).toHaveBeenCalledWith('/account');
      });

      it('should not call deleteUser of the user service but redirect the user to the /account page', async () => {
        // set up
        const id = '05e4fadf-fda6-4ad8-ae75-b7f315843827';
        // action
        await accountController.deleteUser(id, req, res);
        // assertion
        expect(res.redirect).toHaveBeenCalledWith('/account');
        expect(userService.deleteUserById).toHaveBeenCalledTimes(0);
      });

      it('should not redirect the user but set the res status to 500 for the error handler', async () => {
        // set up
        userService.deleteUserById = jest.fn(() => {
          throw Error;
        });
        const id = '2d1280f1-1611-42fa-968a-47e450e0aeba';
        // action
        await accountController.deleteUser(id, req, res);
        // assertion
        expect(res.status).toHaveBeenCalledWith(500);
        expect(res.redirect).toHaveBeenCalledTimes(0);
        expect(userService.deleteUserById).toHaveBeenCalledTimes(1);
      });
    });
  });
});
