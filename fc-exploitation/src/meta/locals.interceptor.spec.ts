import { ConfigService } from 'nestjs-config';
import { Test } from '@nestjs/testing';
import { UserRole } from '@fc/shared/user/roles.enum';
import { LocalsInterceptor } from './locals.interceptor';
import { FC_SCOPES, FCA_SCOPES } from '../constant';

describe('LocalsInterceptor', () => {
  let localsInterceptor;
  const configService = {
    get: jest.fn(),
  };

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [LocalsInterceptor, ConfigService],
    })
      .overrideProvider(ConfigService)
      .useValue(configService)
      .compile();
    localsInterceptor = await module.get<LocalsInterceptor>(LocalsInterceptor);
  });

  it('should add the FCA meta information to all responses', async () => {
    const req = {
      user: 'jean_moust',
    };
    const res: any = {
      locals: {},
    };
    const currentBranch = 'testing';
    const shortHash = '3f17f344';
    const longHash = '3f17f344448066d75f9eb33ade5fdcd799d89352';
    const context = {
      switchToHttp: jest.fn(() => ({
        getRequest: jest.fn(() => req),
        getResponse: jest.fn(() => res),
      })),
    };
    const next = {
      handle: jest.fn(),
    };
    configService.get.mockReturnValueOnce({
      environment: 'testing',
      commitUrlPrefix:
        'https://gitlab.com/france-connect/FranceConnect/commit/',
      currentBranch,
      latestCommitShortHash: shortHash,
      latestCommitLongHash: longHash,
      app_root: '/foo/bar',
      instanceFor: 'FCA',
    });

    await localsInterceptor.intercept(context, next);

    expect(configService.get).toBeCalledWith('app');
    expect(res.locals.APP_ENVIRONMENT).toBe('testing');
    expect(res.locals.APP_ROOT).toBe('/foo/bar');
    expect(res.locals.COMMIT_URL_PREFIX).toBe(
      'https://gitlab.com/france-connect/FranceConnect/commit/',
    );
    expect(res.locals.GIT_CURRENT_BRANCH).toBe(currentBranch);
    expect(res.locals.GIT_LATEST_COMMIT_SHORT_HASH).toBe(shortHash);
    expect(res.locals.GIT_LATEST_COMMIT_LONG_HASH).toBe(longHash);
    expect(res.locals.CURRENT_USER).toBe(req.user);
    expect(next.handle).toBeCalledTimes(1);
    expect(res.locals.USER_ROLES_OPTIONS).toEqual([
      { label: 'Administrateur', value: UserRole.ADMIN },
      { label: 'Exploitant', value: UserRole.OPERATOR },
      { label: 'Sécurité', value: UserRole.SECURITY },
      { label: 'Nouvel utilisateur', value: UserRole.NEWUSER },
      { label: 'Administrateur inactif', value: UserRole.INACTIVE_ADMIN },
      { label: 'Exploitant inactif', value: UserRole.INACTIVE_OPERATOR },
      { label: 'Sécurité inactif', value: UserRole.INACTIVE_SECURITY },
      { label: 'Utilisateur bloqué', value: UserRole.BLOCKED_USER },
    ]);
  });

  it('should add the FC meta information to all responses', async () => {
    const req = {
      user: 'jean_moust',
    };
    const res: any = {
      locals: {},
    };
    const currentBranch = 'testing';
    const shortHash = '3f17f344';
    const longHash = '3f17f344448066d75f9eb33ade5fdcd799d89352';
    const context = {
      switchToHttp: jest.fn(() => ({
        getRequest: jest.fn(() => req),
        getResponse: jest.fn(() => res),
      })),
    };
    const next = {
      handle: jest.fn(),
    };
    configService.get.mockReturnValueOnce({
      environment: 'testing',
      commitUrlPrefix:
        'https://gitlab.com/france-connect/FranceConnect/commit/',
      currentBranch,
      latestCommitShortHash: shortHash,
      latestCommitLongHash: longHash,
      app_root: '/foo/bar',
      instanceFor: 'FC',
    });

    await localsInterceptor.intercept(context, next);

    expect(configService.get).toBeCalledWith('app');
    expect(res.locals.APP_ENVIRONMENT).toBe('testing');
    expect(res.locals.APP_ROOT).toBe('/foo/bar');
    expect(res.locals.COMMIT_URL_PREFIX).toBe(
      'https://gitlab.com/france-connect/FranceConnect/commit/',
    );
    expect(res.locals.GIT_CURRENT_BRANCH).toBe(currentBranch);
    expect(res.locals.GIT_LATEST_COMMIT_SHORT_HASH).toBe(shortHash);
    expect(res.locals.GIT_LATEST_COMMIT_LONG_HASH).toBe(longHash);
    expect(res.locals.CURRENT_USER).toBe(req.user);
    expect(next.handle).toBeCalledTimes(1);
    expect(res.locals.USER_ROLES_OPTIONS).toEqual([
      { label: 'Administrateur', value: UserRole.ADMIN },
      { label: 'Exploitant', value: UserRole.OPERATOR },
      { label: 'Sécurité', value: UserRole.SECURITY },
      { label: 'Nouvel utilisateur', value: UserRole.NEWUSER },
      { label: 'Administrateur inactif', value: UserRole.INACTIVE_ADMIN },
      { label: 'Exploitant inactif', value: UserRole.INACTIVE_OPERATOR },
      { label: 'Sécurité inactif', value: UserRole.INACTIVE_SECURITY },
      { label: 'Utilisateur bloqué', value: UserRole.BLOCKED_USER },
    ]);
  });

  describe('FCA', () => {
    it('should return all fca scope list authorized', () => {
      // action
      const result = LocalsInterceptor.getFcaSCOPES;

      // expect
      expect(result).toEqual(FCA_SCOPES);
    });

    it('should return true if currentScope is in authorized scope list and scope list requested by SP', () => {
      // setup
      const currentScope = 'uid';
      const scopeListFromFSMock = [
        'openid',
        'given_name',
        'usual_name',
        'email',
        'uid',
      ];

      // action
      const result = LocalsInterceptor.hasFcaScope(
        scopeListFromFSMock,
        currentScope,
      );

      // expect
      expect(result).toEqual(true);
    });

    it('should return false if currentScope is not in authorized scope list', () => {
      // setup
      const currentScope = 'scope_not_exist';
      const scopeListFromFSMock = [
        'openid',
        'given_name',
        'usual_name',
        'email',
        'uid',
      ];

      // action
      const result = LocalsInterceptor.hasFcaScope(
        scopeListFromFSMock,
        currentScope,
      );

      // expect
      expect(result).toEqual(false);
    });

    it('should return false if currentScope is not in scope list requested by FS', () => {
      // setup
      const currentScope = 'siret';
      const scopeListFromFSMock = [
        'openid',
        'given_name',
        'usual_name',
        'email',
        'uid',
      ];

      // action
      const result = LocalsInterceptor.hasFcaScope(
        scopeListFromFSMock,
        currentScope,
      );

      // expect
      expect(result).toEqual(false);
    });
  });

  describe('FC/FC+', () => {
    it('should return all fc scope list authorized', () => {
      // action
      const result = LocalsInterceptor.getFcSCOPES;

      // expect
      expect(result).toEqual(FC_SCOPES);
    });

    it('should return true if currentScope is in authorized scope list and scope list requested by SP (for FC/FC+)', () => {
      // setup
      const currentScope = 'given_name';
      const scopeListFromFSMock = ['openid', 'given_name', 'family_name'];

      // action
      const result = LocalsInterceptor.hasFcScope(
        scopeListFromFSMock,
        currentScope,
      );

      // expect
      expect(result).toEqual(true);
    });

    it('should return false if currentScope is not in authorized scope list (for FC/FC+)', () => {
      // setup
      const currentScope = 'not_scope';
      const scopeListFromFSMock = ['openid', 'given_name', 'family_name'];

      // action
      const result = LocalsInterceptor.hasFcScope(
        scopeListFromFSMock,
        currentScope,
      );

      // expect
      expect(result).toEqual(false);
    });

    it('should return false if currentScope is not in scope list requested by FS (for FC/FC+)', () => {
      // setup
      const currentScope = 'gender';
      const scopeListFromFSMock = ['openid', 'given_name', 'family_name'];

      // action
      const result = LocalsInterceptor.hasFcScope(
        scopeListFromFSMock,
        currentScope,
      );

      // expect
      expect(result).toEqual(false);
    });
  });
});
