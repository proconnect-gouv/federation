import { Injectable } from '@nestjs/common';
import { Repository } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import { IdentityProvider } from './identity-provider.entity';
import { PaginationService } from '@fc/shared/pagination/pagination.service';
import { IIdentityProviderDTO } from './interface/identity-provider-dto.interface';
import { IIdentityProvider } from './interface/identity-provider.interface';
import { IIdentityProviderLegacy } from './interface/identity-provider-legacy.interface';
import { SecretManagerService } from '../common/secret-manager.service';

@Injectable()
export class IdentityProviderService extends PaginationService<
  IdentityProvider
> {
  constructor(
    @InjectRepository(IdentityProvider, 'fc-mongo')
    private readonly identityProviderRepository: Repository<IdentityProvider>,
    private readonly secretManager: SecretManagerService,
  ) {
    super(identityProviderRepository);
  }

  async countProviders() {
    return this.identityProviderRepository.count();
  }

  async create(provider: IIdentityProviderDTO, user) {
    const newProvider: IIdentityProvider = await this.createAdaptedIdentityProvider(
      provider,
      user,
    );
    const providerToSave: IIdentityProviderLegacy = await this.tranformIntoLegacy(
      newProvider,
    );

    return this.identityProviderRepository.save(providerToSave);
  }

  private async createAdaptedIdentityProvider(
    provider: IIdentityProviderDTO,
    user,
  ): Promise<IIdentityProvider> {
    const adaptedProvider = provider;
    if (adaptedProvider.hoverMsg === '') {
      provider.hoverMsg = 'Disponible prochainement';
    }
    adaptedProvider.specificText =
      'Une erreur est survenue lors de la transmission de votre identit√©.';

    const now = new Date();

    delete adaptedProvider.clientSecret;

    return Object.assign(adaptedProvider, {
      active: false,
      display: false,
      createdAt: now,
      updatedAt: now,
      updatedBy: user,
      clientSecretHash: await this.secretManager.encrypt(
        adaptedProvider.clientSecret,
      ),
      jwtAlgorithm: [],
      blacklistByIdentityProviderActivated: false,
      WhitelistByServiceProviderActivated: false,
    });
  }

  private async tranformIntoLegacy(
    provider: IIdentityProvider,
  ): Promise<IIdentityProviderLegacy> {
    return {
      ...provider,
      mailto: provider.mailto.join('\r\n'),
    };
  }
}
