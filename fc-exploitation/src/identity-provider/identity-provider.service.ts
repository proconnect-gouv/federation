import { v4 as uuid } from 'uuid';
import { Injectable, NotFoundException } from '@nestjs/common';
import { DeleteResult, MongoRepository, UpdateWriteOpResult } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import { IdentityProvider } from './identity-provider.mongodb.entity';
import { linesToArray } from '@fc/shared/transforms/string.transform';
import { IIdentityProviderDTO } from './interface/identity-provider-dto.interface';
import { IIdentityProvider } from './interface/identity-provider.interface';
import { IIdentityProviderLegacy } from './interface/identity-provider-legacy.interface';
import { IOptions } from '@fc/shared/pagination/interface/options-query-mongodb.interface';
import { SecretManagerService } from '../utils/secret-manager.service';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { ConfigService } from 'nestjs-config';
import { ObjectID } from 'mongodb';

@Injectable()
export class IdentityProviderService {
  constructor(
    @InjectRepository(IdentityProvider, 'fc-mongo')
    private readonly identityProviderRepository: MongoRepository<
      IdentityProvider
    >,
    private readonly secretManager: SecretManagerService,
    @InjectModel('Provider')
    private readonly providerModel: Model<IIdentityProvider>,
    private readonly config: ConfigService,
  ) {}

  async countProviders() {
    return this.identityProviderRepository.count();
  }

  async create(provider: IIdentityProviderDTO, user) {
    const { instanceFor } = await this.config.get('app');
    const defaultedProvider = await this.setDefaultValues(provider);

    const newProvider: IIdentityProvider = await this.transformIntoEntity(
      defaultedProvider,
      user,
      'create',
    );

    if (instanceFor === 'FCA') {
      [
        'revocation_endpoint_auth_method',
        'id_token_encrypted_response_alg',
        'id_token_encrypted_response_enc',
        'userinfo_encrypted_response_alg',
        'userinfo_encrypted_response_enc',
      ].forEach(elem => (newProvider[elem] = ''));
    }

    const providerToSave: IIdentityProviderLegacy = this.tranformIntoLegacy(
      newProvider,
    );

    return this.identityProviderRepository.insertOne(providerToSave);
  }

  async findById(id: string): Promise<IIdentityProvider> {
    const identityProviderLegacy: IdentityProvider = await this.identityProviderRepository.findOne(
      id,
    );

    if (!identityProviderLegacy) {
      throw new NotFoundException();
    }

    identityProviderLegacy.client_secret = this.secretManager.decrypt(
      identityProviderLegacy.client_secret,
    );

    const identityProvider: IIdentityProvider = this.tranformFromLegacy(
      identityProviderLegacy,
    );

    return identityProvider;
  }

  async update(
    id: string,
    data: IIdentityProviderDTO,
    user: string,
  ): Promise<UpdateWriteOpResult> {
    const { instanceFor } = await this.config.get('app');

    const newProvider: IIdentityProvider = await this.transformIntoEntity(
      data,
      user,
      'update',
    );

    // We don't want the technical name or the createdAt date to be changed
    delete newProvider.uid;

    if (instanceFor === 'FCA') {
      [
        'revocation_endpoint_auth_method',
        'id_token_encrypted_response_alg',
        'id_token_encrypted_response_enc',
        'userinfo_encrypted_response_alg',
        'userinfo_encrypted_response_enc',
      ].forEach(elem => (newProvider[elem] = ''));
    }

    const providerToSave: IIdentityProviderLegacy = this.tranformIntoLegacy(
      newProvider,
    );

    const result = await this.identityProviderRepository.replaceOne(
      {
        _id: ObjectID(id),
      },
      providerToSave,
    );

    return result;
  }

  async deleteIdentityProvider(param): Promise<DeleteResult> {
    return this.identityProviderRepository.delete(param);
  }

  private async transformIntoEntity(
    provider: IIdentityProviderDTO,
    user: string,
    mode: string,
  ): Promise<IIdentityProvider> {
    const now = new Date();

    // quick-fix to not register these two in database...
    Reflect.deleteProperty(provider, '_totp');
    Reflect.deleteProperty(provider, '_csrf');

    const clientSecret = await this.secretManager.encrypt(
      provider.client_secret,
    );

    return {
      ...provider,
      active: mode === 'create' ? false : provider.active,
      display: mode === 'create' ? false : provider.display,
      createdAt: now,
      updatedAt: now,
      updatedBy: user,
      client_secret: clientSecret,
      jwtAlgorithm: [],
      blacklistByIdentityProviderActivated: false,
      whitelistByServiceProviderActivated: false,
      messageToDisplayWhenInactive:
        provider.messageToDisplayWhenInactive || 'Disponible prochainement',
      specificText:
        provider.specificText ||
        'Une erreur est survenue lors de la transmission de votre identitÃ©.',
    };
  }

  async paginate(option: IOptions) {
    const paramaters: IOptions = {
      page: option.page,
      limit: option.limit,
      defaultLimit: option.defaultLimit,
      userSearch: option.userSearch,
    };

    if (option.sort) {
      paramaters.sort = option.sort;
    }

    if (option.action) {
      paramaters.action = option.action;
    }

    return this.providerModel.paginate({}, option.route, paramaters);
  }

  private tranformIntoLegacy(
    provider: IIdentityProvider,
  ): IIdentityProviderLegacy {
    const legacyProvider = {
      ...provider,
      hoverMsg: provider.messageToDisplayWhenInactive,
      hoverRedirectLink: provider.redirectionTargetWhenInactive,
      clientID: provider.clientId,
      authzURL: provider.authorizationUrl,
      statusURL: provider.statusUrl,
      tokenURL: provider.tokenUrl,
      userInfoURL: provider.userInfoUrl,
      endSessionURL: provider.logoutUrl,
      jwksURL: provider.jwksUrl,
      WhitelistByServiceProviderActivated:
        provider.whitelistByServiceProviderActivated,
      mailto: provider.emails.join('\r\n'),
      url: provider.issuer,
      userinfo_encrypted_response_enc: provider.userinfo_encrypted_response_enc,
      userinfo_encrypted_response_alg: provider.userinfo_encrypted_response_alg,
      userinfo_signed_response_alg: provider.userinfo_signed_response_alg,
      id_token_signed_response_alg: provider.id_token_signed_response_alg,
      id_token_encrypted_response_alg: provider.id_token_encrypted_response_alg,
      id_token_encrypted_response_enc: provider.id_token_encrypted_response_enc,
      token_endpoint_auth_method: provider.token_endpoint_auth_method,
    };

    delete legacyProvider.messageToDisplayWhenInactive;
    delete legacyProvider.redirectionTargetWhenInactive;
    delete legacyProvider.clientId;
    delete legacyProvider.authorizationUrl;
    delete legacyProvider.statusUrl;
    delete legacyProvider.tokenUrl;
    delete legacyProvider.userInfoUrl;
    delete legacyProvider.logoutUrl;
    delete legacyProvider.jwksUrl;
    delete legacyProvider.whitelistByServiceProviderActivated;
    delete legacyProvider.emails;
    delete legacyProvider.issuer;

    Object.keys(legacyProvider)
      .filter(key => typeof legacyProvider[key] === 'undefined')
      .map(key => {
        delete legacyProvider[key];
      });
    return legacyProvider;
  }

  private tranformFromLegacy(
    legacyProvider: IIdentityProviderLegacy,
  ): IIdentityProvider {
    const provider = {
      ...legacyProvider,
      messageToDisplayWhenInactive: legacyProvider.hoverMsg,
      redirectionTargetWhenInactive: legacyProvider.hoverRedirectLink,
      clientId: legacyProvider.clientID,
      authorizationUrl: legacyProvider.authzURL,
      statusUrl: legacyProvider.statusURL,
      tokenUrl: legacyProvider.tokenURL,
      userInfoUrl: legacyProvider.userInfoURL,
      logoutUrl: legacyProvider.endSessionURL,
      jwksUrl: legacyProvider.jwksURL,
      whitelistByServiceProviderActivated:
        legacyProvider.WhitelistByServiceProviderActivated,
      emails: linesToArray(legacyProvider.mailto),
      issuer: legacyProvider.url,
    };

    delete provider.hoverMsg;
    delete provider.hoverRedirectLink;
    delete provider.clientID;
    delete provider.authzURL;
    delete provider.statusURL;
    delete provider.tokenURL;
    delete provider.userInfoURL;
    delete provider.endSessionURL;
    delete provider.jwksURL;
    delete provider.WhitelistByServiceProviderActivated;
    delete provider.mailto;
    delete provider.url;

    return provider;
  }

  private async setDefaultValues(
    provider: IIdentityProviderDTO,
  ): Promise<IIdentityProviderDTO> {
    const { defaultValues } = await this.config.get('identity-provider');

    const uid = uuid();

    const generatedProperies = {
      uid,
      redirect_uris: [`${defaultValues.redirect_uris}/${uid}`],
    };

    return {
      ...defaultValues,
      ...generatedProperies,
      ...provider,
    };
  }
}
