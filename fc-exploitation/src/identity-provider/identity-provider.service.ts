import { v4 as uuid } from 'uuid';
import { Model } from 'mongoose';
import { DeleteResult, FindAndModifyWriteOpResultObject } from 'typeorm';
import { Repository } from 'mongodb';
import { ConfigService } from 'nestjs-config';
import { ObjectID } from 'mongodb';

import { InjectModel } from '@nestjs/mongoose';
import { InjectRepository } from '@nestjs/typeorm';
import { Injectable, NotFoundException } from '@nestjs/common';

import { linesToArray } from '@fc/shared/transforms/string.transform';
import { IOptions } from '@fc/shared/pagination/interface/options-query-mongodb.interface';
import { LoggerService } from '@fc/shared/logger/logger.service';

import { ICrudTrack } from '../interfaces';
import { SecretManagerService } from '../utils/secret-manager.service';

import { IdentityProvider } from './identity-provider.mongodb.entity';
import { IIdentityProviderDTO } from './interface/identity-provider-dto.interface';
import { IIdentityProvider } from './interface/identity-provider.interface';
import { IIdentityProviderLegacy } from './interface/identity-provider-legacy.interface';
import { ModifierData } from './interface/modifier-data.interface';

@Injectable()
export class IdentityProviderService {
  constructor(
    @InjectRepository(IdentityProvider, 'fc-mongo')
    private readonly identityProviderRepository: Repository<IdentityProvider>,
    private readonly secretManager: SecretManagerService,
    @InjectModel('Provider')
    private readonly providerModel: Model<IIdentityProvider>,
    private readonly config: ConfigService,
    private readonly logger: LoggerService,
  ) {}

  private track(log: ICrudTrack) {
    this.logger.businessEvent(log);
  }

  async getAll(): Promise<IIdentityProvider[]> {
    try {
      const result = await this.identityProviderRepository.find();
      return result;
    } catch ({ message }) {
      const msg = `Unable to retrieve all identity providers : ${message}`;
      this.logger.error(msg);
      throw new Error(msg);
    }
  }

  async countProviders() {
    return this.identityProviderRepository.count();
  }

  async create(provider: IIdentityProviderDTO, user) {
    const { instanceFor } = await this.config.get('app');
    const defaultedProvider = await this.setDefaultValues(provider);

    const newProvider: IIdentityProvider = await this.transformIntoEntity(
      defaultedProvider,
      user,
      'create',
    );

    // Warning change this once FCP allow eidas 1
    if (instanceFor === 'FCA' && newProvider.eidas === 1) {
      [
        'revocation_endpoint_auth_method',
        'id_token_encrypted_response_alg',
        'id_token_encrypted_response_enc',
        'userinfo_encrypted_response_alg',
        'userinfo_encrypted_response_enc',
      ].forEach(elem => (newProvider[elem] = ''));
    }

    const providerToSave: IIdentityProviderLegacy = this.tranformIntoLegacy(
      newProvider,
    );

    const saveOperation = await this.identityProviderRepository.insertOne(
      providerToSave,
    );

    this.track({
      entity: 'identity-provider',
      action: 'create',
      user,
      id: saveOperation.insertedId,
      name: provider.name,
    });

    return saveOperation;
  }

  async findById(id: string): Promise<IIdentityProvider> {
    const identityProviderLegacy: IdentityProvider = await this.identityProviderRepository.findOne(
      id,
    );

    if (!identityProviderLegacy) {
      throw new NotFoundException();
    }

    identityProviderLegacy.client_secret = this.secretManager.decrypt(
      identityProviderLegacy.client_secret,
    );

    const identityProvider: IIdentityProvider = this.tranformFromLegacy(
      identityProviderLegacy,
    );

    return identityProvider;
  }

  async update(
    id: string,
    data: IIdentityProviderDTO,
    user: string,
  ): Promise<FindAndModifyWriteOpResultObject> {
    this.track({
      entity: 'identity-provider',
      action: 'update',
      user,
      id,
      name: data.name,
    });

    const { instanceFor } = await this.config.get('app');

    // recupérer la version en base

    const newProvider: IIdentityProvider = await this.transformIntoEntity(
      data,
      user,
      'update',
    );

    // We don't want the technical name or the createdAt date to be changed
    delete newProvider.uid;

    // Warning change this once FCP allow eidas 1
    if (instanceFor === 'FCA' && newProvider.eidas === 1) {
      [
        'revocation_endpoint_auth_method',
        'id_token_encrypted_response_alg',
        'id_token_encrypted_response_enc',
        'userinfo_encrypted_response_alg',
        'userinfo_encrypted_response_enc',
      ].forEach(elem => (newProvider[elem] = ''));
    }

    // diff entre version en base et nouvelle version

    const providerToSave: IIdentityProviderLegacy = this.tranformIntoLegacy(
      newProvider,
    );

    const result = await this.identityProviderRepository.findOneAndUpdate(
      {
        _id: ObjectID(id),
      },
      this.buildModifier(providerToSave),
    );

    return result;
  }

  buildModifier(providerToSave: IIdentityProviderLegacy): ModifierData {
    const modifier: any = {
      $set: {
        ...providerToSave,
      },
    };

    if (providerToSave.discovery) {
      modifier.$unset = {
        jwksURL: '',
        authzURL: '',
        userInfoURL: '',
        tokenURL: '',
      };
    } else {
      modifier.$unset = {
        discoveryUrl: '',
      };
    }

    return modifier;
  }

  async deleteIdentityProvider(id, user: string): Promise<DeleteResult> {
    const identityProvider = await this.identityProviderRepository.findOne(id);

    this.track({
      entity: 'identity-provider',
      action: 'delete',
      user,
      id,
      name: identityProvider.name,
    });

    return this.identityProviderRepository.delete(id);
  }

  private async transformIntoEntity(
    provider: IIdentityProviderDTO,
    user: string,
    mode: string,
  ): Promise<IIdentityProvider> {
    const now = new Date();

    // quick-fix to not register these two in database...
    Reflect.deleteProperty(provider, '_totp');
    Reflect.deleteProperty(provider, '_csrf');

    const clientSecret = await this.secretManager.encrypt(
      provider.client_secret,
    );

    return {
      ...provider,
      active: mode === 'create' ? false : provider.active,
      display: mode === 'create' ? false : provider.display,
      createdAt: now,
      updatedAt: now,
      updatedBy: user,
      client_secret: clientSecret,
      jwtAlgorithm: [],
      blacklistByIdentityProviderActivated: false,
      whitelistByServiceProviderActivated: false,
      messageToDisplayWhenInactive:
        provider.messageToDisplayWhenInactive || 'Disponible prochainement',
      specificText:
        provider.specificText ||
        'Une erreur est survenue lors de la transmission de votre identité.',
    };
  }

  async paginate(option: IOptions) {
    const paramaters: IOptions = {
      page: option.page,
      limit: option.limit,
      defaultLimit: option.defaultLimit,
      userSearch: option.userSearch,
    };

    if (option.sort) {
      paramaters.sort = option.sort;
    }

    if (option.action) {
      paramaters.action = option.action;
    }

    return this.providerModel.paginate({}, option.route, paramaters);
  }

  private tranformIntoLegacy(
    provider: IIdentityProvider,
  ): IIdentityProviderLegacy {
    const legacyProvider = {
      ...provider,
      hoverMsg: provider.messageToDisplayWhenInactive,
      hoverRedirectLink: provider.redirectionTargetWhenInactive,
      clientID: provider.clientId,
      authzURL: provider.authorizationUrl,
      statusURL: provider.statusUrl,
      tokenURL: provider.tokenUrl,
      userInfoURL: provider.userInfoUrl,
      endSessionURL: provider.logoutUrl,
      jwksURL: provider.jwksUrl,
      WhitelistByServiceProviderActivated:
        provider.whitelistByServiceProviderActivated,
      mailto: provider.emails.join('\r\n'),
      url: provider.issuer,
      userinfo_encrypted_response_enc: provider.userinfo_encrypted_response_enc,
      userinfo_encrypted_response_alg: provider.userinfo_encrypted_response_alg,
      userinfo_signed_response_alg: provider.userinfo_signed_response_alg,
      id_token_signed_response_alg: provider.id_token_signed_response_alg,
      id_token_encrypted_response_alg: provider.id_token_encrypted_response_alg,
      id_token_encrypted_response_enc: provider.id_token_encrypted_response_enc,
      token_endpoint_auth_method: provider.token_endpoint_auth_method,
    };

    delete legacyProvider.messageToDisplayWhenInactive;
    delete legacyProvider.redirectionTargetWhenInactive;
    delete legacyProvider.clientId;
    delete legacyProvider.authorizationUrl;
    delete legacyProvider.statusUrl;
    delete legacyProvider.tokenUrl;
    delete legacyProvider.userInfoUrl;
    delete legacyProvider.logoutUrl;
    delete legacyProvider.jwksUrl;
    delete legacyProvider.whitelistByServiceProviderActivated;
    delete legacyProvider.emails;
    delete legacyProvider.issuer;

    Object.keys(legacyProvider)
      .filter(key => typeof legacyProvider[key] === 'undefined')
      .map(key => {
        delete legacyProvider[key];
      });
    return legacyProvider;
  }

  private tranformFromLegacy(
    legacyProvider: IIdentityProviderLegacy,
  ): IIdentityProvider {
    const provider = {
      ...legacyProvider,
      messageToDisplayWhenInactive: legacyProvider.hoverMsg,
      redirectionTargetWhenInactive: legacyProvider.hoverRedirectLink,
      clientId: legacyProvider.clientID,
      authorizationUrl: legacyProvider.authzURL,
      statusUrl: legacyProvider.statusURL,
      tokenUrl: legacyProvider.tokenURL,
      userInfoUrl: legacyProvider.userInfoURL,
      logoutUrl: legacyProvider.endSessionURL,
      jwksUrl: legacyProvider.jwksURL,
      whitelistByServiceProviderActivated:
        legacyProvider.WhitelistByServiceProviderActivated,
      emails: linesToArray(legacyProvider.mailto),
      issuer: legacyProvider.url,
    };

    delete provider.hoverMsg;
    delete provider.hoverRedirectLink;
    delete provider.clientID;
    delete provider.authzURL;
    delete provider.statusURL;
    delete provider.tokenURL;
    delete provider.userInfoURL;
    delete provider.endSessionURL;
    delete provider.jwksURL;
    delete provider.WhitelistByServiceProviderActivated;
    delete provider.mailto;
    delete provider.url;

    return provider;
  }

  private async setDefaultValues(
    provider: IIdentityProviderDTO,
  ): Promise<IIdentityProviderDTO> {
    const { defaultValues } = await this.config.get('identity-provider');

    const uid = uuid();

    return {
      uid,
      ...defaultValues,
      ...provider,
    };
  }
}
