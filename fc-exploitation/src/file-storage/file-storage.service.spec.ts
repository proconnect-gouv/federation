import { Repository } from 'typeorm';
import { ObjectID } from 'mongodb';
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken, TypeOrmModule } from '@nestjs/typeorm';
import { FileStorageService } from './file-storage.service';
import { FileStorage } from './file-storage.mongodb.entity';

describe('FileStorageService', () => {
  const originalDateNow = Date.now;

  let module: TestingModule;
  let fileStorageService: FileStorageService;

  const file = {
    id: new ObjectID('5d662c66b8e03e2912315da4'),
    fieldname: 'logo',
    originalname: '   Logo    with some     spaces   .png',
    encoding: '7bits',
    mimetype: 'image/png',
    buffer: Buffer.from('myimage'),
    size: 4200,
  };

  const filenameAsSaved = '4242424242424_Logo_with_some_spaces_.png';

  const toArrayMock = jest.fn();
  const gridFSBucketMock = {
    openUploadStream: jest.fn(),
    openDownloadStreamByName: jest.fn(),
    delete: jest.fn(),
    find: jest.fn(),
  };

  const readStreamMock = jest.fn();

  const dbMock = jest.fn();

  const FileStorageRepositoryMock = {
    manager: {
      connection: {
        driver: {
          queryRunner: {
            databaseConnection: {
              db: dbMock,
            },
          },
          mongodb: {
            GridFSBucket: function GridFSBucket(db) {
              return gridFSBucketMock;
            },
          },
        },
      },
    },
  };

  beforeEach(async () => {
    Date.now = jest.fn().mockReturnValue('4242424242424');

    module = await Test.createTestingModule({
      imports: [TypeOrmModule.forFeature([FileStorage], 'fc-mongo')],
      providers: [FileStorageService, FileStorage],
    })
      .overrideProvider(getRepositoryToken(FileStorage, 'fc-mongo'))
      .useValue(FileStorageRepositoryMock)
      .compile();

    fileStorageService = await module.get<FileStorageService>(
      FileStorageService,
    );
    jest.resetAllMocks();
  });

  afterAll(async () => {
    Date.now = originalDateNow;
    module.close();
  });

  describe('storeFile', () => {
    beforeEach(() => {
      gridFSBucketMock.openUploadStream.mockReturnValue({
        end: jest.fn().mockImplementation((buffer: Buffer, cb) => {
          cb(null, file);
        }),
      });
    });

    it('should remove and replace unecessaries spaces in filename before storing the file', async () => {
      // action
      await fileStorageService.storeFile(file);

      // expect
      expect(gridFSBucketMock.openUploadStream).toHaveBeenCalledTimes(1);
      expect(gridFSBucketMock.openUploadStream).toHaveBeenCalledWith(
        `${Date.now()}${file.originalname.replace(/\s+/g, '_')}`,
        expect.anything(),
      );
    });

    it('should insert the file contentType from mimetype and the encoding to metadata in database', async () => {
      // action
      await fileStorageService.storeFile(file);

      // expect
      expect(gridFSBucketMock.openUploadStream).toHaveBeenCalledTimes(1);
      expect(gridFSBucketMock.openUploadStream).toHaveBeenCalledWith(
        expect.anything(),
        {
          contentType: file.mimetype,
          metadata: { encoding: file.encoding },
        },
      );
    });

    it('should throw an error if there is no file to store', async () => {
      // action
      try {
        await fileStorageService.storeFile(undefined);
      } catch (e) {
        // expect
        expect(gridFSBucketMock.openUploadStream).toHaveBeenCalledTimes(0);
        expect(e.message).toBe("Aucun logo valide n'a été fourni");
      }
      expect.hasAssertions();
    });

    it('should throw an error if there is an error when writing on the stream', async () => {
      // setup
      gridFSBucketMock.openUploadStream.mockReturnValue({
        end: jest.fn().mockImplementation((buffer: Buffer, cb) => {
          cb(new Error('Unexpected stream error :('), undefined);
        }),
      });

      // action
      try {
        await fileStorageService.storeFile(file);
      } catch (e) {
        // expect
        expect(gridFSBucketMock.openUploadStream).toHaveBeenCalledTimes(1);
        expect(e.message).toBe('Unexpected stream error :(');
      }
      expect.hasAssertions();
    });
  });

  describe('getFileAsDataUri', () => {
    beforeEach(() => {
      gridFSBucketMock.find.mockReturnValue({
        toArray: toArrayMock.mockResolvedValue([
          {
            contentType: file.mimetype,
            metadata: { encoding: file.encoding },
          },
        ]),
      });

      gridFSBucketMock.openDownloadStreamByName.mockReturnValue({
        on: jest.fn().mockImplementation((event: string, cb) => {
          switch (event) {
            case 'data':
              cb(file.buffer);
              break;
            case 'end': {
              cb();
              break;
            }
          }
        }),
        read: readStreamMock,
      });
    });

    it('should retrieve file informations and then download the file itself from gridfs', async () => {
      // action
      await fileStorageService.getFileAsDataUri(filenameAsSaved);

      // expect
      expect(readStreamMock).toHaveBeenCalledTimes(1);
      expect(gridFSBucketMock.find).toHaveBeenCalledTimes(1);
      expect(gridFSBucketMock.find).toHaveBeenCalledWith({
        filename: filenameAsSaved,
      });
      expect(gridFSBucketMock.openDownloadStreamByName).toHaveBeenCalledTimes(
        1,
      );
      expect(gridFSBucketMock.openDownloadStreamByName).toHaveBeenCalledWith(
        filenameAsSaved,
      );
    });

    it('should return the file as data uri', async () => {
      // action
      const fileAsDataUri = await fileStorageService.getFileAsDataUri(
        filenameAsSaved,
      );

      // expect
      expect(fileAsDataUri).toBe(
        `data:${file.mimetype};base64,${file.buffer.toString('base64')}`,
      );
    });

    it('should retrieve file informations and then download the file itself from gridfs with multiple data event on the stream', async () => {
      // setup
      gridFSBucketMock.openDownloadStreamByName.mockReturnValue({
        on: jest.fn().mockImplementation((event: string, cb) => {
          switch (event) {
            case 'data':
              // equivalent to multiple data event
              cb(file.buffer);
              cb(file.buffer);
              cb(file.buffer);
              break;
            case 'end': {
              cb();
              break;
            }
          }
        }),
        read: readStreamMock,
      });

      // action
      const fileAsDataUri = await fileStorageService.getFileAsDataUri(
        filenameAsSaved,
      );

      // expect
      expect(readStreamMock).toHaveBeenCalledTimes(1);
      expect(gridFSBucketMock.find).toHaveBeenCalledTimes(1);
      expect(gridFSBucketMock.find).toHaveBeenCalledWith({
        filename: filenameAsSaved,
      });
      expect(gridFSBucketMock.openDownloadStreamByName).toHaveBeenCalledTimes(
        1,
      );
      expect(gridFSBucketMock.openDownloadStreamByName).toHaveBeenCalledWith(
        filenameAsSaved,
      );
      expect(fileAsDataUri).toBe(
        'data:image/png;base64,bXlpbWFnZW15aW1hZ2VteWltYWdl',
      );
    });

    it('should throw an error if the stream emit an error event', async () => {
      // setup
      gridFSBucketMock.openDownloadStreamByName.mockReturnValue({
        on: jest.fn().mockImplementation((event: string, cb) => {
          switch (event) {
            case 'error':
              cb(new Error('Unexpected stream error :('));
              break;
          }
        }),
        read: readStreamMock,
      });

      // action
      try {
        const fileAsDataUri = await fileStorageService.getFileAsDataUri(
          filenameAsSaved,
        );
      } catch (e) {
        // expect
        expect(readStreamMock).toHaveBeenCalledTimes(1);
        expect(gridFSBucketMock.find).toHaveBeenCalledTimes(1);
        expect(gridFSBucketMock.find).toHaveBeenCalledWith({
          filename: filenameAsSaved,
        });
        expect(gridFSBucketMock.openDownloadStreamByName).toHaveBeenCalledTimes(
          1,
        );
        expect(gridFSBucketMock.openDownloadStreamByName).toHaveBeenCalledWith(
          filenameAsSaved,
        );
        expect(e.message).toBe('Unexpected stream error :(');
      }
      expect.hasAssertions();
    });

    it('should return return "undefined" if there is no file corresponding', async () => {
      // setup
      gridFSBucketMock.find.mockReturnValue({
        toArray: toArrayMock.mockResolvedValue([]),
      });

      // action
      const fileAsDataUri = await fileStorageService.getFileAsDataUri(
        filenameAsSaved,
      );

      // expect
      expect(readStreamMock).toHaveBeenCalledTimes(0);
      expect(gridFSBucketMock.find).toHaveBeenCalledTimes(1);
      expect(gridFSBucketMock.find).toHaveBeenCalledWith({
        filename: filenameAsSaved,
      });
      expect(fileAsDataUri).toBe(undefined);
    });
  });

  describe('deleteFile', () => {
    beforeEach(() => {
      gridFSBucketMock.find.mockReturnValue({
        toArray: toArrayMock.mockResolvedValue([
          {
            _id: file.id,
            contentType: file.mimetype,
            metadata: { encoding: file.encoding },
          },
        ]),
      });

      gridFSBucketMock.delete.mockImplementation((id, cb) => {
        cb();
      });
    });

    it('should retrieve file informations and then delete it from GridFS', async () => {
      // action
      const result = await fileStorageService.deleteFile(filenameAsSaved);

      // expect
      expect(gridFSBucketMock.find).toHaveBeenCalledTimes(1);
      expect(gridFSBucketMock.find).toHaveBeenCalledWith({
        filename: filenameAsSaved,
      });
      expect(gridFSBucketMock.delete).toHaveBeenCalledTimes(1);
      expect(gridFSBucketMock.delete).toHaveBeenCalledWith(
        file.id,
        expect.anything(),
      );
      expect(result).toEqual({
        _id: file.id,
        contentType: file.mimetype,
        metadata: { encoding: file.encoding },
      });
    });

    it('should return return "undefined" if there is no file corresponding', async () => {
      // setup
      gridFSBucketMock.find.mockReturnValue({
        toArray: toArrayMock.mockResolvedValue([]),
      });

      // action
      const result = await fileStorageService.deleteFile(filenameAsSaved);
      // expect
      expect(gridFSBucketMock.find).toHaveBeenCalledTimes(1);
      expect(gridFSBucketMock.find).toHaveBeenCalledWith({
        filename: filenameAsSaved,
      });
      expect(result).toBe(undefined);
    });

    it('should throw an error if the file informations are found but GridFS delete fail', async () => {
      // setup
      gridFSBucketMock.delete.mockImplementation((id, cb) => {
        cb(new Error('Oops ! Fail !'));
      });

      // action
      try {
        await fileStorageService.deleteFile(filenameAsSaved);
      } catch (e) {
        // expect
        expect(gridFSBucketMock.find).toHaveBeenCalledTimes(1);
        expect(gridFSBucketMock.find).toHaveBeenCalledWith({
          filename: filenameAsSaved,
        });
        expect(gridFSBucketMock.delete).toHaveBeenCalledTimes(1);
        expect(gridFSBucketMock.delete).toHaveBeenCalledWith(
          file.id,
          expect.anything(),
        );
        expect(e.message).toBe('Oops ! Fail !');
      }
      expect.hasAssertions();
    });
  });
});
