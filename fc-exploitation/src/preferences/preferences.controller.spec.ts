import { Test, TestingModule } from '@nestjs/testing';
import { RectificationRequestDTO } from '@fc/shared/rnipp';
import { CitizenService } from '../citizen/citizen.service';
import { PreferencesController } from './preferences.controller';
import { PreferencesService } from './preferences.service';

describe('PreferencesController', () => {
  let controller: PreferencesController;

  const preferencesServiceMock = {
    createLoggerData: jest.fn(),
    createPayloadData: jest.fn(),
    createPayload: jest.fn(),
    setIdpPreferences: jest.fn(),
    findIdpPreferences: jest.fn(),
  };

  const citizenServiceMock = {
    getPivotIdentityHash: jest.fn(),
    findByHash: jest.fn(),
    createBlockedCitizen: jest.fn(),
    generateLegacyAccountId: jest.fn(),
    setActive: jest.fn(),
    findIdpPreferences: jest.fn(),
  };
  const bodyMock = ({
    gender: 'gender',
    familyName: 'familyName',
    preferredUsername: 'preferredUsername',
    givenName: 'givenName',
    birthdate: 'birthdate',
    supportId: '1111111111',
    isFrench: true,
    cog: '75107',
    toIdentity: jest.fn(),
    toOidc: jest.fn(),
  } as unknown) as RectificationRequestDTO;
  const reqMock = {
    totp: 'valid',
    user: {
      username: 'Toto',
    },
    body: {},
  };
  const resMock = { json: jest.fn() };

  const identityMock = {
    givenName: 'georges',
    familyName: 'moustaki',
    preferredUsername: '',
    birthdate: '1934-01-01',
    gender: 'gender',
    birthPlace: '95277',
    birthCountry: '99100',
  };

  const oidcIdentityMock = {
    given_name: 'georges',
    family_name: 'moustaki',
    preferred_username: '',
    birthdate: '1934-01-01',
    gender: 'gender',
    birthplace: '95277',
    birthcountry: '99100',
  };

  const preferences = {
    idpSettings: {
      updatedAt: 'date',
      allowFutureIdp: false,
      idpList: [
        {
          uid: 'idp_uid',
          name: 'idp',
          image: 'idp.png',
          title: 'IDP',
          active: true,
          isChecked: true,
        },
        {
          uid: 'idp_uid',
          name: 'idp',
          image: 'idp.png',
          title: 'IDP',
          active: true,
          isChecked: true,
        },
      ],
    },
  };

  const loggerData = new Map();
  loggerData.set('identityHash', 'identityHash');
  loggerData.set('user', 'user');
  loggerData.set('supportId', 'supportId');

  const dataToCreatePayload = new Map();
  dataToCreatePayload.set('identity', identityMock);
  dataToCreatePayload.set('idpList', preferences.idpSettings.idpList);
  dataToCreatePayload.set('uid', 'uid');
  dataToCreatePayload.set('allowFutureIdp', false);

  const brokerMockResponse = {
    allowFutureIdp: false,
    idpList: [
      {
        uid: 'idp_uid',
        name: 'idp',
        image: 'idp.png',
        title: 'IDP',
        active: true,
        isChecked: true,
      },
      {
        uid: 'idp_uid',
        name: 'idp',
        image: 'idp.png',
        title: 'IDP',
        active: true,
        isChecked: true,
      },
    ],
  };

  beforeEach(async () => {
    jest.resetAllMocks();
    jest.restoreAllMocks();
    const module: TestingModule = await Test.createTestingModule({
      controllers: [PreferencesController],
      providers: [PreferencesService, CitizenService],
    })
      .overrideProvider(PreferencesService)
      .useValue(preferencesServiceMock)
      .overrideProvider(CitizenService)
      .useValue(citizenServiceMock)
      .compile();

    controller = module.get<PreferencesController>(PreferencesController);
  });

  describe('patchCitizenIdpPreferences', () => {
    it('should update an idp preference', async () => {
      // Given
      citizenServiceMock.getPivotIdentityHash.mockReturnValueOnce(identityMock);

      citizenServiceMock.findByHash.mockResolvedValueOnce({
        _id: 'baz',
        id: 'foobar',
        identityHash: 'foo',
        active: false,
        updatedAt: '2019-06-01T12:34:56.000Z',
        preferences,
      });

      preferencesServiceMock.createLoggerData.mockResolvedValueOnce(loggerData);

      preferencesServiceMock.createPayloadData.mockResolvedValueOnce(
        dataToCreatePayload,
      );

      preferencesServiceMock.setIdpPreferences.mockReturnValueOnce(
        brokerMockResponse,
      );

      // When
      await controller.patchCitizenIdpPreferences(bodyMock, reqMock, resMock);

      // Then
      expect(citizenServiceMock.getPivotIdentityHash).toHaveBeenCalledTimes(1);
      expect(resMock.json).toHaveBeenCalledTimes(1);
      expect(resMock.json).toHaveBeenCalledWith({
        userIdpSettings: brokerMockResponse,
        havePreferencesSettings: true,
      });
    });
  });

  describe('patchFutureIdpPreferences', () => {
    it('should update future idp status', async () => {
      // Given
      citizenServiceMock.getPivotIdentityHash.mockReturnValueOnce(identityMock);

      citizenServiceMock.findByHash.mockResolvedValueOnce({
        _id: 'baz',
        id: 'foobar',
        identityHash: 'foo',
        active: false,
        updatedAt: '2019-06-01T12:34:56.000Z',
        preferences,
      });

      preferencesServiceMock.createPayloadData.mockResolvedValueOnce(
        dataToCreatePayload,
      );

      preferencesServiceMock.createPayload.mockResolvedValueOnce({
        identityMock,
        idpSettings: {
          allowFutureIdp: true,
          idpList: preferences.idpSettings.idpList,
        },
      });

      preferencesServiceMock.setIdpPreferences.mockReturnValueOnce(
        brokerMockResponse,
      );

      // When
      await controller.patchFutureIdpPreferences(bodyMock, reqMock, resMock);

      // Then
      expect(citizenServiceMock.getPivotIdentityHash).toHaveBeenCalledTimes(1);
      expect(resMock.json).toHaveBeenCalledTimes(1);
      expect(resMock.json).toHaveBeenCalledWith({
        userIdpSettings: brokerMockResponse,
        havePreferencesSettings: true,
      });
    });
  });
});
