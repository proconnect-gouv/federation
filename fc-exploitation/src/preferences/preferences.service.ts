import { CitizenServiceBase } from '@fc/shared/citizen/citizen-base.service';
import { IPivotIdentity } from '@fc/shared/citizen/interfaces/pivot-identity.interface';
import { LoggerService } from '@fc/shared/logger/logger.service';
import { RectificationRequestDTO } from '@fc/shared/rnipp';
import {
  IFormattedIdpSettings,
  UserPreferencesService,
} from '@fc/shared/user-preferences';
import {
  IPayload,
  IPayloadData,
} from '@fc/shared/user-preferences/formatted-idp-settings.interface';
import { Injectable } from '@nestjs/common';
import { of } from 'rxjs';
import { PreferencesActions } from './preferences-actions.enum';
import { IPreferencesTrack } from './preferences-track.interface';
@Injectable()
export class PreferencesService {
  constructor(
    private readonly logger: LoggerService,
    private readonly broker: UserPreferencesService,
    private readonly citizen: CitizenServiceBase,
  ) {}

  private track(log: IPreferencesTrack) {
    this.logger.businessEvent(log);
  }

  private createPayload(
    dataToCreatePayload: IPayloadData,
    target: string,
  ): IPayload {
    const { identity, preferences, uid, isChecked } = dataToCreatePayload;

    if (target === 'idpPreferences') {
      preferences.idpList.find(idp => {
        if (idp.uid === uid) {
          idp.isChecked = !isChecked;
        }
      });
    }

    const updatedList = preferences.idpList
      .filter(entry => entry.isChecked === true)
      .map(idp => idp.uid);

    const idpSettings = {
      allowFutureIdp: preferences.allowFutureIdp,
      idpList: updatedList,
    };

    if (target === 'futureIdpPreferences') {
      idpSettings.allowFutureIdp = !preferences.allowFutureIdp;
    }

    return { identity, idpSettings };
  }

  async findIdpPreferences(
    rnippIdentity: IPivotIdentity,
  ): Promise<IFormattedIdpSettings> {
    const rnippIdentityWithNormalizedBirthdateIdentity = {
      ...rnippIdentity,
      birthdate: this.citizen.rectifyIfPartialBirthdate(
        rnippIdentity.birthdate,
      ),
    };

    const identity = this.citizen.generateOIDCIdentity(
      rnippIdentityWithNormalizedBirthdateIdentity,
    );

    // get user preferences with the specific broker
    let userIdpSettings;
    try {
      userIdpSettings = await this.broker.publish('GET_IDP_SETTINGS', {
        identity,
      });
    } catch (error) {
      this.logger.error('Preferences Broker error: ' + error);
    }

    return userIdpSettings;
  }

  async setIdpPreferences(
    identity: RectificationRequestDTO,
    identityHash: string,
    preferences: IFormattedIdpSettings,
    uid: string,
    isChecked: boolean,
    username: string,
    target: string,
  ): Promise<IFormattedIdpSettings> {
    let updatedPreferences;
    const identityToOidc = identity.toOidc();

    // Removing preferred_username because CSMR preference does not need it to calculate the identity hash
    // and causes a DTO validation error
    const { preferred_username: _p, ...pivotIdentity } = identityToOidc;

    const payload = await this.createPayload(
      {
        identity: pivotIdentity,
        preferences,
        uid,
        isChecked,
      },
      target,
    );

    try {
      const preferencesToUpdate = await this.broker.publish(
        'SET_IDP_SETTINGS',
        payload,
      );

      updatedPreferences = await of(preferencesToUpdate).toPromise();
    } catch (err) {
      this.logger.trace(err);
    }

    this.track({
      action:
        target === 'idpPreferences'
          ? PreferencesActions.MODIFIED_IDP_PREFERENCES
          : PreferencesActions.MODIFIED_FUTURE_IDP_PREFERENCES,
      user: username,
      reason: `ticket support : ${identity.supportId}`,
      identityHash,
    });

    return updatedPreferences;
  }
}
