import { Test, TestingModule } from '@nestjs/testing';
import { getModelToken } from '@nestjs/mongoose';
import { TypeOrmModule, getRepositoryToken } from '@nestjs/typeorm';
import { ObjectID } from 'mongodb';
import * as MockDate from 'mockdate';

import { NotificationService } from './notification.service';
import { Notification } from './notification.mongodb.entity';
import { NotificationDTO, NotificationInputDTO } from './dto';
import moment = require('moment-timezone');

describe('NotificationService', () => {
  let module: TestingModule;
  let notificationService: NotificationService;

  const notificationModelMock = {
    paginate: jest.fn(),
  };

  const notificationRepository = {
    save: jest.fn(),
    findOne: jest.fn(),
  };

  const objectId = '648c1742c74d6a3d84b31943';

  MockDate.set(moment('2020-08-08').toDate());

  const createdAt = new Date();
  const updatedAt = new Date();

  beforeEach(async () => {
    module = await Test.createTestingModule({
      imports: [TypeOrmModule.forFeature([Notification], 'fc-mongo')],
      providers: [
        NotificationService,
        {
          provide: getModelToken('Notification'),
          useValue: notificationModelMock,
        },
      ],
    })
      .overrideProvider(getRepositoryToken(Notification, 'fc-mongo'))
      .useValue(notificationRepository)
      .compile();

    notificationService = await module.get<NotificationService>(
      NotificationService,
    );
    jest.resetAllMocks();
  });

  afterAll(async () => {
    module.close();
  });

  it('should be defined', () => {
    expect(notificationService).toBeDefined();
  });

  describe('getNotifications', () => {
    it('should return a promise', async () => {
      // action
      const result = notificationService.getNotifications({});

      // expect
      expect(result).toBeInstanceOf(Promise);
    });

    it('should return the promise returned by notification model "paginate" call', async () => {
      // setup
      const aPromise = new Promise(res => {
        res();
      });
      notificationModelMock.paginate.mockReturnValueOnce(aPromise);

      // action
      const result = notificationService.getNotifications({});

      // expect
      expect(result).toStrictEqual(aPromise);
    });

    it('should call notification model "paginate"', async () => {
      // setup
      const option = {
        page: 1,
        limit: 2,
        route: '/notification/information',
        defaultLimit: 10,
      };

      notificationModelMock.paginate.mockResolvedValueOnce({
        items: [
          {
            message: 'toto est dans la place',
          },
          {
            message: 'trotro aussi',
          },
        ],
        total: 2,
      });

      // action
      await notificationService.getNotifications(option);

      // expect
      expect(notificationModelMock.paginate).toHaveBeenCalledTimes(1);
      expect(notificationModelMock.paginate).toHaveBeenCalledWith(
        {},
        option.route,
        {
          page: 1,
          limit: 2,
          defaultLimit: 10,
        },
      );
    });

    it('should call notification model "paginate" with parameter "sort" if "sort" is given as an option', async () => {
      // setup
      const option = {
        page: 1,
        limit: 2,
        route: '/notification/information',
        sort: 'createdAt',
        defaultLimit: 10,
      };

      notificationModelMock.paginate.mockResolvedValueOnce({
        items: [
          {
            message: 'toto est dans la place',
          },
          {
            message: 'trotro aussi',
          },
        ],
        total: 2,
      });

      // action
      await notificationService.getNotifications(option);

      // expect
      expect(notificationModelMock.paginate).toHaveBeenCalledTimes(1);
      expect(notificationModelMock.paginate).toHaveBeenCalledWith(
        {},
        option.route,
        {
          page: 1,
          limit: 2,
          sort: 'createdAt',
          defaultLimit: 10,
        },
      );
    });

    it('should call notification model "paginate" with parameter "action" if "action" is given as an option', async () => {
      // setup
      const option = {
        page: 1,
        limit: 2,
        route: '/notification/information',
        action: -1,
        defaultLimit: 10,
      };

      notificationModelMock.paginate.mockResolvedValueOnce({
        items: [
          {
            message: 'toto est dans la place',
          },
          {
            message: 'trotro aussi',
          },
        ],
        total: 2,
      });

      // action
      await notificationService.getNotifications(option);

      // expect
      expect(notificationModelMock.paginate).toHaveBeenCalledTimes(1);
      expect(notificationModelMock.paginate).toHaveBeenCalledWith(
        {},
        option.route,
        {
          page: 1,
          limit: 2,
          action: -1,
          defaultLimit: 10,
        },
      );
    });
  });

  describe('createNotifications', () => {
    it('should call notification repository: Save method', async () => {
      // Given
      const newNotificationMock: NotificationInputDTO = {
        message: 'New notification',
        isActive: true,
        startDate: new Date('2020-08-24'),
        stopDate: new Date('2020-08-30'),
        startHour: '00:00:00',
        stopHour: '23:59:00',
        createdAt,
      };

      const expected: NotificationDTO = {
        message: 'New notification',
        isActive: true,
        startDate: new Date('2020-08-24T22:00:00Z'),
        stopDate: new Date('2020-08-30T21:59:00Z'),
        createdAt,
      };

      notificationRepository.save.mockReturnValueOnce(newNotificationMock);

      // When
      await notificationService.createNotification(newNotificationMock);

      // Then
      expect(notificationRepository.save).toHaveBeenCalledTimes(1);
      expect(notificationRepository.save).toHaveBeenCalledWith(expected);
    });
  });

  describe('updateNotifications', () => {
    it('should call notification repository: Save method', async () => {
      // Given
      const expectedNotificationMock: Notification = {
        id: new ObjectID(objectId),
        message: 'New notification',
        startDate: new Date('2020-08-24T22:00:00Z'),
        stopDate: new Date('2020-08-30T21:59:00Z'),
        createdAt,
        updatedAt,
        isActive: true,
      };

      const notificationFromDbMock: Notification = {
        id: new ObjectID(objectId),
        message: 'New notification',
        startDate: new Date('2020-08-24T00:00:00Z'),
        stopDate: new Date('2020-08-30T23:59:00Z'),
        createdAt,
        updatedAt,
        isActive: true,
      };

      const notificationToUpdateMock: NotificationInputDTO = {
        message: 'New notification',
        startDate: new Date('2020-08-24'),
        stopDate: new Date('2020-08-30'),
        startHour: '00:00',
        stopHour: '23:59',
        updatedAt,
        createdAt,
        isActive: true,
      };

      notificationRepository.findOne.mockReturnValueOnce(
        notificationFromDbMock,
      );

      notificationRepository.save.mockReturnValueOnce(expectedNotificationMock);

      // When
      await notificationService.updateNotification(
        objectId,
        notificationToUpdateMock,
      );

      // Then
      expect(notificationRepository.findOne).toHaveBeenCalledTimes(1);
      expect(notificationRepository.save).toHaveBeenCalledTimes(1);
      expect(notificationRepository.save).toHaveBeenCalledWith(
        expectedNotificationMock,
      );
    });
  });

  describe('setDataForUpdate', () => {
    it('should set all field before calling db for update', async () => {
      // Given
      const expectedNotificationMock: Notification = {
        id: new ObjectID(objectId),
        message: 'New notification',
        startDate: new Date('2020-08-24T22:00:00.000Z'),
        stopDate: new Date('2020-08-30T21:59:00.000Z'),
        createdAt,
        updatedAt,
        isActive: true,
      };

      const notificationFromDbMock: Notification = {
        id: new ObjectID(objectId),
        message: 'New notification',
        startDate: new Date('2020-07-24'),
        stopDate: new Date('2020-07-30'),
        createdAt,
        updatedAt,
        isActive: true,
      };

      const notificationToUpdateMock: NotificationInputDTO = {
        message: 'New notification',
        startDate: new Date('2020-08-24'),
        stopDate: new Date('2020-08-30'),
        startHour: '00:00',
        stopHour: '23:59',
        updatedAt,
        createdAt,
        isActive: true,
      };

      // When
      const result: NotificationDTO = await notificationService[
        // tslint:disable-next-line: no-string-literal
        'setDataForUpdate'
      ](notificationFromDbMock, notificationToUpdateMock);
      // Then
      expect(result).toEqual(expectedNotificationMock);
    });
  });

  describe('transformHourFormDataToDate', () => {
    it('should add starHour to startDate field and return Date type', async () => {
      // When
      const startHour: string = '00:00';
      const startDate: Date = new Date('2020-08-24');
      const startHourExpected: Date = new Date('2020-08-24T22:00:00Z');

      // Given
      const result: Date = await notificationService[
        // tslint:disable-next-line no-string-literal
        'transformHourFormDataToDate'
      ](startDate, startHour);

      // Then
      // tslint:disable-next-line no-string-literal
      expect(notificationService['transformHourFormDataToDate']).toBeDefined();
      expect(result).toEqual(startHourExpected);
    });

    it('should add hours to stopDate field and return Date type', async () => {
      // When
      const stopHour: string = '23:59';
      const stopDate: Date = new Date('2020-07-30');
      const stopHourExpected: Date = new Date('2020-07-30T21:59:00Z');

      // Given
      const result: Date = await notificationService[
        // tslint:disable-next-line no-string-literal
        'transformHourFormDataToDate'
      ](stopDate, stopHour);

      // Then
      expect(result).toEqual(stopHourExpected);
    });
  });

  describe('createNewNotification', () => {
    it('should set all data before calling db for creation', async () => {
      // Given
      const newNotificationMock: NotificationInputDTO = {
        message: 'New notification',
        startDate: new Date('2020-08-24'),
        stopDate: new Date('2020-08-30'),
        startHour: '00:00:00',
        stopHour: '23:59:00',
        createdAt,
        isActive: true,
      };

      const expectedNotificationMock: NotificationDTO = {
        message: 'New notification',
        startDate: new Date('2020-08-24T22:00:00.000Z'),
        stopDate: new Date('2020-08-30T21:59:00.000Z'),
        createdAt,
        isActive: true,
      };

      // When
      // tslint:disable-next-line no-string-literal
      const result = await notificationService['createNewNotification'](
        newNotificationMock,
      );

      // Then
      expect(result).toEqual(expectedNotificationMock);
    });
  });
});
