import { Test, TestingModule } from '@nestjs/testing';
import { getModelToken } from '@nestjs/mongoose';

import { NotificationService } from './notification.service';

describe('NotificationService', () => {
  let module: TestingModule;
  let notificationService: NotificationService;

  const notificationModelMock = {
    paginate: jest.fn(),
  };

  beforeEach(async () => {
    module = await Test.createTestingModule({
      providers: [
        NotificationService,
        {
          provide: getModelToken('Notification'),
          useValue: notificationModelMock,
        },
      ],
    }).compile();

    notificationService = await module.get<NotificationService>(
      NotificationService,
    );
    jest.resetAllMocks();
  });

  afterAll(async () => {
    module.close();
  });

  it('should be defined', () => {
    expect(notificationService).toBeDefined();
  });

  describe('getNotifications', () => {
    it('should return a promise', async () => {
      // action
      const result = notificationService.getNotifications({});

      // expect
      expect(result).toBeInstanceOf(Promise);
    });

    it('should return the promise returned by notification model "paginate" call', async () => {
      // setup
      const aPromise = new Promise(res => {
        res();
      });
      notificationModelMock.paginate.mockReturnValueOnce(aPromise);

      // action
      const result = notificationService.getNotifications({});

      // expect
      expect(result).toStrictEqual(aPromise);
    });

    it('should call notification model "paginate"', async () => {
      // setup
      const option = {
        page: 1,
        limit: 2,
        route: '/notification/information',
        defaultLimit: 10,
      };

      notificationModelMock.paginate.mockResolvedValueOnce({
        items: [
          {
            message: 'toto est dans la place',
          },
          {
            message: 'trotro aussi',
          },
        ],
        total: 2,
      });

      // action
      await notificationService.getNotifications(option);

      // expect
      expect(notificationModelMock.paginate).toHaveBeenCalledTimes(1);
      expect(notificationModelMock.paginate).toHaveBeenCalledWith(
        {},
        option.route,
        {
          page: 1,
          limit: 2,
          defaultLimit: 10,
        },
      );
    });

    it('should call notification model "paginate" with parameter "sort" if "sort" is given as an option', async () => {
      // setup
      const option = {
        page: 1,
        limit: 2,
        route: '/notification/information',
        sort: 'createdAt',
        defaultLimit: 10,
      };

      notificationModelMock.paginate.mockResolvedValueOnce({
        items: [
          {
            message: 'toto est dans la place',
          },
          {
            message: 'trotro aussi',
          },
        ],
        total: 2,
      });

      // action
      await notificationService.getNotifications(option);

      // expect
      expect(notificationModelMock.paginate).toHaveBeenCalledTimes(1);
      expect(notificationModelMock.paginate).toHaveBeenCalledWith(
        {},
        option.route,
        {
          page: 1,
          limit: 2,
          sort: 'createdAt',
          defaultLimit: 10,
        },
      );
    });

    it('should call notification model "paginate" with parameter "action" if "action" is given as an option', async () => {
      // setup
      const option = {
        page: 1,
        limit: 2,
        route: '/notification/information',
        action: -1,
        defaultLimit: 10,
      };

      notificationModelMock.paginate.mockResolvedValueOnce({
        items: [
          {
            message: 'toto est dans la place',
          },
          {
            message: 'trotro aussi',
          },
        ],
        total: 2,
      });

      // action
      await notificationService.getNotifications(option);

      // expect
      expect(notificationModelMock.paginate).toHaveBeenCalledTimes(1);
      expect(notificationModelMock.paginate).toHaveBeenCalledWith(
        {},
        option.route,
        {
          page: 1,
          limit: 2,
          action: -1,
          defaultLimit: 10,
        },
      );
    });
  });
});
