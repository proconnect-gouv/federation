import {
  Controller,
  Get,
  Render,
  Req,
  Query,
  UsePipes,
  ValidationPipe,
  Param,
  Res,
  Post,
  UseInterceptors,
  Body,
  Patch,
} from '@nestjs/common';
import * as moment from 'moment-timezone';
import { UserRole } from '@fc/shared/user/roles.enum';
import { Roles } from '@fc/shared/authentication/decorator';
import { NotificationService } from './notification.service';
import { IPaginatedNotification } from './interface/index';
import { NotificationQueryDTO } from './dto/notification-query.dto';
import { FormErrorsInterceptor } from '@fc/shared/form/interceptor/form-errors.interceptor';
import { NotificationDTO, NotificationInputDTO } from './dto';
import { Notification } from './notification.mongodb.entity';
import { AlgoName, AlgoValue } from '../enum';

@Controller('notification')
export class NotificationController {
  constructor(private readonly notificationService: NotificationService) {}

  @Get('information')
  @Roles(UserRole.OPERATOR)
  @UsePipes(new ValidationPipe({ transform: true }))
  @Render('notification/information')
  async informations(@Req() req, @Query() query: NotificationQueryDTO) {
    const csrfToken = req.csrfToken();
    const { page, limit } = query;

    let notifications: IPaginatedNotification;
    try {
      notifications = await this.notificationService.getNotifications({
        page,
        limit,
        route: '/notification/information',
        sort: 'createdAt',
        action: -1,
        defaultLimit: 10,
      });

      return {
        csrfToken,
        total: notifications.total,
        notifications: notifications.items,
      };
    } catch (err) {
      req.flash(
        'globalError',
        "Les messages n'ont pas pu être affichés à cause d'une erreur technique",
      );
    }
  }

  @Get('create')
  @Roles(UserRole.OPERATOR)
  @Render('notification/create')
  async showCreationForm(@Req() req) {
    const csrfToken = req.csrfToken();

    return { csrfToken, AlgoName, AlgoValue };
  }

  @Post('create')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor(`/notification/create`))
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async createNotification(
    @Body() createNotification: NotificationInputDTO,
    @Req() req,
    @Res() res,
  ) {
    try {
      await this.notificationService.createNotification(
        createNotification,
        req.user.username,
      );
    } catch (error) {
      req.flash('globalError', 'Impossible de créer la notification');
      req.flash('values', createNotification);
      return res.redirect(`${res.locals.APP_ROOT}/notification/create`);
    }
    req.flash('success', `La notification a été créé avec succès !`);
    return res.redirect(`${res.locals.APP_ROOT}/notification/information`);
  }

  @Get(':id')
  @Roles(UserRole.OPERATOR)
  @Render('notification/update')
  async findNotification(@Param('id') id: string, @Req() req) {
    const csrfToken = req.csrfToken();

    const notification: Notification = await this.notificationService.getNotification(
      id,
    );
    return {
      csrfToken,
      notification,
      moment,
      AlgoName,
      AlgoValue,
    };
  }

  @Patch(':id')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor(`/notification/:id`))
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async updateNotification(
    @Param('id') id: string,
    @Body() notification: NotificationInputDTO,
    @Req() req,
    @Res() res,
  ) {
    try {
      await this.notificationService.updateNotification(
        id,
        notification,
        req.user.username,
      );
    } catch (error) {
      req.flash('globalError', 'Impossible de modifier la notification');
      return res.redirect(`${res.locals.APP_ROOT}/notification/${id}`);
    }

    req.flash('success', `La notification a été modifiée avec succès !`);
    return res.redirect(`${res.locals.APP_ROOT}/notification/${id}`);
  }
}
