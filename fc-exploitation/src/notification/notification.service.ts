import * as moment from 'moment-timezone';
import { Model } from 'mongoose';
import { Repository } from 'typeorm';
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { InjectRepository } from '@nestjs/typeorm';
import { IOptions, PaginableModel } from '@fc/shared/pagination';
import { INotification, IPaginatedNotification } from './interface';
import { NotificationDTO, NotificationInputDTO } from './dto';
import { Notification } from './notification.mongodb.entity';

@Injectable()
export class NotificationService {
  constructor(
    @InjectRepository(Notification, 'fc-mongo')
    private readonly notificationRepository: Repository<Notification>,
    @InjectModel('Notification')
    private readonly notificationModel: PaginableModel<INotification>,
  ) {}

  async getNotifications(option): Promise<IPaginatedNotification> {
    const parameters: IOptions = {
      page: option.page,
      limit: option.limit,
      defaultLimit: option.defaultLimit,
    };

    if (option.sort) {
      parameters.sort = option.sort;
    }

    if (option.action) {
      parameters.action = option.action;
    }

    return this.notificationModel.paginate({}, option.route, parameters);
  }

  async createNotification(
    notificationFormData: NotificationInputDTO,
  ): Promise<Notification> {
    const newNotification = await this.createNewNotification(
      notificationFormData,
    );

    return this.notificationRepository.save(newNotification);
  }

  async getNotification(id: string): Promise<Notification> {
    return await this.notificationRepository.findOne(id);
  }

  async updateNotification(
    id: string,
    notification: NotificationInputDTO,
  ): Promise<Notification> {
    const notificationToUpdate = await this.notificationRepository.findOne(id);
    const udatedNotification = await this.setDataForUpdate(
      notificationToUpdate,
      notification,
    );
    return this.notificationRepository.save(udatedNotification);
  }

  private async createNewNotification(formData): Promise<NotificationDTO> {
    const newNotification: NotificationDTO = {
      message: formData.message,
      isActive: formData.isActive,
      startDate: null,
      stopDate: null,
      createdAt: new Date(),
    };

    newNotification.startDate = await this.transformHourFormDataToDate(
      formData.startDate,
      formData.startHour,
    );
    newNotification.stopDate = await this.transformHourFormDataToDate(
      formData.stopDate,
      formData.stopHour,
    );
    return newNotification;
  }

  private async setDataForUpdate(
    notificationToUpdate: Notification,
    notification: NotificationInputDTO,
  ): Promise<NotificationDTO> {
    const notificationUpdated: Notification = {
      ...notificationToUpdate,
      message: notification.message,
      startDate: await this.transformHourFormDataToDate(
        notification.startDate,
        notification.startHour,
      ),
      stopDate: await this.transformHourFormDataToDate(
        notification.stopDate,
        notification.stopHour,
      ),
      updatedAt: new Date(),
      isActive: notification.isActive,
    };

    return notificationUpdated;
  }

  private async transformHourFormDataToDate(
    date: Date,
    hour: string,
  ): Promise<Date> {
    return new Date(
      `${moment(date).format('YYYY-MM-DD')}T${moment
        .tz(hour, 'HH:mm', 'Europe/Paris')
        .tz('UTC')
        .format('HH:mm')}Z`,
    );
  }
}
