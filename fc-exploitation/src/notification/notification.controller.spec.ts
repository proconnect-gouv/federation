import { Test, TestingModule } from '@nestjs/testing';
import * as moment from 'moment-timezone';
import * as MockDate from 'mockdate';
import { NotificationController } from './notification.controller';
import { NotificationService } from './notification.service';
import { NotificationInputDTO } from './dto';
import { AlgoName, AlgoValue } from '../enum';

describe('Notification Controller', () => {
  let notificationController: NotificationController;

  const notificationService = {
    getNotifications: jest.fn(),
    getNotification: jest.fn(),
    createNotification: jest.fn(),
    updateNotification: jest.fn(),
  };

  const req = {
    flash: jest.fn(),
    user: {
      username: 'fred durand',
    },
    csrfToken: function csrfToken() {
      return 'myGreatCsrfToken';
    },
  };

  const res = {
    redirect: jest.fn(),
    locals: {
      APP_ROOT: '/jedi/knight',
    },
  };

  const items = [
    {
      message: 'mon premier message devant apparaître en dernier ^^',
      startDate: new Date('2020-07-03'),
      stopDate: new Date('2020-07-05'),
      createdAt: new Date('2020-07-02'),
      updatedAt: new Date('2020-07-02'),
      updatedBy: req.user.username,
      isActive: false,
    },
    {
      message: 'mon deuxième message',
      startDate: new Date('2020-06-28'),
      stopDate: new Date('2020-06-30'),
      createdAt: new Date('2020-06-27'),
      updatedAt: new Date('2020-06-27'),
      updatedBy: req.user.username,
      isActive: false,
    },
    {
      message: 'mon troisième message',
      startDate: new Date('2020-06-20'),
      stopDate: new Date('2020-06-22'),
      createdAt: new Date('2020-06-19'),
      updatedAt: new Date('2020-06-19'),
      updatedBy: req.user.username,
      isActive: false,
    },
    {
      message: 'mon quatrième message',
      startDate: new Date('2020-06-13'),
      stopDate: new Date('2020-06-15'),
      createdAt: new Date('2020-06-12'),
      updatedAt: new Date('2020-06-12'),
      isActive: false,
    },
    {
      message: 'mon cinquième message',
      startDate: new Date('2020-06-05'),
      stopDate: new Date('2020-06-07'),
      createdAt: new Date('2020-06-04'),
      updatedAt: new Date('2020-06-04'),
      updatedBy: req.user.username,
      isActive: false,
    },
    {
      message: 'mon sixième message',
      startDate: new Date('2020-05-28'),
      stopDate: new Date('2020-05-30'),
      createdAt: new Date('2020-05-27'),
      updatedAt: new Date('2020-05-27'),
      isActive: false,
    },
    {
      message: 'mon septième message',
      startDate: new Date('2020-05-18'),
      stopDate: new Date('2020-05-20'),
      createdAt: new Date('2020-05-17'),
      updatedAt: new Date('2020-05-17'),
      updatedBy: req.user.username,
      isActive: false,
    },
    {
      message: 'mon huitième message',
      startDate: new Date('2020-05-10'),
      stopDate: new Date('2020-05-12'),
      createdAt: new Date('2020-05-09'),
      updatedAt: new Date('2020-05-09'),
      isActive: false,
    },
    {
      message: 'mon neuvième message',
      startDate: new Date('2020-05-03'),
      stopDate: new Date('2020-05-05'),
      createdAt: new Date('2020-05-02'),
      updatedAt: new Date('2020-05-02'),
      updatedBy: req.user.username,
      isActive: false,
    },
    {
      message: 'mon dixième message',
      startDate: new Date('2020-04-28'),
      stopDate: new Date('2020-04-30'),
      createdAt: new Date('2020-04-27'),
      updatedAt: new Date('2020-04-27'),
      isActive: false,
    },
    {
      message: 'mon onzième message',
      startDate: new Date('2020-04-20'),
      stopDate: new Date('2020-04-22'),
      createdAt: new Date('2020-04-19'),
      updatedAt: new Date('2020-04-19'),
      updatedBy: req.user.username,
      isActive: false,
    },
    {
      message: 'mon douzième message',
      startDate: new Date('2020-04-10'),
      stopDate: new Date('2020-04-12'),
      createdAt: new Date('2020-04-09'),
      updatedAt: new Date('2020-04-09'),
      updatedBy: req.user.username,
      isActive: false,
    },
  ];

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [NotificationController],
      providers: [NotificationService],
    })
      .overrideProvider(NotificationService)
      .useValue(notificationService)
      .compile();

    notificationController = await module.get<NotificationController>(
      NotificationController,
    );

    jest.resetAllMocks();
  });

  it('should be defined', () => {
    expect(notificationController).toBeDefined();
  });

  describe('GET information', () => {
    it('should render notifications', async () => {
      // setup
      const reqMock = {
        ...req,
        query: {
          page: 1,
          limit: 10,
        },
      };

      notificationService.getNotifications.mockResolvedValueOnce({
        items,
        total: 12,
      });

      // action
      const result = await notificationController.informations(
        reqMock,
        reqMock.query,
      );

      // assertion
      expect(result).toEqual({
        csrfToken: 'myGreatCsrfToken',
        total: 12,
        notifications: items,
      });
      expect(reqMock.flash).toBeCalledTimes(0);
    });

    it('should flash an error', async () => {
      // setup
      const reqMock = {
        ...req,
        query: {
          page: 1,
          limit: 10,
        },
      };

      notificationService.getNotifications.mockRejectedValueOnce(
        new Error('Try again buddy'),
      );

      // action
      await notificationController.informations(reqMock, reqMock.query);

      // assertion
      expect(reqMock.flash).toBeCalledTimes(1);
      expect(reqMock.flash).toBeCalledWith(
        'globalError',
        "Les messages n'ont pas pu être affichés à cause d'une erreur technique",
      );
    });
  });

  describe('showCreationForm', () => {
    it('should exist', async () => {
      expect(notificationController.showCreationForm).toBeDefined();
    });

    it('should send to the view the csrfToken', async () => {
      // When
      const result = await notificationController.showCreationForm(req);

      // Then
      expect(result).toEqual({
        csrfToken: 'myGreatCsrfToken',
        AlgoName,
        AlgoValue,
      });
    });
  });

  describe('createNotification', () => {
    const newNotificationMock: NotificationInputDTO = {
      message: 'New notification',
      isActive: true,
      startDate: new Date('2020-08-24'),
      stopDate: new Date('2020-08-30'),
      startHour: '00:00:00',
      stopHour: '23:59:00',
      createdAt: new Date('2020-08-22'),
    };

    it('should call notification service createNotification method ', async () => {
      // When
      await notificationController.createNotification(
        newNotificationMock,
        req,
        res,
      );

      // Then
      expect(notificationService.createNotification).toHaveBeenCalledTimes(1);
    });

    it('should flash success message if the createNotification call does not throw', async () => {
      // When
      await notificationController.createNotification(
        newNotificationMock,
        req,
        res,
      );

      // Then
      expect(req.flash).toHaveBeenCalledTimes(1);
      expect(req.flash).toHaveBeenCalledWith(
        'success',
        'La notification a été créé avec succès !',
      );
      expect(res.redirect).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/notification/information`,
      );
    });

    it('should redirect the user to the notification list page if the createNotification call does not throw', async () => {
      // When
      await notificationController.createNotification(
        newNotificationMock,
        req,
        res,
      );

      // Then
      expect(res.redirect).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/notification/information`,
      );
    });

    it('should flash error message if the createNotification call does throw', async () => {
      // Given
      notificationService.createNotification = jest.fn(() => {
        throw Error;
      });

      // When
      await notificationController.createNotification(
        newNotificationMock,
        req,
        res,
      );

      // Then
      expect(req.flash).toHaveBeenCalledTimes(2);
      expect(req.flash).toHaveBeenNthCalledWith(
        1,
        'globalError',
        'Impossible de créer la notification',
      );
      expect(req.flash).toHaveBeenNthCalledWith(
        2,
        'values',
        newNotificationMock,
      );
    });

    it('should redirect the user to the notification create page if the createNotification call does throw', async () => {
      // Given
      notificationService.createNotification = jest.fn(() => {
        throw Error;
      });

      // When
      await notificationController.createNotification(
        newNotificationMock,
        req,
        res,
      );

      // Then
      expect(res.redirect).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/notification/create`,
      );
    });
  });

  describe('findNotification', () => {
    const idParam = '05e4fadf-fda6-4ad8-ae75-b7f315843827';

    const notificationFromDbMock: NotificationInputDTO = {
      message: 'New notification',
      isActive: true,
      startDate: new Date('2020-08-24'),
      stopDate: new Date('2020-08-30'),
      startHour: '00:00:00',
      stopHour: '23:59:00',
      createdAt: new Date('2020-08-24'),
    };

    it('should call notification service getNotification', async () => {
      // When
      const result = await notificationController.findNotification(
        idParam,
        req,
      );

      // Then
      expect(notificationService.getNotification).toHaveBeenCalledTimes(1);
    });

    it('should send to the view all the needed data if getNotification does not throw ', async () => {
      // Given
      notificationService.getNotification.mockResolvedValueOnce(
        notificationFromDbMock,
      );
      // When
      const result = await notificationController.findNotification(
        idParam,
        req,
      );

      // Then
      expect(result).toEqual({
        csrfToken: 'myGreatCsrfToken',
        notification: notificationFromDbMock,
        moment,
        AlgoName,
        AlgoValue,
      });
    });
  });

  describe('updateNotification', () => {
    const idParam = '05e4fadf-fda6-4ad8-ae75-b7f315843827';

    const newNotificationMock: NotificationInputDTO = {
      message: 'New notification',
      isActive: true,
      startDate: new Date('2020-08-24'),
      stopDate: new Date('2020-08-30'),
      startHour: '00:00:00',
      stopHour: '23:59:00',
      createdAt: new Date('2020-08-24'),
    };

    it('should call updateNotification from notificationService', async () => {
      // When
      await notificationController.updateNotification(
        idParam,
        newNotificationMock,
        req,
        res,
      );

      // Then
      expect(notificationService.updateNotification).toHaveBeenCalledTimes(1);
    });

    it('should flash success message if the updateNotification call does not throw', async () => {
      // When
      await notificationController.updateNotification(
        idParam,
        newNotificationMock,
        req,
        res,
      );

      // Then
      expect(req.flash).toHaveBeenCalledTimes(1);
      expect(req.flash).toHaveBeenCalledWith(
        'success',
        'La notification a été modifiée avec succès !',
      );
    });

    it('should redirect the user to the notification details page if the updateNotification call does not throw', async () => {
      // When
      await notificationController.updateNotification(
        idParam,
        newNotificationMock,
        req,
        res,
      );

      // Then
      expect(res.redirect).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/notification/${idParam}`,
      );
    });

    it('should flash error message if the updateNotification call does throw', async () => {
      notificationService.updateNotification = jest.fn(() => {
        throw Error;
      });

      // When
      await notificationController.updateNotification(
        idParam,
        newNotificationMock,
        req,
        res,
      );

      // Then
      expect(notificationService.updateNotification).toHaveBeenCalledTimes(1);
      expect(req.flash).toHaveBeenCalledTimes(1);
      expect(req.flash).toHaveBeenCalledWith(
        'globalError',
        'Impossible de modifier la notification',
      );
      expect(res.redirect).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/notification/${idParam}`,
      );
    });

    it('should redirect the user to the notification details page if the updateNotification call does throw', async () => {
      notificationService.updateNotification = jest.fn(() => {
        throw Error;
      });

      // When
      await notificationController.updateNotification(
        idParam,
        newNotificationMock,
        req,
        res,
      );

      // Then
      expect(res.redirect).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/notification/${idParam}`,
      );
    });
  });
});
