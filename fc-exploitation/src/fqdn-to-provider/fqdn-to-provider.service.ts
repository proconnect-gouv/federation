import { Repository } from 'mongodb';

import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';

import { FqdnToProvider } from './fqdn-to-provider.mongodb.entity';
import { IIdentityProvider, IIdentityProviderDTO } from '../identity-provider';
import { IFqdnToProvider } from './interface/fqdn.interface';

@Injectable()
export class FqdnToProviderService {
  constructor(
    @InjectRepository(FqdnToProvider, 'fc-mongo')
    private readonly fqdnToProviderRepository: Repository<FqdnToProvider>,
  ) {}

  private async findFqdnsForProviders(
    identityProvidersUuids: string[],
  ): Promise<FqdnToProvider[]> {
    const fqdnToProviders = await this.fqdnToProviderRepository.find({
      where: {
        identityProvider: { $in: identityProvidersUuids },
      },
    });

    if (!fqdnToProviders) {
      return [];
    }

    return fqdnToProviders;
  }

  private async findFqdnsForOneProvider(
    identityProviderUid: string,
  ): Promise<FqdnToProvider[]> {
    const fqdnToProvider = await this.fqdnToProviderRepository.find({
      where: {
        identityProvider: identityProviderUid,
      },
    });

    if (!fqdnToProvider) {
      return [];
    }

    return fqdnToProvider;
  }

  async getProviderWithFqdns(
    identityProvider: IIdentityProviderDTO,
  ): Promise<IIdentityProviderDTO> {
    const fqdnToProviders = await this.findFqdnsForOneProvider(
      identityProvider.uid,
    );

    const idpWithFqdns = { ...identityProvider, fqdns: [] };
    fqdnToProviders.forEach(({ identityProvider: idpUidFromFqdn, fqdn }) => {
      idpWithFqdns.fqdns.push(fqdn);
    });

    return idpWithFqdns;
  }

  async getProvidersWithFqdns(
    identityProviders: IIdentityProvider[],
  ): Promise<IIdentityProviderDTO[]> {
    const identityProvidersUids = identityProviders.map(
      (idp: IIdentityProvider) => idp.uid,
    );

    const fqdnToProviders = await this.findFqdnsForProviders(
      identityProvidersUids,
    );

    return this.getIdentityProvidersDTO(identityProviders, fqdnToProviders);
  }

  async saveFqdnsProvider(
    identityProviderUid: string,
    fqdns: string[],
  ): Promise<void> {
    fqdns.filter(Boolean).forEach(async fqdn => {
      await this.fqdnToProviderRepository.save({
        identityProvider: identityProviderUid,
        fqdn,
      });
    });
  }

  async updateFqdnsProvider(
    identityProviderUid: string,
    fqdns: string[],
  ): Promise<void> {
    // delete all previous relations for this identityProvider
    await this.deleteFqdnsProvider(identityProviderUid);
    if (fqdns.length === 0) {
      return;
    }

    // create new relations
    await this.saveFqdnsProvider(identityProviderUid, fqdns);
  }

  async deleteFqdnsProvider(identityProviderUid: string): Promise<void> {
    const existingFqdns = await this.fqdnToProviderRepository.find({
      identityProvider: identityProviderUid,
    });
    if (existingFqdns.length > 0) {
      await this.fqdnToProviderRepository.delete(existingFqdns);
    }
  }

  private getIdentityProvidersDTO(
    identityPoviders: IIdentityProvider[],
    fqdnToProviders: IFqdnToProvider[],
  ): IIdentityProviderDTO[] {
    const fqdnToProvidersHashMap: Record<string, string[]> = {};

    fqdnToProviders.forEach(({ identityProvider: uid, fqdn }) => {
      if (!fqdnToProvidersHashMap[uid]) {
        return (fqdnToProvidersHashMap[uid] = [fqdn]);
      } else {
        return fqdnToProvidersHashMap[uid].push(fqdn);
      }
    });

    return identityPoviders.map(identityProvider => {
      const idpWithFqdns = {
        ...identityProvider,
        fqdns: fqdnToProvidersHashMap[identityProvider.uid] || [],
      };

      return idpWithFqdns;
    });
  }
}
