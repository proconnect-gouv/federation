import { Test, TestingModule } from '@nestjs/testing';
import { FqdnToProviderService } from './fqdn-to-provider.service';
import { TypeOrmModule, getRepositoryToken } from '@nestjs/typeorm';
import { FqdnToProvider } from './fqdn-to-provider.mongodb.entity';
import { Repository } from 'typeorm';
import { InstanceService } from '@fc/shared/utils';
import { IFqdnToProvider } from './interface/fqdn.interface';
import { IIdentityProvider } from '../identity-provider';

jest.mock('uuid');

describe('FqdnToProviderService', () => {
  let module: TestingModule;
  let fqdnToProviderService: FqdnToProviderService;

  const fqdnToProviderRepository = {
    find: jest.fn(),
    save: jest.fn(),
    delete: jest.fn(),
  };

  const instanceServiceMock = {
    isFcaLow: jest.fn(),
    isCl: jest.fn(),
    isFcpHigh: jest.fn(),
  };

  beforeEach(async () => {
    module = await Test.createTestingModule({
      imports: [TypeOrmModule.forFeature([FqdnToProvider], 'fc-mongo')],
      providers: [FqdnToProviderService, Repository, InstanceService],
    })
      .overrideProvider(InstanceService)
      .useValue(instanceServiceMock)
      .overrideProvider(getRepositoryToken(FqdnToProvider, 'fc-mongo'))
      .useValue(fqdnToProviderRepository)

      .compile();

    fqdnToProviderService = await module.get<FqdnToProviderService>(
      FqdnToProviderService,
    );

    jest.resetAllMocks();
  });

  afterAll(async () => {
    module.close();
  });

  describe('findFqdnsForOneProvider', () => {
    it('should return all fqdns for one identity provider', async () => {
      // Given
      const expectedResult = [
        {
          identityProvider: 'mock-id-1',
          fqdn: 'stendhal.fr',
        } as IFqdnToProvider,
        {
          identityProvider: 'mock-id-1',
          fqdn: 'flaubert.fr',
        } as IFqdnToProvider,
      ];
      fqdnToProviderRepository.find.mockReturnValueOnce(expectedResult);

      // When
      const result = await fqdnToProviderService['findFqdnsForOneProvider'](
        'mock-id-1',
      );

      // Then
      expect(result).toStrictEqual(expectedResult);
    });

    it('should return an empty array if no fqdn has been found', async () => {
      // Given
      const mockResponse = [];
      fqdnToProviderRepository.find.mockReturnValueOnce(mockResponse);

      // Then
      const result = await fqdnToProviderService['findFqdnsForOneProvider'](
        'mock-id-1',
      );
      expect(result).toStrictEqual([]);
    });

    describe('findFqdnsForProviders', () => {
      it('should return all fqdns for a list of identity providers', async () => {
        // Given
        const expectedResult = [
          {
            identityProvider: 'mock-id-1',
            fqdn: 'stendhal.fr',
          } as IFqdnToProvider,
          {
            identityProvider: 'mock-id-1',
            fqdn: 'flaubert.fr',
          } as IFqdnToProvider,
          {
            identityProvider: 'mock-id-2',
            fqdn: 'duras.fr',
          } as IFqdnToProvider,
        ];
        fqdnToProviderRepository.find.mockReturnValueOnce(expectedResult);

        // When
        const result = await fqdnToProviderService['findFqdnsForProviders']([
          'mock-id-1',
          'mock-id-2',
        ]);

        // Then
        expect(result).toStrictEqual(expectedResult);
      });
    });

    describe('getProviderWithFqdns', () => {
      it('should return an identity provider with its fqdns', async () => {
        // Given
        const identityProvider = {
          uid: 'mock-id-1',
          active: true,
          display: true,
          name: 'mock-identity-provider-name-1',
          title: 'mock-identity-provider-title-1',
        } as IIdentityProvider;

        const fqdns = [
          {
            identityProvider: 'mock-id-1',
            fqdn: 'stendhal.fr',
          } as IFqdnToProvider,
          {
            identityProvider: 'mock-id-1',
            fqdn: 'flaubert.fr',
          } as IFqdnToProvider,
        ];

        const expectedResult = {
          ...identityProvider,
          fqdns: ['stendhal.fr', 'flaubert.fr'],
        };
        fqdnToProviderRepository.find.mockReturnValueOnce(fqdns);

        // When
        const result = await fqdnToProviderService['getProviderWithFqdns'](
          identityProvider,
        );

        // Then
        expect(result).toStrictEqual(expectedResult);
      });

      it('should return an identity provider without fqdns if there is no associations', async () => {
        // Given
        const identityProvider = {
          uid: 'mock-id-1',
          active: true,
          display: true,
          name: 'mock-identity-provider-name-1',
          title: 'mock-identity-provider-title-1',
        } as IIdentityProvider;

        const expectedResult = {
          uid: 'mock-id-1',
          active: true,
          display: true,
          name: 'mock-identity-provider-name-1',
          title: 'mock-identity-provider-title-1',
          fqdns: [],
        };

        // When
        const result = await fqdnToProviderService['getProviderWithFqdns'](
          identityProvider,
        );

        // Then
        expect(result).toStrictEqual(expectedResult);
      });
    });

    describe('getProvidersWithFqdns', () => {
      it('should returns idps with fqdns', async () => {
        // Given
        const identityProviders = [
          {
            uid: 'mock-id-1',
            active: true,
            display: true,
            name: 'mock-identity-provider-name-1',
            title: 'mock-identity-provider-title-1',
          } as IIdentityProvider,
          {
            uid: 'mock-id-2',
            active: false,
            display: false,
            name: 'mock-identity-provider-name-2',
            title: 'mock-identity-provider-title-2',
          } as IIdentityProvider,
        ];

        const fqdns = [
          {
            identityProvider: 'mock-id-1',
            fqdn: 'stendhal.fr',
          } as IFqdnToProvider,
          {
            identityProvider: 'mock-id-1',
            fqdn: 'flaubert.fr',
          } as IFqdnToProvider,
          {
            identityProvider: 'mock-id-2',
            fqdn: 'duras.fr',
          } as IFqdnToProvider,
        ];

        const expectedResult = [
          {
            uid: 'mock-id-1',
            active: true,
            display: true,
            name: 'mock-identity-provider-name-1',
            title: 'mock-identity-provider-title-1',
            fqdns: ['stendhal.fr', 'flaubert.fr'],
          },
          {
            uid: 'mock-id-2',
            active: false,
            display: false,
            name: 'mock-identity-provider-name-2',
            title: 'mock-identity-provider-title-2',
            fqdns: ['duras.fr'],
          },
        ];

        fqdnToProviderRepository.find.mockReturnValueOnce(fqdns);

        // When
        const result = await fqdnToProviderService['getProvidersWithFqdns'](
          identityProviders,
        );

        // Then
        expect(result).toStrictEqual(expectedResult);
      });
    });

    describe('saveFqdnsProvider', () => {
      it('should save fqdns for an identity provider', async () => {
        // Given
        const identityProviderUid = 'mock-id-1';
        const fqdns = ['stendhal.fr', 'flaubert.fr'];

        // When
        await fqdnToProviderService['saveFqdnsProvider'](
          identityProviderUid,
          fqdns,
        );

        // Then
        expect(fqdnToProviderRepository.save).toHaveBeenCalledTimes(2);
        expect(fqdnToProviderRepository.save).toHaveBeenNthCalledWith(1, {
          identityProvider: identityProviderUid,
          fqdn: fqdns[0],
        });
        expect(fqdnToProviderRepository.save).toHaveBeenNthCalledWith(2, {
          identityProvider: identityProviderUid,
          fqdn: fqdns[1],
        });
      });

      it('should not save an empty fqdn', async () => {
        // Given
        const identityProviderUid = 'mock-id-1';
        const fqdns = ['stendhal.fr', ''];

        // When
        fqdnToProviderRepository.save.mockReturnValueOnce(null);

        await fqdnToProviderService['saveFqdnsProvider'](
          identityProviderUid,
          fqdns,
        );

        // Then
        expect(fqdnToProviderRepository.save).toHaveBeenCalledTimes(1);
        expect(fqdnToProviderRepository.save).toHaveBeenNthCalledWith(1, {
          identityProvider: identityProviderUid,
          fqdn: fqdns[0],
        });
      });
    });
  });

  describe('deleteFqdnsProvider', () => {
    it('should delete fqdns for an identity provider', async () => {
      // Given
      const identityProviderUid = 'mock-id-1';
      const existingFqdns = [
        {
          identityProvider: 'mock-id-1',
          fqdn: 'stendhal.fr',
        } as IFqdnToProvider,
        {
          identityProvider: 'mock-id-1',
          fqdn: 'flaubert.fr',
        } as IFqdnToProvider,
      ];

      // When
      fqdnToProviderRepository.find.mockReturnValueOnce(existingFqdns);

      await fqdnToProviderService['deleteFqdnsProvider'](identityProviderUid);

      // Then
      expect(fqdnToProviderRepository.find).toHaveBeenCalledTimes(1);
      expect(fqdnToProviderRepository.find).toHaveBeenCalledWith({
        identityProvider: identityProviderUid,
      });

      expect(fqdnToProviderRepository.delete).toHaveBeenCalledTimes(1);
      expect(fqdnToProviderRepository.delete).toHaveBeenCalledWith(
        existingFqdns,
      );
    });

    it('should not delete fqdns for an identity provider if there is no fqdn', async () => {
      // Given
      const identityProviderUid = 'mock-id-1';
      const existingFqdns = [];

      // When
      fqdnToProviderRepository.find.mockReturnValueOnce(existingFqdns);

      await fqdnToProviderService['deleteFqdnsProvider'](identityProviderUid);

      // Then
      expect(fqdnToProviderRepository.find).toHaveBeenCalledTimes(1);
      expect(fqdnToProviderRepository.find).toHaveBeenCalledWith({
        identityProvider: identityProviderUid,
      });

      expect(fqdnToProviderRepository.delete).toHaveBeenCalledTimes(0);
    });
  });

  describe('updateFqdnsProvider', () => {
    it('should update fqdns for an identity provider', async () => {
      // Given
      const identityProviderUid = 'mock-id-1';
      const existingFqdns = [
        {
          identityProvider: 'mock-id-1',
          fqdn: 'stendhal.fr',
        } as IFqdnToProvider,
        {
          identityProvider: 'mock-id-1',
          fqdn: 'flaubert.fr',
        } as IFqdnToProvider,
      ];
      const newFqdns = ['duras.fr', 'balzac.fr'];

      // When
      fqdnToProviderRepository.find.mockReturnValueOnce(existingFqdns);

      await fqdnToProviderService['updateFqdnsProvider'](
        identityProviderUid,
        newFqdns,
      );

      // Then
      expect(fqdnToProviderRepository.delete).toHaveBeenCalledTimes(1);
      expect(fqdnToProviderRepository.delete).toHaveBeenCalledWith(
        existingFqdns,
      );

      expect(fqdnToProviderRepository.save).toHaveBeenCalledTimes(2);
      expect(fqdnToProviderRepository.save).toHaveBeenNthCalledWith(1, {
        identityProvider: identityProviderUid,
        fqdn: newFqdns[0],
      });
      expect(fqdnToProviderRepository.save).toHaveBeenNthCalledWith(2, {
        identityProvider: identityProviderUid,
        fqdn: newFqdns[1],
      });
    });

    it('should not delete previous fqdns for an identity provider if there is no previous fqdn', async () => {
      // Given
      const identityProviderUid = 'mock-id-1';
      const existingFqdns = [];
      const newFqdns = ['duras.fr', 'balzac.fr'];

      // When
      fqdnToProviderRepository.find.mockReturnValueOnce(existingFqdns);

      await fqdnToProviderService['updateFqdnsProvider'](
        identityProviderUid,
        newFqdns,
      );

      // Then
      expect(fqdnToProviderRepository.delete).toHaveBeenCalledTimes(0);

      expect(fqdnToProviderRepository.save).toHaveBeenCalledTimes(2);
      expect(fqdnToProviderRepository.save).toHaveBeenNthCalledWith(1, {
        identityProvider: identityProviderUid,
        fqdn: newFqdns[0],
      });
      expect(fqdnToProviderRepository.save).toHaveBeenNthCalledWith(2, {
        identityProvider: identityProviderUid,
        fqdn: newFqdns[1],
      });
    });
  });

  describe('getIdentityProvidersDTO', () => {
    it('should add fqdns to identity providers', async () => {
      // Given
      const identityProviders = [
        {
          uid: 'mock-id-1',
          active: true,
          display: true,
          name: 'mock-identity-provider-name-1',
          title: 'mock-identity-provider-title-1',
        } as IIdentityProvider,
        {
          uid: 'mock-id-2',
          active: false,
          display: false,
          name: 'mock-identity-provider-name-2',
          title: 'mock-identity-provider-title-2',
        } as IIdentityProvider,
      ];

      const fqdns = [
        {
          identityProvider: 'mock-id-1',
          fqdn: 'stendhal.fr',
        } as IFqdnToProvider,
        {
          identityProvider: 'mock-id-1',
          fqdn: 'flaubert.fr',
        } as IFqdnToProvider,
        {
          identityProvider: 'mock-id-2',
          fqdn: 'duras.fr',
        } as IFqdnToProvider,
      ];

      const expectedResult = [
        {
          uid: 'mock-id-1',
          active: true,
          display: true,
          name: 'mock-identity-provider-name-1',
          title: 'mock-identity-provider-title-1',
          fqdns: ['stendhal.fr', 'flaubert.fr'],
        },
        {
          uid: 'mock-id-2',
          active: false,
          display: false,
          name: 'mock-identity-provider-name-2',
          title: 'mock-identity-provider-title-2',
          fqdns: ['duras.fr'],
        },
      ];

      // When
      const result = fqdnToProviderService['getIdentityProvidersDTO'](
        identityProviders,
        fqdns,
      );

      // Then
      expect(result).toStrictEqual(expectedResult);
    });
  });
});
