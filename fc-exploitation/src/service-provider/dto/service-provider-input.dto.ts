/* istanbul ignore file */

// Declarative code
import {
  IsNotEmpty,
  Matches,
  IsArray,
  IsOptional,
  IsBoolean,
  IsNumber,
  IsString,
  IsIn,
} from 'class-validator';
import { ValidateWith } from '@fc/shared/validators/validate-with.validator';
import { Transform, Type } from 'class-transformer';
import {
  linesToArray,
  toArray,
  toBoolean,
} from '@fc/shared/transforms/string.transform';
import { IsDataURI } from '@fc/shared/validators/is-data-uri.validator';
import { IsOptionalExtended } from '@fc/shared/validators/is-optional-extended.validator';
import { IsValidInputString } from '@fc/shared/validators/is-valid-input-string';
import { AlgoValue } from '../../enum';
import { IP_VALIDATOR_REGEX } from '../../utils/ip-validator.constant';

const { ES256, RS256, HS256 } = AlgoValue;

// tslint:disable-next-line:max-line-length
// match empty string because of optionals paramters
// impossible to use IsOptionalExtended because of the Transform which always return something
const URL_REGEX = /^(?:((https?:\/\/)?((([^\s\/$.?#]{1,})(\.[^\s\/$?#]{2,})*\.[a-z]{2,})|(([0-9]{1,3}\.){3}[0-9]{1,3})|(([A-Za-z0-9\.\+-]{6,}):(?:\/\/)?(?:[\-;:&=\+\$,\w]+@)?[A-Za-z0-9\.\-_]+)|localhost)(:[0-9]{2,5})?(\/[^\s\/$]+)*\/?)?)$/;

// Regex retrieved from the 'identity-provider.dto' part to keep the same validation rule for the jwks uri
const URL_REGEX_JWKS = /^((https?:\/\/)?((([^\s\/$.?#]{1,})(\.[^\s\/$?#]{2,})*\.[a-z]{2,})|(([0-9]{1,3}\.){3}[0-9]{1,3})|localhost)(:[0-9]{2,5})?(\/[^\s\/$]+)*\/?)$/;
export class ServiceProviderDto {
  @IsValidInputString({
    message: `Veuillez mettre un nom valide ( Majuscule, minuscule, nombres et '.:_/!+- [espace] )`,
  })
  @IsNotEmpty({
    message: `Le nom du fournisseur de service doit être renseigné`,
  })
  readonly name: string;

  @IsOptional()
  readonly signupId: string;

  @Transform(linesToArray)
  @Matches(URL_REGEX, {
    each: true,
    message: 'Veuillez mettre une url valide ( Ex: https://toto.com/ )',
  })
  readonly redirectUri: string[];

  @Transform(linesToArray)
  @Matches(URL_REGEX, {
    each: true,
    message: ' Veuillez mettre une url valide ( Ex: https://toto.com/ )',
  })
  readonly redirectUriLogout: string[];

  @Transform(linesToArray)
  @Matches(URL_REGEX, {
    each: true,
    message: ' Veuillez mettre une url valide ( Ex: https://site.com/ )',
  })
  readonly site: string[];

  @IsOptionalExtended()
  @Matches(URL_REGEX_JWKS, {
    message:
      ' Veuillez mettre une client keys url valide au format ( Ex: https://urlvalide.fr/jwks )',
  })
  readonly jwksUri: string;

  @IsOptional()
  @Transform(linesToArray)
  @Matches(/^$|^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/, {
    each: true,
    message: 'Veuillez mettre des emails valides ( Ex: email@email.com )',
  })
  readonly emails: string[];

  // match empty string because of optionals paramters
  // impossible to use IsOptionalExtended because of the Transform which always return something
  @Transform(linesToArray)
  @Matches(IP_VALIDATOR_REGEX, {
    each: true,
    message: 'Veuillez mettre des ips valides ( Ex: 1.1.1.1 )',
  })
  readonly ipAddresses: string[];

  @IsNotEmpty({
    message: 'Veuillez faire un choix',
  })
  @Transform(toBoolean)
  readonly active: boolean;

  @IsNotEmpty({
    message: 'Veuillez faire un choix',
  })
  @IsString()
  readonly type: string;

  @IsOptionalExtended()
  // Limit of image size 1Mb
  // tslint:disable-next-line: prettier
  @IsDataURI(1048576, 'png|jpe?g|gif|svg\\+xml', {
    message: "Votre image n'est pas à la bonne taille ou bon format",
  })
  readonly logo: string;

  @IsOptional()
  @Transform(toArray)
  @IsArray()
  readonly scopes: string[];

  @ValidateWith(ServiceProviderDto.shouldValidateIdentityConsent, {
    message: `Vous ne pouvez pas demander un consentement pour un service provider public`,
  })
  @IsNotEmpty({
    message: 'Veuillez faire un choix',
  })
  @Transform(toBoolean)
  readonly identityConsent: boolean;

  @IsNotEmpty({
    message: 'Veuillez faire un choix',
  })
  @Transform(toBoolean)
  @IsBoolean()
  readonly trustedIdentity: boolean;

  @IsOptionalExtended()
  @IsNumber()
  @Type(() => Number)
  readonly eidas: number;

  @IsOptionalExtended()
  @IsIn(['A256GCM'], {
    message:
      '<strong>userinfo_encrypted_response_enc</strong> doit être une des valeurs suivantes: A256GCM',
  })
  // oidc defined variable name
  // tslint:disable-next-line: variable-name
  readonly userinfo_encrypted_response_enc?: string;

  @IsOptionalExtended()
  @IsIn(['ECDH-ES', 'RSA-OAEP'], {
    message:
      '<strong>userinfo_encrypted_response_alg</strong> doit être une des valeurs suivantes: ECDH-ES, RSA-OAEP',
  })
  // oidc defined variable name
  // tslint:disable-next-line: variable-name
  readonly userinfo_encrypted_response_alg?: string;

  @IsOptionalExtended()
  @IsIn([ES256, RS256, HS256], {
    message: `<strong>userinfo_signed_response_alg</strong> doit être une des valeurs suivantes: ${ES256}, ${RS256} ou ${HS256}`,
  })
  // oidc defined variable name
  // tslint:disable-next-line: variable-name
  readonly userinfo_signed_response_alg?: string;

  @IsOptionalExtended()
  @IsIn([ES256, RS256, HS256], {
    message: `<strong>id_token_signed_response_alg</strong> doit être une des valeurs suivantes: ${ES256}, ${RS256} ou ${HS256}`,
  })
  // oidc defined variable name
  // tslint:disable-next-line: variable-name
  readonly id_token_signed_response_alg?: string;

  @IsOptionalExtended()
  @IsIn(['ECDH-ES', 'RSA-OAEP'], {
    message:
      '<strong>id_token_encrypted_response_alg</strong> doit être une des valeurs suivantes: ECDH-ES, RSA-OAEP',
  })
  // oidc defined variable name
  // tslint:disable-next-line: variable-name
  readonly id_token_encrypted_response_alg?: string;

  @IsOptionalExtended()
  @IsIn(['A256GCM'], {
    message:
      '<strong>id_token_encrypted_response_enc</strong> doit être une des valeurs suivantes: A256GCM',
  })
  // oidc defined variable name
  // tslint:disable-next-line: variable-name
  readonly id_token_encrypted_response_enc?: string;

  @IsOptionalExtended()
  @Matches(/^[a-zA-Z1-9]{1}[a-zA-Z0-9-]{31,}$/, {
    each: true,
    message:
      "Veuillez mettre un id d'entité valide (lettres, chiffres, tirets et 32 caractères minimum)",
  })
  readonly entityId?: string;

  /**
   * type == public, identityConsent must be false
   * type == private, identityConsent is free
   */
  static shouldValidateIdentityConsent(
    instance: ServiceProviderDto,
    identityConsent: boolean,
  ) {
    return instance.type !== 'public' || !identityConsent;
  }
}
