import { Repository } from 'typeorm';
import { ConfigService } from 'nestjs-config';

import { Test, TestingModule } from '@nestjs/testing';
import { getModelToken } from '@nestjs/mongoose';
import { getRepositoryToken, TypeOrmModule } from '@nestjs/typeorm';
import { LoggerService } from '@fc/shared/logger/logger.service';
import { InstanceService } from '@fc/shared/utils';

import { SecretManagerService } from '../utils/secret-manager.service';
import { SecretAdapter } from '../utils/secret.adapter';

import { IServiceProvider } from './interface';
import { ServiceProviderService } from './service-provider.service';
import { ServiceProvider } from './service-provider.mongodb.entity';
import { ClientSchema } from './schema/service-provider.schema';
import { ICrudTrack } from '../interfaces';

describe('ServiceProviderService', () => {
  let module: TestingModule;
  let serviceProviderService: ServiceProviderService;

  const configServiceMock = {
    get: jest.fn(),
  };

  const instanceServiceMock = {
    isFcaLow: jest.fn(),
    isCl: jest.fn(),
    isFcpHigh: jest.fn(),
  };

  const secretManagerMocked = {
    encrypt: jest.fn(),
    decrypt: jest.fn(),
    generateSHA256: jest.fn(),
  };

  const secretAdapterMock = {
    generateSecret: jest.fn(),
    generateKey: jest.fn(),
  };

  const serviceProviderRepository = {
    save: jest.fn(),
    insertOne: jest.fn(),
    find: jest.fn(),
    findAndCount: jest.fn(),
    findOne: jest.fn(),
    delete: jest.fn(),
  };

  const userMock = 'userMockValue';

  const serviceProviderMock = ({
    key: 'keyMock',
    name: 'monfs',
    signupId: '123456',
    redirectUri: ['https://monfs.com'],
    redirectUriLogout: ['https://monfs.com/logout'],
    site: ['https://monfs.com'],
    ipAddresses: ['192.0.0.0'],
    emails: ['v@b.com'],
    active: true,
    type: 'private',
    scopes: [],
    identityConsent: true,
    trustedIdentity: false,
    eidas: 1,
    idpFilterExclude: true,
    idpFilterList: [],
  } as unknown) as IServiceProvider;

  const expectedServiceProviderCreated = {
    active: false,
    eidas: 1,
    identityConsent: true,
    name: 'monfs',
    site: ['https://monfs.com'],
    client_secret: 'FE1CE803iuyiuyiy',
    createdAt: expect.any(Date),
    credentialFlow: false,
    emails: ['v@b.com'],
    entityId: 'secretKeyMocked',
    ipAddresses: ['192.0.0.0'],
    key: 'secretKeyMocked',
    redirectUri: ['https://monfs.com'],
    redirectUriLogout: ['https://monfs.com/logout'],
    scopes: [],
    secretCreatedAt: expect.any(Date),
    secretUpdatedAt: expect.any(Date),
    secretUpdatedBy: 'user',
    signupId: '123456',
    trustedIdentity: false,
    type: 'private',
    updatedAt: expect.any(Date),
    updatedBy: 'user',
  };

  const expectedServiceProviderUpdated = {
    active: false,
    eidas: 1,
    identityConsent: true,
    name: 'monfs',
    site: ['https://monfs.com'],
    email: 'v@b.com',
    IPServerAddressesAndRanges: ['192.0.0.0'],
    redirect_uris: ['https://monfs.com'],
    post_logout_redirect_uris: ['https://monfs.com/logout'],
    scopes: ['openid'],
    trustedIdentity: false,
    type: 'private',
    updatedAt: expect.any(Date),
    updatedBy: 'userMockValue',
    ssoDisabled: false,
    signup_id: '123456',
    rep_scope: [],
  };

  const insertResultMock = {
    insertedId: 'insertedIdMock',
    key: 'keyMock',
  };

  const loggerMock = {
    businessEvent: jest.fn(),
  };

  beforeEach(async () => {
    jest.resetAllMocks();

    module = await Test.createTestingModule({
      imports: [TypeOrmModule.forFeature([ServiceProvider], 'fc-mongo')],
      providers: [
        ServiceProviderService,
        {
          provide: getModelToken('Client'),
          useValue: ClientSchema,
        },
        Repository,
        SecretManagerService,
        ConfigService,
        SecretAdapter,
        InstanceService,
        LoggerService,
      ],
    })
      .overrideProvider(getRepositoryToken(ServiceProvider, 'fc-mongo'))
      .useValue(serviceProviderRepository)
      .overrideProvider(SecretManagerService)
      .useValue(secretManagerMocked)
      .overrideProvider(ConfigService)
      .useValue(configServiceMock)
      .overrideProvider(InstanceService)
      .useValue(instanceServiceMock)
      .overrideProvider(SecretAdapter)
      .useValue(secretAdapterMock)
      .overrideProvider(LoggerService)
      .useValue(loggerMock)
      .compile();

    serviceProviderService = await module.get<ServiceProviderService>(
      ServiceProviderService,
    );

    serviceProviderRepository.findOne.mockResolvedValue(serviceProviderMock);
    serviceProviderRepository.insertOne.mockResolvedValue(insertResultMock);
  });

  afterAll(async () => {
    module.close();
  });

  describe('track', () => {
    it('should call logger.businessEvent', () => {
      // Given
      const logMock = {} as ICrudTrack;
      // When
      // tslint:disable-next-line:no-string-literal
      serviceProviderService['track'](logMock);
      // Then
      expect(loggerMock.businessEvent).toHaveBeenCalledTimes(1);
      expect(loggerMock.businessEvent).toHaveBeenCalledWith(logMock);
    });
  });

  describe('createServiceProvider', () => {
    beforeEach(() => {
      // tslint:disable-next-line:no-string-literal
      serviceProviderService['track'] = jest.fn();
      secretAdapterMock.generateKey.mockResolvedValue('secretKeyMocked');
      secretAdapterMock.generateSecret.mockResolvedValueOnce('FE1CE803');
      secretManagerMocked.generateSHA256.mockResolvedValueOnce('FE1CE803');
      secretManagerMocked.encrypt.mockResolvedValueOnce('FE1CE803iuyiuyiy');
      instanceServiceMock.isCl.mockReturnValueOnce(true);
      instanceServiceMock.isFcpHigh.mockReturnValueOnce(false);
    });

    it('should calls the tracking method', async () => {
      // Given
      instanceServiceMock.isFcaLow.mockReturnValueOnce(true);
      instanceServiceMock.isCl.mockReset().mockReturnValueOnce(false);

      // When
      const _result = await serviceProviderService.createServiceProvider(
        serviceProviderMock,
        userMock,
      );

      // Then
      // tslint:disable-next-line:no-string-literal
      expect(serviceProviderService['track']).toHaveBeenCalledTimes(1);
      // tslint:disable-next-line:no-string-literal
      expect(serviceProviderService['track']).toHaveBeenCalledWith({
        entity: 'service-provider',
        action: 'create',
        user: userMock,
        id: 'insertedIdMock',
        name: 'secretKeyMocked',
      });
    });

    it('should call generateKey once if entityId is provide in params', async () => {
      // Given
      const spMock = {
        ...serviceProviderMock,
        entityId: '12aze3',
      };

      // When
      const _result = await serviceProviderService.createServiceProvider(
        spMock,
        'user',
      );

      // Then
      expect(secretAdapterMock.generateKey).toHaveBeenCalledTimes(1);
    });

    it('should call generateKey twice if entityId is not provide in params', async () => {
      // When
      const _result = await serviceProviderService.createServiceProvider(
        serviceProviderMock,
        'user',
      );

      // Then
      expect(secretAdapterMock.generateKey).toHaveBeenCalledTimes(2);
    });

    it('should call generateSecret method', async () => {
      // When
      await serviceProviderService.createServiceProvider(
        serviceProviderMock,
        'user',
      );

      // Then
      expect(secretAdapterMock.generateSecret).toHaveBeenCalledTimes(1);
    });

    it('should call encrypt method', async () => {
      // When
      const _result = await serviceProviderService.createServiceProvider(
        serviceProviderMock,
        'user',
      );

      // Then
      expect(secretManagerMocked.encrypt).toHaveBeenCalledTimes(1);
      expect(secretManagerMocked.encrypt).toHaveBeenCalledWith('FE1CE803');
    });

    it('should call transformIntoLegacy method', async () => {
      // Given
      serviceProviderService['transformIntoLegacy'] = jest
        .fn()
        .mockReturnValue({});

      // When
      await serviceProviderService.createServiceProvider(
        serviceProviderMock,
        'user',
      );

      // Then
      expect(
        serviceProviderService['transformIntoLegacy'],
      ).toHaveBeenCalledTimes(1);
      expect(
        serviceProviderService['transformIntoLegacy'],
      ).toHaveBeenCalledWith({
        key: 'keyMock',
        active: true,
        eidas: 1,
        emails: ['v@b.com'],
        identityConsent: true,
        ipAddresses: ['192.0.0.0'],
        name: 'monfs',
        redirectUri: ['https://monfs.com'],
        redirectUriLogout: ['https://monfs.com/logout'],
        scopes: [],
        signupId: '123456',
        site: ['https://monfs.com'],
        trustedIdentity: false,
        type: 'private',
        idpFilterExclude: true,
        idpFilterList: [],
      });
    });

    it('should call inserOne method into FC legacy context', async () => {
      // Given
      const spMock = {
        ...serviceProviderMock,
        platform: 'CORE_LEGACY',
      };

      const expected = {
        ...expectedServiceProviderCreated,
        idpFilterExclude: true,
        idpFilterList: [],
        platform: 'CORE_LEGACY',
      };

      serviceProviderService['arrayToKeyObject'] = jest
        .fn()
        .mockReturnValue({ fip1: true })
        .mockReturnValue({});
      serviceProviderService['transformIntoLegacy'] = jest
        .fn()
        .mockReturnValue(spMock);

      // When
      const _result = await serviceProviderService.createServiceProvider(
        spMock,
        'user',
      );

      // Then
      expect(serviceProviderRepository.insertOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.insertOne).toHaveBeenCalledWith(
        expected,
      );
    });

    it('should call inserOne method into FC low context', async () => {
      // Given
      const spMock = {
        ...serviceProviderMock,
        idpFilterExclude: false,
        idpFilterList: ['fip1v2'],
        platform: 'CORE_FCP',
      };

      const expected = {
        ...expectedServiceProviderCreated,
        idpFilterExclude: false,
        idpFilterList: ['fip1v2'],
        platform: 'CORE_FCP',
      };

      serviceProviderService['transformIntoLegacy'] = jest
        .fn()
        .mockReturnValue(spMock);

      // When
      const _result = await serviceProviderService.createServiceProvider(
        spMock,
        'user',
      );

      // Then
      expect(serviceProviderRepository.insertOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.insertOne).toHaveBeenCalledWith(
        expected,
      );
    });

    it('should call inserOne method into FC+ context', async () => {
      // Given
      const spMock = {
        ...serviceProviderMock,
        idpFilterExclude: true,
        idpFilterList: ['fip1v2'],
        jwksUri: 'https://monfs.com/jwks',
      };

      const expected = {
        ...expectedServiceProviderCreated,
        idpFilterExclude: true,
        idpFilterList: ['fip1v2'],
        jwks_uri: 'https://monfs.com/jwks',
      };

      serviceProviderService['transformIntoLegacy'] = jest
        .fn()
        .mockReturnValue(serviceProviderMock);

      instanceServiceMock.isCl.mockReset().mockReturnValueOnce(false);
      instanceServiceMock.isFcpHigh.mockReset().mockReturnValueOnce(true);

      // When
      const _result = await serviceProviderService.createServiceProvider(
        spMock,
        'user',
      );

      // Then
      expect(serviceProviderRepository.insertOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.insertOne).toHaveBeenCalledWith(
        expected,
      );
    });
  });

  describe('findById', () => {
    it("should find a service provider in mongodb and decrypt it's secret", async () => {
      // setup
      const id = '5d4d6d29bbdfbd203da312f2';
      const secretCipher = '<cipher>';
      const secret = '◬ La terre est plate ◬';
      const serviceProvider = {
        id: '5d4d6d29bbdfbd203da312f2',
        client_secret: secretCipher,
      };
      serviceProviderRepository.findOne.mockResolvedValueOnce(serviceProvider);
      secretManagerMocked.decrypt.mockReturnValueOnce(secret);

      // action
      const result = await serviceProviderService.findById(id);

      // expect
      expect(serviceProviderRepository.findOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.findOne).toHaveBeenCalledWith(id);
      expect(secretManagerMocked.decrypt).toHaveBeenCalledTimes(1);
      expect(secretManagerMocked.decrypt).toHaveBeenCalledWith(secretCipher);
      expect(result).toEqual({
        ...serviceProvider,
        client_secret: secret,
      });
    });
  });

  describe('getRepresentationScopeList', () => {
    it('should call ConfigService.get ', () => {
      // Given
      const configGetResultMock = {
        representativeScopeList: Symbol('configGetResultMock'),
      };
      configServiceMock.get.mockReturnValue(configGetResultMock);

      // When
      serviceProviderService.getRepresentativeScopeList();

      // Then
      expect(configServiceMock.get).toHaveBeenCalledTimes(1);
      expect(configServiceMock.get).toHaveBeenCalledWith('service-provider');
    });

    it('should return the content configured representativeScopeList', () => {
      // Given
      const configGetResultMock = {
        representativeScopeList: Symbol('configGetResultMock'),
      };
      configServiceMock.get.mockReturnValue(configGetResultMock);

      // When
      const result = serviceProviderService.getRepresentativeScopeList();

      // Then
      expect(result).toEqual(configGetResultMock.representativeScopeList);
    });
  });

  describe('update()', () => {
    const id = '5d4d6d29bbdfbd203da312f2';

    beforeEach(() => {
      // tslint:disable-next-line:no-string-literal
      serviceProviderService['track'] = jest.fn();
    });

    it('should call findOne method to retrieve service provider', async () => {
      // action
      await serviceProviderService.update(id, serviceProviderMock, userMock);

      // expect
      expect(serviceProviderRepository.findOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.findOne).toHaveBeenCalledWith(id);
    });

    it('should calls the tracking method', async () => {
      // setup
      serviceProviderRepository.findOne.mockImplementationOnce(() =>
        Promise.resolve({
          name: 'franceConnect',
          signupId: '123456',
          redirectUri: ['https://franceConnect.com'],
          redirectUriLogout: ['https://franceConnect.com/logout'],
          site: 'https://franceConnect.com',
          ipAddresses: ['192.0.0.0'],
          emails: ['v@b2.com'],
          active: true,
          type: 'private',
          scopes: ['toto', 'tutu'],
          trustedIdentity: false,
          eidas: 1,
        }),
      );

      instanceServiceMock.isFcaLow.mockReturnValueOnce(true);
      instanceServiceMock.isCl.mockReturnValueOnce(false);
      instanceServiceMock.isFcpHigh.mockReturnValueOnce(false);

      // action
      await serviceProviderService.update(id, serviceProviderMock, userMock);
      // assertion
      // tslint:disable-next-line:no-string-literal
      expect(serviceProviderService['track']).toHaveBeenCalledTimes(1);
      // tslint:disable-next-line:no-string-literal
      expect(serviceProviderService['track']).toHaveBeenCalledWith({
        entity: 'service-provider',
        action: 'update',
        id,
        user: userMock,
      });
    });

    it('should update service provider in FC+ context', async () => {
      // Given
      const dataToUpdate = ({
        ...serviceProviderMock,
        idpFilterExclude: true,
        idpFilterList: ['fip1v2'],
        ssoDisabled: false,
        jwks_uri: 'jwks_uri',
        id_token_encrypted_response_alg: 'id_token_encrypted_response_alg',
        id_token_encrypted_response_enc: 'id_token_encrypted_response_enc',
        id_token_signed_response_alg: 'id_token_signed_response_alg',
        userinfo_encrypted_response_alg: 'userinfo_encrypted_response_alg',
        userinfo_encrypted_response_enc: 'userinfo_encrypted_response_enc',
        userinfo_signed_response_alg: 'userinfo_signed_response_alg',
      } as unknown) as IServiceProvider;

      serviceProviderRepository.findOne.mockImplementationOnce(() =>
        Promise.resolve({
          name: 'franceConnect',
          signup_id: '123456',
          redirect_uris: ['https://franceConnect.com'],
          post_logout_redirect_uris: ['https://franceConnect.com/logout'],
          site: 'https://franceConnect.com',
          IPServerAddressesAndRanges: ['192.0.0.0'],
          email: ['v@b2.com'],
          active: false,
          type: 'private',
          scopes: ['toto', 'tutu'],
          trustedIdentity: false,
          eidas: 1,
          identityConsent: false,
          id_token_encrypted_response_alg: 'id_token_encrypted_response_alg',
          id_token_encrypted_response_enc: 'id_token_encrypted_response_enc',
          id_token_signed_response_alg: 'id_token_signed_response_alg',
          userinfo_encrypted_response_alg: 'userinfo_encrypted_response_alg',
          userinfo_encrypted_response_enc: 'userinfo_encrypted_response_enc',
          userinfo_signed_response_alg: 'userinfo_signed_response_alg',
          idpFilterExclude: false,
          idpFilterList: [],
          jwks_uri: 'jwks_uri',
        }),
      );

      const expected = {
        ...expectedServiceProviderUpdated,
        idpFilterExclude: true,
        idpFilterList: ['fip1v2'],
        id_token_encrypted_response_alg: 'id_token_encrypted_response_alg',
        id_token_encrypted_response_enc: 'id_token_encrypted_response_enc',
        id_token_signed_response_alg: 'id_token_signed_response_alg',
        userinfo_encrypted_response_alg: 'userinfo_encrypted_response_alg',
        userinfo_encrypted_response_enc: 'userinfo_encrypted_response_enc',
        userinfo_signed_response_alg: 'userinfo_signed_response_alg',
        jwks_uri: undefined,
      };

      instanceServiceMock.isFcaLow.mockReturnValueOnce(false);
      instanceServiceMock.isCl.mockReturnValueOnce(false);
      instanceServiceMock.isFcpHigh.mockReturnValueOnce(true);

      // When
      await serviceProviderService.update(id, dataToUpdate, userMock);

      // Then
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.save).toHaveBeenCalledWith(expected);
    });

    it('should update service provider in FC legacy context', async () => {
      // Given
      const dataToUpdate = ({
        ...serviceProviderMock,
        ssoDisabled: false,
        id_token_signed_response_alg: 'id_token_signed_response_alg',
        userinfo_signed_response_alg: 'userinfo_signed_response_alg',
        id_token_encrypted_response_alg: '',
        id_token_encrypted_response_enc: '',
        userinfo_encrypted_response_alg: '',
        userinfo_encrypted_response_enc: '',
        platform: 'CORE_LEGACY',
      } as unknown) as IServiceProvider;

      serviceProviderRepository.findOne.mockImplementationOnce(() =>
        Promise.resolve({
          name: 'franceConnect',
          signup_id: '123456',
          redirect_uris: ['https://franceConnect.com'],
          post_logout_redirect_uris: ['https://franceConnect.com/logout'],
          site: 'https://franceConnect.com',
          IPServerAddressesAndRanges: ['192.0.0.0'],
          email: ['v@b2.com'],
          active: true,
          type: 'private',
          scopes: ['toto', 'tutu'],
          trustedIdentity: false,
          eidas: 1,
          identityConsent: false,
          id_token_signed_response_alg: 'id_token_signed_response_alg',
          userinfo_signed_response_alg: 'userinfo_signed_response_alg',
          id_token_encrypted_response_alg: '',
          id_token_encrypted_response_enc: '',
          userinfo_encrypted_response_alg: '',
          userinfo_encrypted_response_enc: '',
        }),
      );

      const expected = {
        ...expectedServiceProviderUpdated,
        id_token_signed_response_alg: 'id_token_signed_response_alg',
        userinfo_signed_response_alg: 'userinfo_signed_response_alg',
        id_token_encrypted_response_alg: '',
        id_token_encrypted_response_enc: '',
        userinfo_encrypted_response_alg: '',
        userinfo_encrypted_response_enc: '',
        platform: 'CORE_LEGACY',
      };

      instanceServiceMock.isFcaLow.mockReturnValueOnce(false);
      instanceServiceMock.isCl.mockReturnValueOnce(true);
      instanceServiceMock.isFcpHigh.mockReturnValueOnce(false);

      // When
      await serviceProviderService.update(id, dataToUpdate, userMock);

      // Then
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.save).toHaveBeenCalledWith(expected);
    });

    it('should update service provider in FC low context', async () => {
      // Given
      const dataToUpdate = ({
        ...serviceProviderMock,
        idpFilterExclude: true,
        idpFilterList: ['fip1v2'],
        ssoDisabled: false,
        id_token_signed_response_alg: 'id_token_signed_response_alg',
        userinfo_signed_response_alg: 'userinfo_signed_response_alg',
        id_token_encrypted_response_alg: '',
        id_token_encrypted_response_enc: '',
        userinfo_encrypted_response_alg: '',
        userinfo_encrypted_response_enc: '',
        platform: 'CORE_FCP',
      } as unknown) as IServiceProvider;

      serviceProviderRepository.findOne.mockImplementationOnce(() =>
        Promise.resolve({
          name: 'franceConnect',
          signup_id: '123456',
          redirect_uris: ['https://franceConnect.com'],
          post_logout_redirect_uris: ['https://franceConnect.com/logout'],
          site: 'https://franceConnect.com',
          IPServerAddressesAndRanges: ['192.0.0.0'],
          email: ['v@b2.com'],
          active: true,
          type: 'private',
          scopes: ['toto', 'tutu'],
          trustedIdentity: false,
          eidas: 1,
          identityConsent: false,
          id_token_signed_response_alg: 'id_token_signed_response_alg',
          userinfo_signed_response_alg: 'userinfo_signed_response_alg',
          id_token_encrypted_response_alg: '',
          id_token_encrypted_response_enc: '',
          userinfo_encrypted_response_alg: '',
          userinfo_encrypted_response_enc: '',
          idpFilterExclude: false,
          idpFilterList: [],
        }),
      );

      const expected = {
        ...expectedServiceProviderUpdated,
        idpFilterExclude: true,
        idpFilterList: ['fip1v2'],
        id_token_signed_response_alg: 'id_token_signed_response_alg',
        userinfo_signed_response_alg: 'userinfo_signed_response_alg',
        id_token_encrypted_response_alg: '',
        id_token_encrypted_response_enc: '',
        userinfo_encrypted_response_alg: '',
        userinfo_encrypted_response_enc: '',
        platform: 'CORE_FCP',
      };

      instanceServiceMock.isFcaLow.mockReturnValueOnce(false);
      instanceServiceMock.isCl.mockReturnValueOnce(true);
      instanceServiceMock.isFcpHigh.mockReturnValueOnce(false);

      // When
      await serviceProviderService.update(id, dataToUpdate, userMock);

      // Then
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.save).toHaveBeenCalledWith(expected);
    });
  });

  describe('delete service provider by id', () => {
    beforeEach(() => {
      // tslint:disable-next-line:no-string-literal
      serviceProviderService['track'] = jest.fn();
    });

    it('calls the delete function of the serviceProviderRepository with a string as argument', async () => {
      // set up
      const idMock = '123';
      // action
      await serviceProviderService.deleteServiceProviderById(idMock, userMock);
      // assertion
      expect(serviceProviderRepository.delete).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.delete).toHaveBeenCalledWith(idMock);
    });
    it('should calls the tracking method', async () => {
      // set up
      const idMock = '123';

      // action
      await serviceProviderService.deleteServiceProviderById(idMock, userMock);
      // assertion
      // tslint:disable-next-line:no-string-literal
      expect(serviceProviderService['track']).toHaveBeenCalledTimes(1);
      // tslint:disable-next-line:no-string-literal
      expect(serviceProviderService['track']).toHaveBeenCalledWith({
        action: 'delete',
        entity: 'service-provider',
        id: idMock,
        user: userMock,
        name: 'secretKeyMocked',
      });
    });
  });

  describe('deleteManyServiceProvidersById', () => {
    it('calls the delete function of the serviceProviderRepository with an array of string as argument', async () => {
      // set up
      const clientsId = ['aaaa', 'bbbb', 'cccc'];
      serviceProviderService.deleteServiceProviderById = jest.fn();
      // action
      await serviceProviderService.deleteManyServiceProvidersById(
        clientsId,
        userMock,
      );
      // assertion
      expect(
        serviceProviderService.deleteServiceProviderById,
      ).toHaveBeenCalledTimes(3);
      expect(
        serviceProviderService.deleteServiceProviderById,
      ).toHaveBeenNthCalledWith(1, clientsId[0], userMock);
      expect(
        serviceProviderService.deleteServiceProviderById,
      ).toHaveBeenNthCalledWith(2, clientsId[1], userMock);
      expect(
        serviceProviderService.deleteServiceProviderById,
      ).toHaveBeenNthCalledWith(3, clientsId[2], userMock);
    });
  });

  describe('generate a new client secret', () => {
    it('should generate a new client secret with hsm', async () => {
      const id = '5d4d6d29bbdfbd203da312f2';

      serviceProviderRepository.findOne.mockImplementationOnce(() =>
        Promise.resolve({
          name: 'franceConnect',
          signupId: '123456',
          redirectUri: ['https://franceConnect.com'],
          redirectUriLogout: ['https://franceConnect.com/logout'],
          site: 'https://franceConnect.com',
          ipAddresses: ['192.0.0.0'],
          emails: ['v@b2.com'],
          active: true,
          type: 'private',
          key: 'bafe2428-3ab9-4c44-9021-46bde0cd13c5',
          client_secret:
            '$2b$10$EO3FnI3YKfnnvUlvr084wegEgEPeRPRMdE2VJwMHpAsNkaMv1n9pG',
          trustedIdentity: false,
          eidas: 1,
        }),
      );

      configServiceMock.get.mockReturnValue({ use_hsm: 'true' });
      secretManagerMocked.encrypt.mockReturnValueOnce(
        '$2b$10$EO3FnI3YKfnnvUlvr084wegEgEPeRPRMdE2VJwMHpAsNkaMv1n9pG',
      );

      await serviceProviderService.generateNewSecret(id, 'user');

      expect(secretAdapterMock.generateSecret).toHaveBeenCalledTimes(1);
      expect(secretManagerMocked.encrypt).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.findOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
    });

    it('should generate a new client secret without hsm', async () => {
      const id = '5d4d6d29bbdfbd203da312f2';

      serviceProviderRepository.findOne.mockResolvedValueOnce({
        name: 'franceConnect',
        signupId: '123456',
        redirectUri: ['https://franceConnect.com'],
        redirectUriLogout: ['https://franceConnect.com/logout'],
        site: 'https://franceConnect.com',
        ipAddresses: ['192.0.0.0'],
        emails: ['v@b2.com'],
        active: true,
        type: 'private',
        key: 'bafe2428-3ab9-4c44-9021-46bde0cd13c5',
        client_secret:
          '$2b$10$EO3FnI3YKfnnvUlvr084wegEgEPeRPRMdE2VJwMHpAsNkaMv1n9pG',
        trustedIdentity: false,
        eidas: 1,
      });

      configServiceMock.get.mockReturnValue({ use_hsm: 'false' });

      await serviceProviderService.generateNewSecret(id, 'user');

      expect(secretAdapterMock.generateSecret).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.findOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
    });
  });
});
