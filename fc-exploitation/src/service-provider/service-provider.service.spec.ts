import { Repository } from 'typeorm';
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken, TypeOrmModule } from '@nestjs/typeorm';
import { ServiceProviderService } from './service-provider.service';
import { ServiceProvider } from './service-provider.entity';

describe('ServiceProviderService', () => {
  let module: TestingModule;
  let serviceProviderService: ServiceProviderService;

  const serviceProviderRepository = {
    save: jest.fn(),
    findAndCount: jest.fn(),
    findOne: jest.fn(),
    delete: jest.fn(),
  };

  const serviceMock = {
    createServiceProvider: jest.fn(),
    paginate: jest.fn(),
    save: jest.fn(),
  };

  beforeEach(async () => {
    module = await Test.createTestingModule({
      imports: [TypeOrmModule.forFeature([ServiceProvider], 'fc-mongo')],
      providers: [ServiceProviderService, Repository],
    })
      .overrideProvider(getRepositoryToken(ServiceProvider, 'fc-mongo'))
      .useValue(serviceProviderRepository)
      .compile();

    serviceProviderService = await module.get<ServiceProviderService>(
      ServiceProviderService,
    );
    jest.resetAllMocks();
  });

  afterAll(async () => {
    module.close();
  });

  describe('createUser', () => {
    it('creates the user', async () => {
      const IServiceProvider = {
        title: 'monfs',
        name: 'monfs',
        redirectUri: ['https://monfs.com'],
        redirectUriLogout: ['https://monfs.com/logout'],
        site: 'https://monfs.com',
        ipAddresses: ['192.0.0.0'],
        emails: ['v@b.com'],
        active: true,
        type: 'private',
      };
      await serviceProviderService.createServiceProvider(IServiceProvider);
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
    });
  });

  describe('findById', () => {
    it('should find a service provider in mongodb', async () => {
      const id = '5d4d6d29bbdfbd203da312f2';
      await serviceProviderService.findById(id);
      expect(serviceProviderRepository.findOne).toHaveBeenCalledTimes(1);
    });
  });

  describe('update', () => {
    it('should update with all data', async () => {
      const dataToUpdate = {
        title: 'monfs',
        name: 'monfs',
        redirectUri: ['https://monfs.com'],
        redirectUriLogout: ['https://monfs.com/logout'],
        site: 'https://monfs.com',
        ipAddresses: ['192.0.0.0'],
        emails: ['v@b.com'],
        active: true,
        type: 'private',
      };

      const id = '5d4d6d29bbdfbd203da312f2';

      serviceProviderRepository.findOne.mockImplementationOnce(() =>
        Promise.resolve({
          title: 'franceConnect',
          name: 'franceConnect',
          redirectUri: ['https://franceConnect.com'],
          redirectUriLogout: ['https://franceConnect.com/logout'],
          site: 'https://franceConnect.com',
          ipAddresses: ['192.0.0.0'],
          emails: ['v@b2.com'],
          active: true,
          type: 'private',
        }),
      );

      await serviceProviderService.update(id, dataToUpdate);
      expect(serviceProviderRepository.findOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
    });

    it('should update a document with only arrayLike ( emails, ips, redirectUris and postRedirectUris) as updated data', async () => {
      const dataToUpdate = {
        title: 'franceConnect',
        name: 'franceConnect',
        redirectUri: ['https://toto.com'],
        redirectUriLogout: ['https://toto.com/logout'],
        site: 'https://toto.com',
        ipAddresses: ['192.0.0.0'],
        emails: ['v@b.com'],
        active: true,
        type: 'private',
      };

      const id = '5d4d6d29bbdfbd203da312f2';

      serviceProviderRepository.findOne.mockImplementationOnce(() =>
        Promise.resolve({
          title: 'franceConnect',
          name: 'franceConnect',
          redirectUri: ['https://franceConnect.com'],
          redirectUriLogout: ['https://franceConnect.com/logout'],
          site: 'https://franceConnect.com',
          ipAddresses: ['192.0.0.0'],
          emails: ['v@b2.com'],
          active: true,
          type: 'private',
        }),
      );

      await serviceProviderService.update(id, dataToUpdate);
      expect(serviceProviderRepository.findOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
    });

    it('should update a document with only stringLike ( title, name) as updated data', async () => {
      const dataToUpdate = {
        title: 'monfs',
        name: 'monfs',
        redirectUri: ['https://franceConnect.com'],
        redirectUriLogout: ['https://franceConnect.com/logout'],
        site: 'https://franceConnect.com',
        ipAddresses: ['192.0.0.0'],
        emails: ['v@b.com'],
        active: true,
        type: 'private',
      };

      const id = '5d4d6d29bbdfbd203da312f2';

      serviceProviderRepository.findOne.mockImplementationOnce(() =>
        Promise.resolve({
          title: 'franceConnect',
          name: 'franceConnect',
          redirectUri: ['https://franceConnect.com'],
          redirectUriLogout: ['https://franceConnect.com/logout'],
          site: 'https://franceConnect.com',
          ipAddresses: ['192.0.0.0'],
          emails: ['v@b2.com'],
          active: true,
          type: 'private',
        }),
      );

      await serviceProviderService.update(id, dataToUpdate);
      expect(serviceProviderRepository.findOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
    });
  });

  describe('delete service provider by key', () => {
    it('calls the delete function of the serviceProviderRepository with a string as argument', async () => {
      // set up
      const key = { key: '123' };
      const expectedRepositoryDeleteArguments = { key: '123' };
      // action
      await serviceProviderService.deleteServiceProviderByKey(key);
      // assertion
      expect(serviceProviderRepository.delete).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.delete).toHaveBeenCalledWith(
        expectedRepositoryDeleteArguments,
      );
    });

    it('calls the delete function of the serviceProviderRepository with an array of string as argument', async () => {
      // set up
      const clientsId = [{ key: 'aaaa' }, { key: 'bbbb' }, { key: 'cccc' }];
      const expectedRepositoryDeleteArguments = [
        { key: 'aaaa' },
        { key: 'bbbb' },
        { key: 'cccc' },
      ];
      // action
      await serviceProviderService.deleteServiceProviderByKey(clientsId);
      // assertion
      expect(serviceProviderRepository.delete).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.delete).toHaveBeenCalledWith(
        expectedRepositoryDeleteArguments,
      );
    });
  });
});
