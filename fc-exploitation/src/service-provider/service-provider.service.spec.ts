import { Repository } from 'typeorm';
import { ConfigService } from 'nestjs-config';
import { Test, TestingModule } from '@nestjs/testing';
import { getModelToken } from '@nestjs/mongoose';
import { getRepositoryToken, TypeOrmModule } from '@nestjs/typeorm';
import { RabbitmqService } from '@fc/shared/rabbitmq';
import { SecretManagerService } from '../utils/secret-manager.service';
import { SecretAdapter } from '../utils/secret.adapter';
import { ServiceProviderService } from './service-provider.service';
import { ServiceProvider } from './service-provider.mongodb.entity';
import { ClientSchema } from './schema/service-provider.schema';

describe('ServiceProviderService', () => {
  let module: TestingModule;
  let serviceProviderService: ServiceProviderService;

  const configServiceMock = {
    get: jest.fn(),
  };

  const brokerMock = {
    publish: jest.fn(),
  };

  const secretManagerMocked = {
    encrypt: jest.fn(),
    decrypt: jest.fn(),
    generateSHA256: jest.fn(),
  };

  const secretAdapterMock = {
    generateSecret: jest.fn(),
  };

  const serviceProviderRepository = {
    save: jest.fn(),
    find: jest.fn(),
    findAndCount: jest.fn(),
    findOne: jest.fn(),
    delete: jest.fn(),
  };

  const rabbitmqRandomMockValue = 'rabbitmqRandomMockValue';
  const rabbitmqMock = {
    publish: jest.fn(),
  };

  beforeEach(async () => {
    module = await Test.createTestingModule({
      imports: [TypeOrmModule.forFeature([ServiceProvider], 'fc-mongo')],
      providers: [
        ServiceProviderService,
        {
          provide: getModelToken('Client'),
          useValue: ClientSchema,
        },
        Repository,
        SecretManagerService,
        RabbitmqService,
        ConfigService,
        SecretAdapter,
      ],
    })
      .overrideProvider(getRepositoryToken(ServiceProvider, 'fc-mongo'))
      .useValue(serviceProviderRepository)
      .overrideProvider(SecretManagerService)
      .useValue(secretManagerMocked)
      .overrideProvider(RabbitmqService)
      .useValue(rabbitmqMock)
      .overrideProvider(ConfigService)
      .useValue(configServiceMock)
      .overrideProvider(SecretAdapter)
      .useValue(secretAdapterMock)
      .compile();

    serviceProviderService = await module.get<ServiceProviderService>(
      ServiceProviderService,
    );
    jest.resetAllMocks();

    rabbitmqMock.publish.mockResolvedValue(rabbitmqRandomMockValue);
  });

  afterAll(async () => {
    module.close();
  });

  describe('createServiceProvider', () => {
    it('creates the service provider', async () => {
      const IServiceProvider = {
        name: 'monfs',
        signupId: '123456',
        redirectUri: ['https://monfs.com'],
        redirectUriLogout: ['https://monfs.com/logout'],
        site: ['https://monfs.com'],
        ipAddresses: ['192.0.0.0'],
        logo: 'my_logo.png',
        emails: ['v@b.com'],
        active: true,
        type: 'private',
        scopes: [],
        identityConsent: true,
        trustedIdentity: false,
        eidas: 1,
      };

      const key = '7a79e45107f9ccc6a3a5971d501220d';
      const secret = secretAdapterMock.generateSecret.mockResolvedValueOnce(
        'FE1CE803',
      );
      secretManagerMocked.encrypt.mockResolvedValueOnce('FE1CE803iuyiuyiy');
      await serviceProviderService.createServiceProvider(
        IServiceProvider,
        'user',
      );

      expect(secretAdapterMock.generateSecret).toHaveBeenCalledTimes(1);
      expect(secretManagerMocked.encrypt).toHaveBeenCalledTimes(1);
      expect(secretManagerMocked.encrypt).toHaveBeenCalledWith('FE1CE803');
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
    });
  });

  describe('findById', () => {
    it("should find a service provider in mongodb and decrypt it's secret", async () => {
      // setup
      const id = '5d4d6d29bbdfbd203da312f2';
      const secretCipher = '<cipher>';
      const secret = '◬ La terre est plate ◬';
      const serviceProvider = {
        id: '5d4d6d29bbdfbd203da312f2',
        client_secret: secretCipher,
      };
      serviceProviderRepository.findOne.mockResolvedValueOnce(serviceProvider);
      secretManagerMocked.decrypt.mockReturnValueOnce(secret);

      // action
      const result = await serviceProviderService.findById(id);

      // assert
      expect(serviceProviderRepository.findOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.findOne).toHaveBeenCalledWith(id);
      expect(secretManagerMocked.decrypt).toHaveBeenCalledTimes(1);
      expect(secretManagerMocked.decrypt).toHaveBeenCalledWith(secretCipher);
      expect(result).toEqual({
        ...serviceProvider,
        client_secret: secret,
      });
    });
  });

  describe('update', () => {
    it('should update with all data', async () => {
      const dataToUpdate = {
        name: 'monfs',
        signupId: '123456',
        redirectUri: ['https://monfs.com'],
        redirectUriLogout: ['https://monfs.com/logout'],
        site: 'https://monfs.com',
        ipAddresses: ['192.0.0.0'],
        emails: ['v@b.com'],
        active: true,
        type: 'private',
        scopes: ['seldon', 'daneel'],
        trustedIdentity: false,
        eidas: 1,
      };

      const id = '5d4d6d29bbdfbd203da312f2';

      serviceProviderRepository.findOne.mockImplementationOnce(() =>
        Promise.resolve({
          name: 'franceConnect',
          signupId: '123456',
          redirectUri: ['https://franceConnect.com'],
          redirectUriLogout: ['https://franceConnect.com/logout'],
          site: 'https://franceConnect.com',
          ipAddresses: ['192.0.0.0'],
          emails: ['v@b2.com'],
          active: true,
          type: 'private',
          scopes: ['toto', 'tutu'],
          trustedIdentity: false,
          eidas: 1,
        }),
      );

      await serviceProviderService.update(id, dataToUpdate);
      expect(serviceProviderRepository.findOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
    });

    it('should update a document with only arrayLike ( emails, ips, redirectUris and postRedirectUris) as updated data', async () => {
      const dataToUpdate = {
        name: 'franceConnect',
        signupId: '123456',
        redirectUri: ['https://toto.com'],
        redirectUriLogout: ['https://toto.com/logout'],
        site: 'https://toto.com',
        ipAddresses: ['192.0.0.0'],
        emails: ['v@b.com'],
        active: true,
        type: 'private',
        scopes: ['seldon', 'daneel'],
        trustedIdentity: false,
        eidas: 1,
      };

      const id = '5d4d6d29bbdfbd203da312f2';

      serviceProviderRepository.findOne.mockImplementationOnce(() =>
        Promise.resolve({
          name: 'franceConnect',
          signupId: '123456',
          redirectUri: ['https://franceConnect.com'],
          redirectUriLogout: ['https://franceConnect.com/logout'],
          site: 'https://franceConnect.com',
          ipAddresses: ['192.0.0.0'],
          emails: ['v@b2.com'],
          active: true,
          type: 'private',
          scopes: ['toto', 'tutu'],
          trustedIdentity: false,
          eidas: 1,
        }),
      );

      await serviceProviderService.update(id, dataToUpdate);
      expect(serviceProviderRepository.findOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
    });

    it('should update a document with only stringLike (name) as updated data', async () => {
      const dataToUpdate = {
        name: 'monfs',
        signupId: '123456',
        redirectUri: ['https://franceConnect.com'],
        redirectUriLogout: ['https://franceConnect.com/logout'],
        site: 'https://franceConnect.com',
        ipAddresses: ['192.0.0.0'],
        emails: ['v@b.com'],
        active: true,
        type: 'private',
        scopes: ['seldon', 'daneel'],
        trustedIdentity: true,
        eidas: 1,
      };

      const id = '5d4d6d29bbdfbd203da312f2';

      serviceProviderRepository.findOne.mockImplementationOnce(() =>
        Promise.resolve({
          name: 'franceConnect',
          signupId: '123456',
          redirectUri: ['https://franceConnect.com'],
          redirectUriLogout: ['https://franceConnect.com/logout'],
          site: 'https://franceConnect.com',
          ipAddresses: ['192.0.0.0'],
          emails: ['v@b2.com'],
          active: true,
          type: 'private',
          scopes: ['toto', 'tutu'],
          trustedIdentity: false,
          eidas: 1,
        }),
      );

      await serviceProviderService.update(id, dataToUpdate);
      expect(serviceProviderRepository.findOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
    });

    it('should update with no signupId, redirectUri, redirectUriLogout, site, ipAddresses, emails', async () => {
      const dataToUpdate = {
        name: 'monfs',
        signupId: '',
        redirectUri: '',
        redirectUriLogout: '',
        site: '',
        ipAddresses: '',
        emails: '',
        active: true,
        type: 'private',
        scopes: ['seldon', 'daneel'],
        trustedIdentity: false,
        eidas: 1,
      };

      const id = '5d4d6d29bbdfbd203da312f2';

      serviceProviderRepository.findOne.mockImplementationOnce(() =>
        Promise.resolve({
          name: 'franceConnect',
          signupId: '123456',
          redirectUri: ['https://franceConnect.com'],
          redirectUriLogout: ['https://franceConnect.com/logout'],
          site: 'https://franceConnect.com',
          ipAddresses: ['192.0.0.0'],
          emails: ['v@b2.com'],
          active: true,
          type: 'private',
          scopes: ['toto', 'tutu'],
          trustedIdentity: false,
          eidas: 1,
        }),
      );

      await serviceProviderService.update(id, dataToUpdate);
      expect(serviceProviderRepository.findOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
    });

    it('should update logo', async () => {
      const dataToUpdate = {
        name: 'franceConnect',
        signupId: '123456',
        redirectUri: ['https://franceConnect.com'],
        redirectUriLogout: ['https://franceConnect.com/logout'],
        site: 'https://franceConnect.com',
        ipAddresses: ['192.0.0.0'],
        emails: ['v@b2.com'],
        active: true,
        type: 'private',
        scopes: ['toto', 'tutu'],
        trustedIdentity: false,
        eidas: 1,
        logo: 'updatedLogoName',
      };

      const id = '5d4d6d29bbdfbd203da312f2';

      serviceProviderRepository.findOne.mockImplementationOnce(() =>
        Promise.resolve({
          name: 'franceConnect',
          signupId: '123456',
          redirectUri: ['https://franceConnect.com'],
          redirectUriLogout: ['https://franceConnect.com/logout'],
          site: 'https://franceConnect.com',
          ipAddresses: ['192.0.0.0'],
          emails: ['v@b2.com'],
          active: true,
          type: 'private',
          scopes: ['toto', 'tutu'],
          trustedIdentity: false,
          eidas: 1,
          logo: 'oldLogoName',
        }),
      );

      await serviceProviderService.updateLogo(id, 'updatedLogoName');

      expect(serviceProviderRepository.findOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.save).toHaveBeenCalledWith(dataToUpdate);
    });
  });

  describe('delete service provider by key', () => {
    it('calls the delete function of the serviceProviderRepository with a string as argument', async () => {
      // set up
      const key = { key: '123' };
      const expectedRepositoryDeleteArguments = { key: '123' };
      // action
      await serviceProviderService.deleteServiceProviderByKey(key);
      // assertion
      expect(serviceProviderRepository.delete).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.delete).toHaveBeenCalledWith(
        expectedRepositoryDeleteArguments,
      );
    });

    it('calls the delete function of the serviceProviderRepository with an array of string as argument', async () => {
      // set up
      const clientsId = [{ key: 'aaaa' }, { key: 'bbbb' }, { key: 'cccc' }];
      const expectedRepositoryDeleteArguments = [
        { key: 'aaaa' },
        { key: 'bbbb' },
        { key: 'cccc' },
      ];
      // action
      await serviceProviderService.deleteServiceProviderByKey(clientsId);
      // assertion
      expect(serviceProviderRepository.delete).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.delete).toHaveBeenCalledWith(
        expectedRepositoryDeleteArguments,
      );
    });
  });

  describe('generate a new client secret', () => {
    it('should generate a new client secret with hsm', async () => {
      const id = '5d4d6d29bbdfbd203da312f2';

      serviceProviderRepository.findOne.mockImplementationOnce(() =>
        Promise.resolve({
          name: 'franceConnect',
          signupId: '123456',
          redirectUri: ['https://franceConnect.com'],
          redirectUriLogout: ['https://franceConnect.com/logout'],
          site: 'https://franceConnect.com',
          ipAddresses: ['192.0.0.0'],
          emails: ['v@b2.com'],
          active: true,
          type: 'private',
          key: 'bafe2428-3ab9-4c44-9021-46bde0cd13c5',
          client_secret:
            '$2b$10$EO3FnI3YKfnnvUlvr084wegEgEPeRPRMdE2VJwMHpAsNkaMv1n9pG',
          trustedIdentity: false,
          eidas: 1,
        }),
      );

      configServiceMock.get.mockReturnValue({ use_hsm: 'true' });

      await serviceProviderService.generateNewSecret(id, 'user');

      expect(secretAdapterMock.generateSecret).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.findOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
    });

    it('should generate a new client secret without hsm', async () => {
      const id = '5d4d6d29bbdfbd203da312f2';

      serviceProviderRepository.findOne.mockResolvedValueOnce({
        name: 'franceConnect',
        signupId: '123456',
        redirectUri: ['https://franceConnect.com'],
        redirectUriLogout: ['https://franceConnect.com/logout'],
        site: 'https://franceConnect.com',
        ipAddresses: ['192.0.0.0'],
        emails: ['v@b2.com'],
        active: true,
        type: 'private',
        key: 'bafe2428-3ab9-4c44-9021-46bde0cd13c5',
        client_secret:
          '$2b$10$EO3FnI3YKfnnvUlvr084wegEgEPeRPRMdE2VJwMHpAsNkaMv1n9pG',
        trustedIdentity: false,
        eidas: 1,
      });

      configServiceMock.get.mockReturnValue({ use_hsm: 'false' });

      await serviceProviderService.generateNewSecret(id, 'user');

      expect(secretAdapterMock.generateSecret).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.findOne).toHaveBeenCalledTimes(1);
      expect(serviceProviderRepository.save).toHaveBeenCalledTimes(1);
    });
  });
});
