import {
  Controller,
  Get,
  Render,
  Post,
  Body,
  UseInterceptors,
  UsePipes,
  Req,
  Res,
  Param,
  Query,
  Put,
  Delete,
  ValidationPipe,
  Patch,
  UploadedFile,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { memoryStorage } from 'multer';
import { InjectRepository } from '@nestjs/typeorm';
import { ServiceProvider } from './service-provider.entity';
import { Roles } from '@fc/shared/authentication/decorator/roles.decorator';
import { UserRole } from '@fc/shared/user/roles.enum';
import { FormErrorsInterceptor } from '@fc/shared/form/interceptor/form-errors.interceptor';
import { ServiceProviderService } from './service-provider.service';
import { IServiceProvider } from './interface/service-provider.interface';
import { CustomValidationPipe } from '../pipe/custom-validation.pipe';
import { ServiceProviderDTO } from './dto/service-provider-input.dto';
import { Repository } from 'typeorm';
import { DeleteServiceProviderDto } from './dto/delete-service-provider.dto';
import { GenerateNewClientSecretDTO } from './dto/generate-new-client-secret.dto';
import { UpdateServiceProviderLogoInputDto } from './dto/update-service-provider-logo-input.dto';
import { DeleteServiceProviderLogoInputDto } from './dto/delete-service-provider-logo-input.dto';
import { IDeleteServiceProvider } from './interface/delete-service-provider.interface';
import { FileStorageService } from '../file-storage/file-storage.service';
import { FileStorage } from '../file-storage/file-storage.entity';

const multerLogoOptions = {
  storage: memoryStorage(),
  limits: {
    fileSize: 1024 * 1024, // 1MB
    files: 1,
  },
  fileFilter: (req, file, cb) => {
    if (!file.mimetype.match(/image\/(?:png|jpe?g|gif|svg\+xml)/i)) {
      req.flash('errors', { logo: ['Le format du logo fourni est incorrect'] });
      req.flash('values', req.body);
      return cb(null, false);
    }
    return cb(null, true);
  },
};

@Controller('service-provider')
export class ServiceProviderController {
  constructor(
    @InjectRepository(ServiceProvider, 'fc-mongo')
    private readonly serviceProviderRepository: Repository<ServiceProvider>,
    private readonly serviceProviderService: ServiceProviderService,
    private readonly fileStorage: FileStorageService,
  ) {}

  @Get()
  @Roles(UserRole.OPERATOR)
  @Render('service-provider/list')
  async list(
    @Req() req,
    @Query('page') pageQuery: string = '0',
    @Query('limit') limitQuery: string = '10',
  ) {
    const activeServiceProvidersCount = await this.serviceProviderRepository.count(
      { active: true },
    );
    const page = parseInt(pageQuery, 10);
    const limit = parseInt(limitQuery, 10);

    const serviceProviders = await this.serviceProviderService.paginate({
      page,
      limit,
      route: '/service-provider',
    });
    const csrfToken = req.csrfToken();

    return {
      pages: serviceProviders.pageCount,
      next: serviceProviders.next,
      previous: serviceProviders.previous,
      serviceProviders: serviceProviders.items,
      activeServiceProvidersCount,
      csrfToken,
    };
  }

  @Get('create')
  @Render('service-provider/creation')
  @Roles(UserRole.OPERATOR)
  showCreationForm(@Req() req) {
    const csrfToken = req.csrfToken();
    return { csrfToken };
  }

  @Post('create')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor(`/service-provider/create`))
  @UseInterceptors(FileInterceptor('logo', multerLogoOptions))
  @UsePipes(CustomValidationPipe)
  async createServiceProvider(
    @Body() createServiceProviderDto: ServiceProviderDTO,
    @Req() req,
    @Res() res,
    @UploadedFile() logo,
  ) {
    try {
      const serviceProvider: IServiceProvider = createServiceProviderDto as IServiceProvider;

      /**
       * if logo is not defined but we have an error to flash, then it means
       * that a file has been provided but the format was incorrect.
       * Therefor, we let the flow continue.
       * This is because an incorrect format was (Cf. multer, "fileFilter")
       * will return an "undefined" value for "logo".
       */
      if (logo) {
        const uploadResult: any = await this.fileStorage.storeFile(logo);

        // Update the service provider with the logo id to retreive it later
        serviceProvider.logo = uploadResult.filename;
      } else if (req.session.flash.errors) {
        return res.redirect(`${res.locals.APP_ROOT}/service-provider/create`);
      }

      await this.serviceProviderService.createServiceProvider(serviceProvider);
    } catch (error) {
      req.flash(
        'globalError',
        "Impossible d'enregistrer le fournisseur de service",
      );
      req.flash('values', req.body);
      return res.redirect(`${res.locals.APP_ROOT}/service-provider/create`);
    }
    req.flash(
      'success',
      `Le fournisseur de service ${createServiceProviderDto.name} a été créé avec succès !`,
    );
    return res.redirect(`${res.locals.APP_ROOT}/`);
  }

  @Get(':id')
  @Roles(UserRole.OPERATOR)
  @Render('service-provider/update')
  async findOne(@Param('id') id, @Req() req, @Res() res) {
    const csrfToken = req.csrfToken();

    const serviceProvider = await this.serviceProviderService.findById(id);
    const logoAsDataUri = await this.fileStorage.getFileAsDataUri(
      serviceProvider.logo,
    );

    const output = {
      ...serviceProvider,
      redirectUri: this.AddCarriageReturn(serviceProvider.redirect_uris),
      ipsRanges: this.AddCarriageReturn(
        serviceProvider.IPServerAddressesAndRanges,
      ),
      postLogoutUri: this.AddCarriageReturn(
        serviceProvider.post_logout_redirect_uris,
      ),
      emails: this.AddCarriageReturn(serviceProvider.email),
      logoAsDataUri,
    };

    /**
     * We want to send to the view all the fields that the user
     * has updated if there was an error plus all the fields
     * that were not updated.
     */
    if (req.session.flash && req.session.flash.errors) {
      Object.assign(req.session.flash.values[0], output);
    } else {
      req.flash('values', output);
    }

    return {
      csrfToken,
      id,
    };
  }

  @Patch(':id')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor(`/service-provider/:id`))
  @UsePipes(CustomValidationPipe)
  async serviceProviderUpdate(
    @Body() serviceProviderUpdate: ServiceProviderDTO,
    @Param('id') id,
    @Req() req,
    @Res() res,
  ) {
    try {
      await this.serviceProviderService.update(id, serviceProviderUpdate);
    } catch (error) {
      req.flash('globalError', 'Impossible de mettre à jour le FS');
      return res.redirect(`${res.locals.APP_ROOT}/service-provider/${id}`);
    }
    req.flash(
      'success',
      `Le fournisseur de service ${serviceProviderUpdate.name} a été modifié avec succès !`,
    );
    return res.redirect(`${res.locals.APP_ROOT}/service-provider/${id}`);
  }

  @Put(':id/logo')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor(`/service-provider/:id`))
  @UseInterceptors(FileInterceptor('logo', multerLogoOptions))
  @UsePipes(ValidationPipe)
  async serviceProviderUpdateLogo(
    @Body() logoUpdate: UpdateServiceProviderLogoInputDto,
    @Param('id') id,
    @Req() req,
    @Res() res,
    @UploadedFile() logo,
  ) {
    try {
      const uploadResult: any = await this.fileStorage.storeFile(logo);

      await this.serviceProviderService.updateLogo(id, uploadResult.filename);

      // Remove the current logo from GridFS
      await this.fileStorage.deleteFile(logoUpdate.currentLogo);
    } catch (error) {
      req.flash('globalError', 'Impossible de mettre à jour le logo');
      return res.redirect(`${res.locals.APP_ROOT}/service-provider/${id}`);
    }
    req.flash('success', `Le logo du fournisseur a été modifié avec succès !`);
    return res.redirect(`${res.locals.APP_ROOT}/service-provider/${id}`);
  }

  @Delete(':id/logo')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor(`/service-provider/:id`))
  @UsePipes(ValidationPipe)
  async serviceProviderDeleteLogo(
    @Body() logoDelete: DeleteServiceProviderLogoInputDto,
    @Param('id') id,
    @Req() req,
    @Res() res,
    @UploadedFile() logo,
  ) {
    try {
      // Remove the current logo from the service provider
      await this.serviceProviderService.deleteLogo(id);

      // Remove the logo from GridFS
      await this.fileStorage.deleteFile(logoDelete.currentLogo);
    } catch (error) {
      req.flash('globalError', 'Impossible de supprimer le logo');
      return res.redirect(`${res.locals.APP_ROOT}/service-provider/${id}`);
    }
    req.flash('success', `Le logo du fournisseur a été supprimé avec succès !`);
    return res.redirect(`${res.locals.APP_ROOT}/service-provider/${id}`);
  }

  @Delete(':key')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor('/service-provider'))
  async deleteServiceProvider(
    @Param('key') key: string,
    @Req() req,
    @Res() res,
    @Body() body,
  ) {
    try {
      await this.serviceProviderService.deleteServiceProviderByKey({
        key,
      });
    } catch (error) {
      req.flash('globalError', error.message);
      return res.status(500);
    }
    req.flash(
      'success',
      `Le fournisseur de service ${body.name} a été supprimé avec succès !`,
    );
    return res.redirect(`${res.locals.APP_ROOT}/service-provider`);
  }

  @Post('delete')
  @Roles(UserRole.OPERATOR)
  @UsePipes(new ValidationPipe({ transform: true }))
  @UseInterceptors(new FormErrorsInterceptor('/service-provider'))
  async deleteServiceProviders(
    @Body() deleteServiceProviderDto: DeleteServiceProviderDto,
    @Res() res,
    @Req() req,
  ) {
    try {
      const itemsTodelete: IDeleteServiceProvider[] = [];
      for (const key of deleteServiceProviderDto.deleteItems) {
        itemsTodelete.push({ key });
      }
      await this.serviceProviderService.deleteServiceProviderByKey(
        itemsTodelete,
      );
    } catch (error) {
      req.flash('globalError', error.message);
      return res.status(500);
    }
    req.flash(
      'success',
      `Les fournisseurs de service ${deleteServiceProviderDto.name} ont été supprimés avec succès !`,
    );
    return res.redirect(`${res.locals.APP_ROOT}/service-provider`);
  }

  @Get('update/:id/secret')
  @Roles(UserRole.OPERATOR)
  @Render('service-provider/generate-new-client-secret')
  async generateNewSecret(@Param('id') id: string, @Req() req, @Res() res) {
    const csrfToken = req.csrfToken();

    /**
     * If we have an error to flash, we want to render the last user inputs,
     * not the service-provider in database.
     */
    if (req.session.flash && req.session.flash.errors) {
      return {
        csrfToken,
        id,
      };
    }

    const serviceProvider = await this.serviceProviderService.findById(id);
    return {
      csrfToken,
      id,
      messages: {
        values: [serviceProvider],
      },
    };
  }

  @Patch('update/:id/secret')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(
    new FormErrorsInterceptor('/service-provider/update/:id/secret'),
  )
  async generateNewClientSecret(
    @Param('id') id: string,
    @Body() generateNewClientSecretDTO: GenerateNewClientSecretDTO,
    @Req() req,
    @Res() res,
  ) {
    try {
      await this.serviceProviderService.generateNewSecret(id);
    } catch (error) {
      req.flash('gobalError', error);
      return res.status(500);
    }

    req.flash(
      'success',
      `Le nouveau client secret du fournisseur de service ${generateNewClientSecretDTO.name} a été généré avec succés !`,
    );

    return res.redirect(`${res.locals.APP_ROOT}/service-provider`);
  }

  private AddCarriageReturn(input: string[]) {
    if (Array.isArray(input)) {
      return input.join('\r\n');
    }
    return input;
  }
}
