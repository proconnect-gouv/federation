import {
  Controller,
  Get,
  Render,
  Post,
  Body,
  UseInterceptors,
  UsePipes,
  Req,
  Res,
  Param,
  Query,
  Put,
  Delete,
  ValidationPipe,
} from '@nestjs/common';
import { ServiceProvider } from './service-provider.entity';
import { InjectRepository } from '@nestjs/typeorm';
import { Roles } from '@fc/shared/authentication/decorator/roles.decorator';
import { UserRole } from '@fc/shared/user/roles.enum';
import { FormErrorsInterceptor } from '@fc/shared/form/interceptor/form-errors.interceptor';
import { ServiceProviderService } from './service-provider.service';
import { IServiceProvider } from './interface/service-provider.interface';
import { CustomValidationPipe } from '../pipe/custom-validation.pipe';
import { ServiceProviderDTO } from './dto/service-provider-input.dto';
import { Repository } from 'typeorm';
import { DeleteServiceProviderDto } from './dto/delete-service-provider.dto';
import { IDeleteServiceProvider } from './interface/delete-service-provider.interface';

@Controller('service-provider')
export class ServiceProviderController {
  constructor(
    @InjectRepository(ServiceProvider, 'fc-mongo')
    private readonly serviceProviderRepository: Repository<ServiceProvider>,
    private readonly serviceProviderService: ServiceProviderService,
  ) {}

  @Get()
  @Roles(UserRole.OPERATOR)
  @Render('service-provider/list')
  async list(
    @Req() req,
    @Query('page') pageQuery: string = '0',
    @Query('limit') limitQuery: string = '10',
  ) {
    const activeServiceProvidersCount = await this.serviceProviderRepository.count(
      { active: true },
    );
    const page = parseInt(pageQuery, 10);
    const limit = parseInt(limitQuery, 10);

    const serviceProviders = await this.serviceProviderService.paginate({
      page,
      limit,
      route: '/service-provider',
    });
    const csrfToken = req.csrfToken();
    return {
      pages: serviceProviders.pageCount,
      next: serviceProviders.next,
      previous: serviceProviders.previous,
      serviceProviders: serviceProviders.items,
      activeServiceProvidersCount,
      csrfToken,
    };
  }

  @Get('create')
  @Render('service-provider/creation')
  @Roles(UserRole.OPERATOR)
  showCreationForm(@Req() req) {
    const csrfToken = req.csrfToken();
    return { csrfToken };
  }

  @Post('create')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor(`/service-provider/create`))
  @UsePipes(CustomValidationPipe)
  async createServiceProvider(
    @Body() createServiceProviderDto: ServiceProviderDTO,
    @Req() req,
    @Res() res,
  ) {
    try {
      await this.serviceProviderService.createServiceProvider(
        createServiceProviderDto as IServiceProvider,
      );
    } catch (error) {
      req.flash('globalError', error);
      return res.redirect(`${res.locals.APP_ROOT}/service-provider/create`);
    }
    req.flash(
      'success',
      `Le fournisseur de service ${createServiceProviderDto.name} a été créé avec succès !`,
    );
    return res.redirect(`${res.locals.APP_ROOT}/`);
  }

  @Get(':id')
  @Roles(UserRole.OPERATOR)
  @Render('service-provider/update')
  async findOne(@Param('id') id, @Req() req, @Res() res) {
    const csrfToken = req.csrfToken();

    /**
     * If we have an error to flash, we want to render the last user inputs,
     * not the service-provider in database.
     */
    if (req.session.flash && req.session.flash.errors) {
      return {
        csrfToken,
        id,
      };
    }

    const serviceProvider = await this.serviceProviderService.findById(id);

    return {
      csrfToken,
      id,
      messages: {
        values: [
          {
            ...serviceProvider,
            redirectUri: this.AddCarriageReturn(serviceProvider.redirect_uris),
            ipsRanges: this.AddCarriageReturn(
              serviceProvider.IPServerAddressesAndRanges,
            ),
            postLogoutUri: this.AddCarriageReturn(
              serviceProvider.post_logout_redirect_uris,
            ),
            emails: this.AddCarriageReturn(serviceProvider.email),
          },
        ],
      },
    };
  }

  @Post('update/:id')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor(`/service-provider/:id`))
  @UsePipes(CustomValidationPipe)
  async serviceProviderUpdate(
    @Body() serviceProviderUpdate: ServiceProviderDTO,
    @Req() req,
    @Res() res,
  ) {
    try {
      await this.serviceProviderService.update(
        serviceProviderUpdate.clientId,
        serviceProviderUpdate,
      );
    } catch (error) {
      req.flash('globalError', error);
      return res.redirect(
        `${res.locals.APP_ROOT}/service-provider/${req.params.id}`,
      );
    }
    req.flash(
      'success',
      `Le fournisseur de service ${serviceProviderUpdate.name} a été modifié avec succès !`,
    );
    return res.redirect(`${res.locals.APP_ROOT}/`);
  }

  @Delete(':key')
  @Roles(UserRole.OPERATOR)
  async deleteServiceProvider(
    @Param('key') key: string,
    @Req() req,
    @Res() res,
    @Body() body,
  ) {
    try {
      await this.serviceProviderService.deleteServiceProviderByKey({
        key,
      });
    } catch (error) {
      return res.status(500);
    }
    req.flash(
      'success',
      `Le fournisseur de service ${body.name} a été supprimé avec succès !`,
    );
    return res.redirect(`${res.locals.APP_ROOT}/service-provider`);
  }

  @Post('delete')
  @Roles(UserRole.OPERATOR)
  @UsePipes(new ValidationPipe({ transform: true }))
  async deleteServiceProviders(
    @Body() deleteServiceProviderDto: DeleteServiceProviderDto,
    @Res() res,
    @Req() req,
  ) {
    try {
      const itemsTodelete: IDeleteServiceProvider[] = [];
      for (const key of deleteServiceProviderDto.deleteItems) {
        itemsTodelete.push({ key });
      }
      await this.serviceProviderService.deleteServiceProviderByKey(
        itemsTodelete,
      );
    } catch (error) {
      return res.status(500);
    }
    req.flash(
      'success',
      `Les fournisseurs de service ${deleteServiceProviderDto.name} ont été supprimés avec succès !`,
    );
    return res.redirect(`${res.locals.APP_ROOT}/service-provider`);
  }
  private AddCarriageReturn(input: string[]) {
    if (Array.isArray(input)) {
      return input.join('\r\n');
    }
    return input;
  }
}
