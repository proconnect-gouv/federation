import { Test } from '@nestjs/testing';
import { ServiceProviderController } from './service-provider.controller';
import { getRepositoryToken, TypeOrmModule } from '@nestjs/typeorm';
import { ObjectID } from 'mongodb';
import { ServiceProvider } from './service-provider.entity';
import { ServiceProviderService } from './service-provider.service';
import { ConfigService } from 'nestjs-config';
import { Pagination } from 'nestjs-typeorm-paginate';

describe('ServiceProviderController', () => {
  let serviceProviderController: ServiceProviderController;
  let service: ServiceProviderService;
  const serviceProviderRepository = {
    count: jest.fn(),
    findAndCount: jest.fn(),
    find: jest.fn(),
  };

  const serviceProviderService = {
    createServiceProvider: jest.fn(),
    paginate: jest.fn(),
    findById: jest.fn(),
    update: jest.fn(),
  };

  const renderMock = {
    render: jest.fn(),
  };

  const res = {
    redirect: jest.fn(),
    status: jest.fn(),
    locals: {
      APP_ROOT: '/foo/bar',
    },
  };

  const ServiceProviderDto = {
    title: 'monfs',
    name: 'monfs',
    redirectUri: { result: ['https://url.com'] },
    redirectUriLogout: { result: ['https://url.com/logout'] },
    site: 'https:/monsite.com',
    emails: { result: ['v@b.com'] },
    ipAddresses: { result: ['192.0.0.0'] },
    active: true,
    type: 'public',
  };

  const expectedResultAfterTransformation = {
    title: 'monfs',
    name: 'monfs',
    redirectUri: ['https://url.com'],
    redirectUriLogout: ['https://url.com/logout'],
    site: 'https:/monsite.com',
    emails: ['v@b.com'],
    ipAddresses: ['192.0.0.0'],
    active: true,
    type: 'public',
  };

  const req = {
    flash: jest.fn(),
    user: {
      id: '05e4fadf-fda6-4ad8-ae75-b7f315843827',
    },
    csrfToken: function csrfToken() {
      return 'mygreatcsrftoken';
    },
  };

  const configService = {
    get: jest.fn(),
  };

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [TypeOrmModule.forFeature([ServiceProvider], 'fc-mongo')],
      providers: [
        ServiceProviderController,
        ServiceProviderService,
        ConfigService,
      ],
    })
      .overrideProvider(getRepositoryToken(ServiceProvider, 'fc-mongo'))
      .useValue(serviceProviderRepository)
      .overrideProvider(ServiceProviderService)
      .useValue(serviceProviderService)
      .overrideProvider(ConfigService)
      .useValue(configService)
      .compile();

    serviceProviderController = await module.get<ServiceProviderController>(
      ServiceProviderController,
    );

    service = await module.get<ServiceProviderService>(ServiceProviderService);

    jest.resetAllMocks();

    renderMock.render.mockReturnValueOnce(true);
    res.status.mockReturnValueOnce(renderMock);
  });

  describe('list method', () => {
    it('returns the list of the available service providers', async () => {
      // Setup
      const page = '0';
      const limit = '10';

      // Mocking item id
      const itemId: ObjectID = new ObjectID('5d35b91e70332098440d0f85');

      // Mocking Items
      const itemTest1: ServiceProvider = {
        id: itemId,
        name: 'users',
        title: 'Site Usagers',
        redirect_uris: ['https://url.com'],
        post_logout_redirect_uris: [''],
        site: 'https:/monsite.com',
        email: ['v@b.com'],
        IPServerAddressesAndRanges: ['192.0.0.0'],
        active: true,
        type: 'public',
        secretCreatedAt: new Date(),
        secret_hash: '76eded44d32b40c0cb1006065',
        key: '6925fb8143c76eded44d32b40c0cb1006065f7f003de52712b78985704f39950',
      };

      const itemTest2: ServiceProvider = {
        id: itemId,
        name: 'users',
        title: 'Site Usagers',
        redirect_uris: ['https://url.com'],
        post_logout_redirect_uris: [''],
        site: 'https:/monsite.com',
        email: ['v@b.com'],
        IPServerAddressesAndRanges: ['192.0.0.0'],
        active: true,
        type: 'public',
        secretCreatedAt: new Date(),
        secret_hash: '76eded44d32b40c0cb1006065',
        key: '6925fb8143c76eded44d32b40c0cb1006065f7f003de52712b78985704f39950',
      };

      const itemTest3: ServiceProvider = {
        id: itemId,
        name: 'users',
        title: 'Site Usagers',
        redirect_uris: ['https://url.com'],
        post_logout_redirect_uris: [''],
        site: 'https:/monsite.com',
        email: ['v@b.com'],
        IPServerAddressesAndRanges: ['192.0.0.0'],
        active: true,
        type: 'public',
        secretCreatedAt: new Date(),
        secret_hash: '76eded44d32b40c0cb1006065',
        key: '6925fb8143c76eded44d32b40c0cb1006065f7f003de52712b78985704f39950',
      };

      // Mocking return value of serviceProviderController.list(page, limit)
      const serviceProvidersResult = {
        items: [itemTest1, itemTest2, itemTest3],
        itemCount: 3,
        totalItems: 3,
        pageCount: 0,
        next: '',
        previous: '',
      };

      // Actions
      // Mocking the return of the paginate function
      const result: Promise<Pagination<ServiceProvider>> = Promise.resolve(
        serviceProvidersResult,
      );

      const spy = jest
        .spyOn(service, 'paginate')
        .mockImplementation(() => Promise.resolve(result));

      // Calling the list function
      const resultat = await serviceProviderController.list(req, page, limit);

      // Expected
      expect(resultat.pages).toEqual(0);
      expect(resultat.serviceProviders.length).toEqual(3);
    });

    it('call repository with active true', async () => {
      const mockedCount = 10;
      /// const result = serviceProviderRepository.count.mockResolvedValueOnce(mockedCount);

      // Mocking item id
      const itemId: ObjectID = new ObjectID('5d35b91e70332098440d0f85');

      // Mocking Items
      const itemTest1: ServiceProvider = {
        id: itemId,
        name: 'users',
        title: 'Site Usagers',
        redirect_uris: ['https://url.com'],
        post_logout_redirect_uris: [''],
        site: 'https:/monsite.com',
        email: ['v@b.com'],
        IPServerAddressesAndRanges: ['192.0.0.0'],
        active: true,
        type: 'public',
        secretCreatedAt: new Date(),
        secret_hash: '76eded44d32b40c0cb1006065',
        key: '6925fb8143c76eded44d32b40c0cb1006065f7f003de52712b78985704f39950',
      };

      const itemTest2: ServiceProvider = {
        id: itemId,
        name: 'users',
        title: 'Site Usagers',
        redirect_uris: ['https://url.com'],
        post_logout_redirect_uris: [''],
        site: 'https:/monsite.com',
        email: ['v@b.com'],
        IPServerAddressesAndRanges: ['192.0.0.0'],
        active: true,
        type: 'public',
        secretCreatedAt: new Date(),
        secret_hash: '76eded44d32b40c0cb1006065',
        key: '6925fb8143c76eded44d32b40c0cb1006065f7f003de52712b78985704f39950',
      };

      const itemTest3: ServiceProvider = {
        id: itemId,
        name: 'users',
        title: 'Site Usagers',
        redirect_uris: ['https://url.com'],
        post_logout_redirect_uris: [''],
        site: 'https:/monsite.com',
        email: ['v@b.com'],
        IPServerAddressesAndRanges: ['192.0.0.0'],
        active: true,
        type: 'public',
        secretCreatedAt: new Date(),
        secret_hash: '76eded44d32b40c0cb1006065',
        key: '6925fb8143c76eded44d32b40c0cb1006065f7f003de52712b78985704f39950',
      };

      // Mocking return value of serviceProviderController.list(page, limit)
      const serviceProvidersResult = {
        items: [itemTest1, itemTest2, itemTest3],
        itemCount: 3,
        totalItems: 3,
        pageCount: 0,
        next: '',
        previous: '',
      };

      const result: Promise<Pagination<ServiceProvider>> = Promise.resolve(
        serviceProvidersResult,
      );

      const spy = jest
        .spyOn(service, 'paginate')
        .mockImplementation(() => Promise.resolve(result));

      const data = await serviceProviderController.list(req, '0', '10');

      expect(serviceProviderRepository.count).toHaveBeenCalledWith({
        active: true,
      });
    });
  });

  describe('createUser', () => {
    it('redirects the user when a valid user is provided', async () => {
      await serviceProviderController.createServiceProvider(
        ServiceProviderDto,
        req,
        res,
      );
      expect(res.redirect).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith('/foo/bar/');
    });

    it('uses the user service to create users', async () => {
      await serviceProviderController.createServiceProvider(
        ServiceProviderDto,
        req,
        res,
      );

      expect(
        serviceProviderService.createServiceProvider,
      ).toHaveBeenCalledTimes(1);
      expect(serviceProviderService.createServiceProvider).toHaveBeenCalledWith(
        expectedResultAfterTransformation,
      );
    });
    it('should not redirect the user but set the res status to 400 for the error handler', async () => {
      // set up
      serviceProviderService.createServiceProvider = jest.fn(() => {
        throw Error;
      });
      // action
      await serviceProviderController.createServiceProvider(
        ServiceProviderDto,
        req,
        res,
      );
      // assertion
      expect(res.status).toHaveBeenCalledWith(400);
      expect(renderMock.render).toHaveBeenCalledWith(
        'service-provider/creation',
        {
          values: ServiceProviderDto,
          globalError: Error,
          csrfToken: 'mygreatcsrftoken',
        },
      );
      expect(
        serviceProviderService.createServiceProvider,
      ).toHaveBeenCalledTimes(1);
    });
  });

  describe('get a service provider', () => {
    it('should get a service Provider and render update view', async () => {
      const id = '5d4d6d29bbdfbd203da312f2';
      const serviceProvider = {
        name: 'FranceConnect TEST 9',
        title: 'FranceConnect TEST 9',
        redirect_uris: ['https://FranceConnect.com'],
        post_logout_redirect_uris: ['https://FranceConnect.com'],
        site: 'https://FranceConnect8888.com',
        status: 'public',
        email: ['v@b.com'],
        active: 'true',
        IPServerAddressesAndRanges: ['1.1.1.1'],
        key: 'cb55015c-7fb5-49b4-9006-e523552bc3e7',
      };

      serviceProviderService.findById.mockImplementation(() =>
        Promise.resolve(serviceProvider),
      );

      const result = await serviceProviderController.findOne(id, req, res);
      expect(result).toEqual({
        serviceProvider,
        redirectUri: 'https://FranceConnect.com',
        IPServerAddressesAndRanges: '1.1.1.1',
        post_logout_redirect_uris: 'https://FranceConnect.com',
        emails: 'v@b.com',
        csrfToken: 'mygreatcsrftoken',
      });
    });
  });

  describe('serviceProviderUpdate', () => {
    it('should update a servicerProvider and return to index page', async () => {
      await serviceProviderController.serviceProviderUpdate(
        ServiceProviderDto,
        req,
        res,
      );
      expect(res.redirect).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith('/foo/bar/');
    });
    it('should render an error 400 if we cant update the serviceProvider', async () => {
      serviceProviderService.update = jest.fn(() => {
        throw Error;
      });
      // action
      await serviceProviderController.serviceProviderUpdate(
        ServiceProviderDto,
        req,
        res,
      );
      // assertion
      expect(res.status).toHaveBeenCalledWith(400);
      expect(renderMock.render).toHaveBeenCalledWith(
        'service-provider/update',
        {
          values: ServiceProviderDto,
          globalError: Error,
          csrfToken: 'mygreatcsrftoken',
        },
      );
      expect(serviceProviderService.update).toHaveBeenCalledTimes(1);
    });
  });
});
