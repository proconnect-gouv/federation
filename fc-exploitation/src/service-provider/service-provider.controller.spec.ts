import { Test } from '@nestjs/testing';
import { ServiceProviderController } from './service-provider.controller';
import { getRepositoryToken, TypeOrmModule } from '@nestjs/typeorm';
import { ObjectID } from 'mongodb';
import { Pagination } from 'nestjs-typeorm-paginate';
import { ServiceProvider } from './service-provider.entity';
import { FileStorage } from '../file-storage/file-storage.entity';
import { ServiceProviderService } from './service-provider.service';
import { FileStorageService } from '../file-storage/file-storage.service';
import { CustomValidationPipe } from '../pipe/custom-validation.pipe';

describe('ServiceProviderController', () => {
  let serviceProviderController: ServiceProviderController;
  let service: ServiceProviderService;

  const serviceProviderRepository = {
    count: jest.fn(),
    findAndCount: jest.fn(),
    find: jest.fn(),
  };

  const fileStorageRepository = {};

  const serviceProviderService = {
    createServiceProvider: jest.fn(),
    paginate: jest.fn(),
    findById: jest.fn(),
    update: jest.fn(),
    deleteServiceProviderByKey: jest.fn(),
    generateNewSecret: jest.fn(),
    updateLogo: jest.fn(),
  };

  const fileStorageService = {
    storeFile: jest.fn(),
    deleteFile: jest.fn(),
    getFileAsDataUri: jest.fn(),
  };

  const renderMock = {
    render: jest.fn(),
  };

  const res = {
    redirect: jest.fn(),
    status: jest.fn(),
    locals: {
      APP_ROOT: '/foo/bar',
    },
  };

  const ServiceProviderDto = {
    name: 'monfs',
    redirectUri: ['https://url.com'],
    redirectUriLogout: ['https://url.com/logout'],
    site: ['https:/monsite.com'],
    emails: ['v@b.com'],
    ipAddresses: ['192.0.0.0'],
    active: true,
    type: 'public',
  };

  const idParam = '05e4fadf-fda6-4ad8-ae75-b7f315843827';

  const UpdateServiceProviderLogoInputDto = {
    currentLogo: '424242424_logo.png',
  };

  const DeleteServiceProviderLogoInputDto = UpdateServiceProviderLogoInputDto;

  const req = {
    flash: jest.fn(),
    params: { id: idParam },
    session: {},
    user: { id: idParam },
    csrfToken: function csrfToken() {
      return 'mygreatcsrftoken';
    },
  };

  const logo = {
    _id: new ObjectID('5d63959eeaf61f5938153586'),
    fieldname: 'logo',
    originalname: 'name.png',
    encoding: '7bits',
    mimetype: 'image/png',
    buffer: new Buffer('myimagebuffer'),
    size: 1024 * 1024, // 1MB
  };

  const logoAsDataUri = 'data:image/png;base64,abcd+=';

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [
        TypeOrmModule.forFeature([ServiceProvider, FileStorage], 'fc-mongo'),
      ],
      providers: [
        ServiceProviderController,
        ServiceProviderService,
        FileStorageService,
      ],
    })
      .overrideProvider(getRepositoryToken(ServiceProvider, 'fc-mongo'))
      .useValue(serviceProviderRepository)
      .overrideProvider(getRepositoryToken(FileStorage, 'fc-mongo'))
      .useValue(fileStorageRepository)
      .overrideProvider(ServiceProviderService)
      .useValue(serviceProviderService)
      .overrideProvider(FileStorageService)
      .useValue(fileStorageService)
      .overridePipe(CustomValidationPipe)
      .useValue(jest.fn())
      .compile();

    serviceProviderController = await module.get<ServiceProviderController>(
      ServiceProviderController,
    );

    service = await module.get<ServiceProviderService>(ServiceProviderService);

    jest.resetAllMocks();

    renderMock.render.mockReturnValueOnce(true);
    res.status.mockReturnValueOnce(renderMock);
  });

  describe('list method', () => {
    it('returns the list of the available service providers', async () => {
      // Setup
      const page = '0';
      const limit = '10';

      // Mocking item id
      const itemId: ObjectID = new ObjectID('5d35b91e70332098440d0f85');

      // Mocking Items
      const itemTest1: ServiceProvider = {
        id: itemId,
        name: 'Site Usagers',
        redirect_uris: ['https://url.com'],
        post_logout_redirect_uris: [''],
        site: ['https:/monsite.com'],
        email: 'v@b.com',
        IPServerAddressesAndRanges: ['192.0.0.0'],
        logo: 'logo.png',
        active: true,
        type: 'public',
        secretCreatedAt: new Date(),
        secret_hash: '76eded44d32b40c0cb1006065',
        key: '6925fb8143c76eded44d32b40c0cb1006065f7f003de52712b78985704f39950',
        createdAt: new Date(),
      };

      const itemTest2: ServiceProvider = {
        id: itemId,
        name: 'Site Usagers',
        redirect_uris: ['https://url.com'],
        post_logout_redirect_uris: [''],
        site: ['https:/monsite.com'],
        email: 'v@b.com',
        IPServerAddressesAndRanges: ['192.0.0.0'],
        logo: 'logo.png',
        active: true,
        type: 'public',
        secretCreatedAt: new Date(),
        secret_hash: '76eded44d32b40c0cb1006065',
        key: '6925fb8143c76eded44d32b40c0cb1006065f7f003de52712b78985704f39950',
        createdAt: new Date(),
      };

      const itemTest3: ServiceProvider = {
        id: itemId,
        name: 'Site Usagers',
        redirect_uris: ['https://url.com'],
        post_logout_redirect_uris: [''],
        site: ['https:/monsite.com'],
        email: 'v@b.com',
        IPServerAddressesAndRanges: ['192.0.0.0'],
        logo: 'logo.png',
        active: true,
        type: 'public',
        secretCreatedAt: new Date(),
        secret_hash: '76eded44d32b40c0cb1006065',
        key: '6925fb8143c76eded44d32b40c0cb1006065f7f003de52712b78985704f39950',
        createdAt: new Date(),
      };

      // Mocking return value of serviceProviderController.list(page, limit)
      const serviceProvidersResult = {
        items: [itemTest1, itemTest2, itemTest3],
        itemCount: 3,
        totalItems: 3,
        pageCount: 0,
        next: '',
        previous: '',
      };

      // Actions
      // Mocking the return of the paginate function
      const result: Promise<Pagination<ServiceProvider>> = Promise.resolve(
        serviceProvidersResult,
      );

      const spy = jest
        .spyOn(service, 'paginate')
        .mockImplementation(() => Promise.resolve(result));

      // Calling the list function
      const resultat = await serviceProviderController.list(req, page, limit);

      // Expected
      expect(resultat.pageCount).toEqual(0);
      expect(resultat.serviceProviders.length).toEqual(3);
    });

    it('call repository with active true', async () => {
      const mockedCount = 10;
      /// const result = serviceProviderRepository.count.mockResolvedValueOnce(mockedCount);

      // Mocking item id
      const itemId: ObjectID = new ObjectID('5d35b91e70332098440d0f85');

      // Mocking Items
      const itemTest1: ServiceProvider = {
        id: itemId,
        name: 'Site Usagers',
        redirect_uris: ['https://url.com'],
        post_logout_redirect_uris: [''],
        site: ['https:/monsite.com'],
        email: 'v@b.com',
        IPServerAddressesAndRanges: ['192.0.0.0'],
        logo: 'logo.png',
        active: true,
        type: 'public',
        secretCreatedAt: new Date(),
        secret_hash: '76eded44d32b40c0cb1006065',
        key: '6925fb8143c76eded44d32b40c0cb1006065f7f003de52712b78985704f39950',
        createdAt: new Date(),
      };

      const itemTest2: ServiceProvider = {
        id: itemId,
        name: 'Site Usagers',
        redirect_uris: ['https://url.com'],
        post_logout_redirect_uris: [''],
        site: ['https:/monsite.com'],
        email: 'v@b.com',
        IPServerAddressesAndRanges: ['192.0.0.0'],
        logo: 'logo.png',
        active: true,
        type: 'public',
        secretCreatedAt: new Date(),
        secret_hash: '76eded44d32b40c0cb1006065',
        key: '6925fb8143c76eded44d32b40c0cb1006065f7f003de52712b78985704f39950',
        createdAt: new Date(),
      };

      const itemTest3: ServiceProvider = {
        id: itemId,
        name: 'Site Usagers',
        redirect_uris: ['https://url.com'],
        post_logout_redirect_uris: [''],
        site: ['https:/monsite.com'],
        email: 'v@b.com',
        IPServerAddressesAndRanges: ['192.0.0.0'],
        logo: 'logo.png',
        active: true,
        type: 'public',
        secretCreatedAt: new Date(),
        secret_hash: '76eded44d32b40c0cb1006065',
        key: '6925fb8143c76eded44d32b40c0cb1006065f7f003de52712b78985704f39950',
        createdAt: new Date(),
      };

      // Mocking return value of serviceProviderController.list(page, limit)
      const serviceProvidersResult = {
        items: [itemTest1, itemTest2, itemTest3],
        itemCount: 3,
        totalItems: 3,
        pageCount: 0,
        next: '',
        previous: '',
      };

      const result: Promise<Pagination<ServiceProvider>> = Promise.resolve(
        serviceProvidersResult,
      );

      const spy = jest
        .spyOn(service, 'paginate')
        .mockImplementation(() => Promise.resolve(result));

      const data = await serviceProviderController.list(req, '0', '10');

      expect(serviceProviderRepository.count).toHaveBeenCalledWith({
        active: true,
      });
    });
  });

  describe('createServiceProvider', () => {
    it('redirects the user when a valid user is provided', async () => {
      // setup
      fileStorageService.storeFile.mockResolvedValueOnce(logo);

      // action
      await serviceProviderController.createServiceProvider(
        ServiceProviderDto,
        req,
        res,
        logo,
      );

      // expect
      expect(res.redirect).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith(`${res.locals.APP_ROOT}/`);
    });

    it('should redirect to the form with flashed error if the creation fail', async () => {
      // setup
      fileStorageService.storeFile.mockResolvedValueOnce(logo);

      serviceProviderService.createServiceProvider = jest.fn(() => {
        throw Error;
      });

      // action
      await serviceProviderController.createServiceProvider(
        ServiceProviderDto,
        req,
        res,
        logo,
      );

      // assertion
      expect(
        serviceProviderService.createServiceProvider,
      ).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/service-provider/create`,
      );
    });

    it('should redirect to the form with flashed error if the logo cannot be stored', async () => {
      // setup
      fileStorageService.storeFile.mockRejectedValueOnce(
        new Error('Something occured...'),
      );

      // action
      await serviceProviderController.createServiceProvider(
        ServiceProviderDto,
        req,
        res,
        logo,
      );

      // expect
      expect(res.redirect).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/service-provider/create`,
      );
    });
  });

  describe('get a service provider', () => {
    it('should get a service Provider and render update view', async () => {
      // setup
      const serviceProvider = {
        id: idParam,
        name: 'FranceConnect TEST 9',
        redirect_uris: ['https://FranceConnect.com'],
        post_logout_redirect_uris: ['https://FranceConnect.com'],
        site: ['https://FranceConnect8888.com'],
        status: 'public',
        email: ['v@b.com'],
        active: 'true',
        IPServerAddressesAndRanges: ['1.1.1.1'],
        key: 'cb55015c-7fb5-49b4-9006-e523552bc3e7',
      };

      serviceProviderService.findById.mockImplementation(() =>
        Promise.resolve(serviceProvider),
      );

      fileStorageService.getFileAsDataUri.mockResolvedValueOnce(logoAsDataUri);

      // action
      const result = await serviceProviderController.findOne(idParam, req, res);

      // expect
      expect(req.flash).toHaveBeenCalledTimes(1);
      expect(req.flash).toHaveBeenCalledWith('values', {
        ...serviceProvider,
        redirectUri: 'https://FranceConnect.com',
        ipsRanges: '1.1.1.1',
        postLogoutUri: 'https://FranceConnect.com',
        emails: 'v@b.com',
        logoAsDataUri,
      });
      expect(result).toEqual({
        id: idParam,
        csrfToken: 'mygreatcsrftoken',
      });
    });

    it('should get a service Provider and render update view even without logo', async () => {
      // setup
      const serviceProvider = {
        id: idParam,
        name: 'FranceConnect TEST 9',
        redirect_uris: ['https://FranceConnect.com'],
        post_logout_redirect_uris: ['https://FranceConnect.com'],
        site: ['https://FranceConnect8888.com'],
        status: 'public',
        email: ['v@b.com'],
        active: 'true',
        IPServerAddressesAndRanges: ['1.1.1.1'],
        key: 'cb55015c-7fb5-49b4-9006-e523552bc3e7',
      };

      serviceProviderService.findById.mockImplementation(() =>
        Promise.resolve(serviceProvider),
      );

      fileStorageService.getFileAsDataUri.mockResolvedValueOnce(undefined);

      // action
      const result = await serviceProviderController.findOne(idParam, req, res);

      // expect
      expect(req.flash).toHaveBeenCalledTimes(1);
      expect(req.flash).toHaveBeenCalledWith('values', {
        ...serviceProvider,
        redirectUri: 'https://FranceConnect.com',
        ipsRanges: '1.1.1.1',
        postLogoutUri: 'https://FranceConnect.com',
        emails: 'v@b.com',
      });
      expect(result).toEqual({
        id: idParam,
        csrfToken: 'mygreatcsrftoken',
      });
    });
  });

  describe('serviceProviderUpdate', () => {
    it('should update a servicerProvider and return to the serviceProvider page', async () => {
      await serviceProviderController.serviceProviderUpdate(
        ServiceProviderDto,
        idParam,
        req,
        res,
      );
      expect(res.redirect).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/service-provider/${idParam}`,
      );
    });
    it('should redirect to the serviceProvider if we cant update the serviceProvider', async () => {
      serviceProviderService.update = jest.fn(() => {
        throw Error;
      });
      // action
      await serviceProviderController.serviceProviderUpdate(
        ServiceProviderDto,
        idParam,
        req,
        res,
      );
      // assertion
      expect(serviceProviderService.update).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/service-provider/${idParam}`,
      );
    });
  });

  describe('serviceProviderUpdateLogo', () => {
    it('should update the logo and redirect the user to the service provider page with success', async () => {
      // setup
      fileStorageService.storeFile.mockResolvedValueOnce({
        filename: '424242424_logo.png',
      });
      fileStorageService.deleteFile.mockResolvedValueOnce(logo);

      // action
      await serviceProviderController.serviceProviderUpdateLogo(
        UpdateServiceProviderLogoInputDto,
        idParam,
        req,
        res,
        logo,
      );

      // expect
      expect(serviceProviderService.updateLogo).toHaveBeenCalledTimes(1);
      expect(serviceProviderService.updateLogo).toHaveBeenCalledWith(
        idParam,
        '424242424_logo.png',
      );
      expect(req.flash).toHaveBeenCalledTimes(1);
      expect(req.flash).toHaveBeenCalledWith(
        'success',
        'Le logo du fournisseur a été modifié avec succès !',
      );
      expect(res.redirect).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/service-provider/${idParam}`,
      );
    });

    it('should remove the old logo if the update succeed', async () => {
      // setup
      fileStorageService.storeFile.mockResolvedValueOnce(logo);
      serviceProviderService.updateLogo.mockResolvedValueOnce(logo);

      // action
      await serviceProviderController.serviceProviderUpdateLogo(
        UpdateServiceProviderLogoInputDto,
        idParam,
        req,
        res,
        logo,
      );

      // expect
      expect(fileStorageService.deleteFile).toHaveBeenCalledTimes(1);
      expect(fileStorageService.deleteFile).toHaveBeenCalledWith(
        UpdateServiceProviderLogoInputDto.currentLogo,
      );
    });

    it('should not update the logo and redirect the user to the service provider page with error', async () => {
      // setup
      fileStorageService.storeFile.mockRejectedValueOnce(
        new Error('Something occured...'),
      );
      fileStorageService.deleteFile.mockResolvedValueOnce(logo);

      // action
      await serviceProviderController.serviceProviderUpdateLogo(
        UpdateServiceProviderLogoInputDto,
        idParam,
        req,
        res,
        logo,
      );

      // expect
      expect(serviceProviderService.updateLogo).toHaveBeenCalledTimes(0);
      expect(req.flash).toHaveBeenCalledTimes(1);
      expect(req.flash).toHaveBeenCalledWith(
        'globalError',
        'Impossible de mettre à jour le logo',
      );
      expect(res.redirect).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/service-provider/${idParam}`,
      );
    });

    it('should not remove the old logo if the update fail for some reason', async () => {
      // setup
      fileStorageService.storeFile.mockResolvedValueOnce(logo);
      serviceProviderService.updateLogo.mockRejectedValueOnce(
        new Error('Something occured...'),
      );

      // action
      await serviceProviderController.serviceProviderUpdateLogo(
        UpdateServiceProviderLogoInputDto,
        idParam,
        req,
        res,
        logo,
      );

      // expect
      expect(fileStorageService.deleteFile).toHaveBeenCalledTimes(0);
    });
  });

  describe('Delete service provider', () => {
    it('Should redirect if service provider is removed', async () => {
      // set up
      const key = 'key';
      const body = { name: 'name' };

      // action
      serviceProviderService.deleteServiceProviderByKey.mockImplementationOnce(
        () => {
          return {};
        },
      );
      await serviceProviderController.deleteServiceProvider(
        key,
        req,
        res,
        body,
      );

      // expect
      expect(
        serviceProviderService.deleteServiceProviderByKey,
      ).toHaveBeenCalledWith({ key });
      expect(
        serviceProviderService.deleteServiceProviderByKey,
      ).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/service-provider`,
      );
    });

    it('Should not redirect the user but set the res status to 500 for the error handler', async () => {
      // set up
      const key = 'key';
      const body = { name: 'name' };

      // action
      serviceProviderService.deleteServiceProviderByKey.mockImplementationOnce(
        () => {
          throw new Error('Try again buddy');
        },
      );
      await serviceProviderController.deleteServiceProvider(
        key,
        req,
        res,
        body,
      );
      // expect
      expect(
        serviceProviderService.deleteServiceProviderByKey,
      ).toHaveBeenCalledWith({ key });
      expect(
        serviceProviderService.deleteServiceProviderByKey,
      ).toHaveBeenCalledTimes(1);
      expect(req.flash).toHaveBeenCalledTimes(1);
      expect(req.flash).toHaveBeenCalledWith('globalError', 'Try again buddy');
      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.redirect).toHaveBeenCalledTimes(0);
    });
  });

  describe('Delete several service provider', () => {
    it('Should redirect after remove several servide provider', async () => {
      // set up
      const deleteServiceProviderDto = {
        deleteItems: ['aaaa', 'bbbb', 'cccc'],
        name: 'aaa, bbb, ccc',
      };

      const expectedResultSentToService = [
        { key: 'aaaa' },
        { key: 'bbbb' },
        { key: 'cccc' },
      ];

      // action
      serviceProviderService.deleteServiceProviderByKey.mockImplementationOnce(
        () => {
          return {};
        },
      );
      await serviceProviderController.deleteServiceProviders(
        deleteServiceProviderDto,
        res,
        req,
      );

      // expect
      expect(
        serviceProviderService.deleteServiceProviderByKey,
      ).toHaveBeenCalledWith(expectedResultSentToService);
      expect(
        serviceProviderService.deleteServiceProviderByKey,
      ).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/service-provider`,
      );
    });

    it('Should not redirect the user but set the res status to 500 for error handler', async () => {
      // set up
      const deleteServiceProviderDto = {
        deleteItems: ['aaaa', 'bbbb'],
        name: 'aaa, bbb',
      };

      const expectedResultSentToService = [{ key: 'aaaa' }, { key: 'bbbb' }];

      // action
      serviceProviderService.deleteServiceProviderByKey.mockImplementationOnce(
        () => {
          throw new Error('Try again buddy');
        },
      );
      await serviceProviderController.deleteServiceProviders(
        deleteServiceProviderDto,
        res,
        req,
      );

      // expect
      expect(
        serviceProviderService.deleteServiceProviderByKey,
      ).toHaveBeenCalledWith(expectedResultSentToService);
      expect(
        serviceProviderService.deleteServiceProviderByKey,
      ).toHaveBeenCalledTimes(1);
      expect(req.flash).toHaveBeenCalledTimes(1);
      expect(req.flash).toHaveBeenCalledWith('globalError', 'Try again buddy');
      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.redirect).toHaveBeenCalledTimes(0);
    });
  });

  describe('GenerateNewSecret View', () => {
    it('should get a service Provider and render generate client secret view', async () => {
      const serviceProvider = {
        IPServerAddressesAndRanges: ['1.1.1.1'],
        active: 'true',
        email: ['v@b.com'],
        emails: 'v@b.com',
        ipsRanges: '1.1.1.1',
        key: 'cb55015c-7fb5-49b4-9006-e523552bc3e7',
        name: 'FranceConnect TEST 9',
        postLogoutUri: 'https://FranceConnect.com',
        post_logout_redirect_uris: ['https://FranceConnect.com'],
        redirectUri: 'https://FranceConnect.com',
        redirect_uris: ['https://FranceConnect.com'],
        site: ['https://FranceConnect8888.com'],
        status: 'public',
      };

      serviceProviderService.findById.mockImplementation(() =>
        Promise.resolve(serviceProvider),
      );

      const result = await serviceProviderController.findOne(idParam, req, res);
      expect(req.flash).toHaveBeenCalledTimes(1);
      expect(req.flash).toHaveBeenCalledWith('values', {
        ...serviceProvider,
      });
      expect(result).toEqual({
        id: idParam,
        csrfToken: 'mygreatcsrftoken',
      });
    });
  });

  describe('Generate a new client secret', () => {
    it('Should redirect after generation of a client secret', async () => {
      // set up
      const serviceProvider = {
        IPServerAddressesAndRanges: ['1.1.1.1'],
        active: 'true',
        email: ['v@b.com'],
        emails: 'v@b.com',
        ipsRanges: '1.1.1.1',
        key: 'cb55015c-7fb5-49b4-9006-e523552bc3e7',
        name: 'FranceConnect TEST 9',
        postLogoutUri: 'https://FranceConnect.com',
        post_logout_redirect_uris: ['https://FranceConnect.com'],
        redirectUri: 'https://FranceConnect.com',
        redirect_uris: ['https://FranceConnect.com'],
        site: ['https://FranceConnect8888.com'],
        status: 'public',
        secret_hash:
          '$2b$10$EO3FnI3YKfnnvUlvr084wegEgEPeRPRMdE2VJwMHpAsNkaMv1n9pG',
      };
      const generateNewClientSecretDTO = {
        name: 'aaa, bbb, ccc',
        key: 'clientID',
        secret_hash: 'ancien secret hash',
      };

      const key = 'key';

      // action
      serviceProviderService.generateNewSecret.mockImplementationOnce(() => {
        return serviceProvider;
      });
      await serviceProviderController.generateNewClientSecret(
        key,
        generateNewClientSecretDTO,
        req,
        res,
      );

      // expect
      expect(serviceProviderService.generateNewSecret).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith(
        `${res.locals.APP_ROOT}/service-provider`,
      );
    });

    it('Should redirect after generation of a client secret', async () => {
      // set up
      const generateNewClientSecretDTO = {
        name: 'aaa, bbb, ccc',
        key: 'clientID',
        secret_hash: 'ancien secret hash',
      };

      const key = 'key';

      // action
      serviceProviderService.generateNewSecret.mockImplementationOnce(() => {
        throw Error;
      });

      await serviceProviderController.generateNewClientSecret(
        key,
        generateNewClientSecretDTO,
        req,
        res,
      );

      // expect
      expect(serviceProviderService.generateNewSecret).toHaveBeenCalledTimes(1);
      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.redirect).toHaveBeenCalledTimes(0);
    });
  });
});
