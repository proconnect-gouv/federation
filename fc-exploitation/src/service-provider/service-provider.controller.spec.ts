import { Test } from '@nestjs/testing';
import { ServiceProviderController } from './service-provider.controller';
import { getRepositoryToken, TypeOrmModule } from '@nestjs/typeorm';
import { ServiceProvider } from './service-provider.entity';
import { ServiceProviderService } from './service-provider.service';

describe('ServiceProviderController', () => {
  let serviceProviderController: ServiceProviderController;

  const serviceProviderRepository = {
    count: jest.fn(),
    find: jest.fn(),
  };

  const serviceProviderService = {
    createServiceProvider: jest.fn(),
  };
  const renderMock = {
    render: jest.fn(),
  };

  const res = {
    redirect: jest.fn(),
    status: jest.fn(),
  };

  const createServiceProviderDto = {
    name: 'monfs',
    redirectUri: { result: ['https://url.com'] },
    redirectUriLogout: { result: ['https://url.com/logout'] },
    site: 'https:/monsite.com',
    emails: { result: ['v@b.com'] },
    ipAddresses: { result: ['192.0.0.0'] },
    activateClient: 'oui',
    clientStatus: 'public',
  };

  const expectedResultAfterTransformation = {
    name: 'monfs',
    redirectUri: ['https://url.com'],
    redirectUriLogout: ['https://url.com/logout'],
    site: 'https:/monsite.com',
    emails: ['v@b.com'],
    ipAddresses: ['192.0.0.0'],
    activateClient: 'oui',
    clientStatus: 'public',
  };

  const req = {
    flash: jest.fn(),
    user: {
      id: '05e4fadf-fda6-4ad8-ae75-b7f315843827',
    },
  };

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [TypeOrmModule.forFeature([ServiceProvider], 'fc-mongo')],
      providers: [ServiceProviderController, ServiceProviderService],
    })
      .overrideProvider(getRepositoryToken(ServiceProvider, 'fc-mongo'))
      .useValue(serviceProviderRepository)
      .overrideProvider(ServiceProviderService)
      .useValue(serviceProviderService)
      .compile();
    serviceProviderController = await module.get<ServiceProviderController>(
      ServiceProviderController,
    );
    jest.resetAllMocks();

    renderMock.render.mockReturnValueOnce(true);
    res.status.mockReturnValueOnce(renderMock);
  });

  describe('list method', () => {
    it('returns the list of the available service providers', async () => {
      const mockedServiceProviders = [
        'La barbe',
        'de la femme',
        'Ã  Georges Moustaki',
      ];
      serviceProviderRepository.find.mockResolvedValueOnce(
        mockedServiceProviders,
      );

      const { serviceProviders } = await serviceProviderController.list();

      expect(serviceProviders).toEqual(mockedServiceProviders);
    });

    it('returns the count of active service providers', async () => {
      const mockedCount = 10;
      serviceProviderRepository.count.mockResolvedValueOnce(mockedCount);

      const {
        activeServiceProvidersCount,
      } = await serviceProviderController.list();

      expect(activeServiceProvidersCount).toBe(mockedCount);
      expect(serviceProviderRepository.count).toHaveBeenCalledWith({
        active: true,
      });
    });
  });

  describe('createUser', () => {
    it('redirects the user when a valid user is provided', async () => {
      await serviceProviderController.createServiceProvider(
        createServiceProviderDto,
        req,
        res,
      );
      expect(res.redirect).toHaveBeenCalledTimes(1);
      expect(res.redirect).toHaveBeenCalledWith('/');
    });

    it('uses the user service to create users', async () => {
      await serviceProviderController.createServiceProvider(
        createServiceProviderDto,
        req,
        res,
      );

      expect(
        serviceProviderService.createServiceProvider,
      ).toHaveBeenCalledTimes(1);
      expect(serviceProviderService.createServiceProvider).toHaveBeenCalledWith(
        expectedResultAfterTransformation,
      );
    });

    it('should not redirect the user but set the res status to 422 for the error handler', async () => {
      // set up
      serviceProviderService.createServiceProvider = jest.fn(() => {
        throw Error;
      });
      // action
      await serviceProviderController.createServiceProvider(
        createServiceProviderDto,
        req,
        res,
      );
      // assertion
      expect(res.status).toHaveBeenCalledWith(422);
      expect(renderMock.render).toHaveBeenCalledWith(
        'service-provider/creation',
        {
          values: createServiceProviderDto,
          globalError: Error,
        },
      );
      expect(
        serviceProviderService.createServiceProvider,
      ).toHaveBeenCalledTimes(1);
    });
  });
});
