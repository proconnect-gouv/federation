import { HttpException, HttpStatus } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { CitizenController } from './citizen.controller';
import { CitizenService } from './citizen.service';

describe('CitizenController', () => {
  let citizenController: CitizenController;
  let service: CitizenService;

  const citizenService = {
    getCitizenHash: jest.fn(),
    findByHash: jest.fn(),
    createBlockedCitizen: jest.fn(),
    generateLegacyAccountId: jest.fn(),
    setActive: jest.fn(),
  };

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [],
      providers: [CitizenController, CitizenService],
    })
      .overrideProvider(CitizenService)
      .useValue(citizenService)
      .compile();

    citizenController = await module.get<CitizenController>(CitizenController);

    service = await module.get<CitizenService>(CitizenService);

    jest.resetAllMocks();
  });

  describe('getCitizenStatus', () => {
    it('Should return the citizen status and last connection date', async () => {
      // Given
      const body = {
        givenName: 'georges',
        familyName: 'moustaki',
        birthdate: new Date('1934-01-01'),
        gender: 'gender',
        birthPlace: 99,
        birthCountry: 99,
      };

      citizenService.getCitizenHash.mockReturnValueOnce('foo');
      citizenService.findByHash.mockResolvedValueOnce({
        _id: 'baz',
        id: 'bar',
        identityHash: 'foo',
        active: true,
        updatedAt: '2019-06-01T12:34:56.000Z',
      });

      // When
      const result = await citizenController.getCitizenStatus(body);
      // Then
      expect(result).toEqual({
        active: true,
        lastConnection: '2019-06-01T12:34:56.000Z',
      });
    });

    it('Should throw a 404 error if citizen not found', async () => {
      // Given
      const body = {
        givenName: 'georges',
        familyName: 'moustaki',
        birthdate: new Date('1934-01-01'),
        gender: 'gender',
        birthPlace: 99,
        birthCountry: 99,
      };
      citizenService.getCitizenHash.mockReturnValueOnce('foo');
      citizenService.findByHash.mockResolvedValueOnce(false);

      // Then
      expect(citizenController.getCitizenStatus(body)).rejects.toEqual(
        new HttpException('Not found', HttpStatus.NOT_FOUND),
      );
    });
  });

  describe('patchCitizenStatus', () => {
    it('Should update existing citizen', async () => {
      // Given
      const body = {
        givenName: 'georges',
        familyName: 'moustaki',
        birthdate: new Date('1934-01-01'),
        gender: 'gender',
        birthPlace: 99,
        birthCountry: 99,
        active: false,
      };
      const hash = 'myCitizenHash';
      citizenService.getCitizenHash.mockReturnValueOnce(hash);
      citizenService.findByHash.mockResolvedValue({
        id: 'foobar',
        identityHash: hash,
        active: true,
        updatedAt: '2019-01-03T12:34:56.000Z',
      });
      const req = { totp: 'valid' };
      const res = { json: jest.fn() };
      // When
      await citizenController.patchCitizenStatus(body, req, res);
      // Then
      expect(res.json).toHaveBeenCalledTimes(1);
      expect(res.json).toHaveBeenCalledWith({
        active: false,
        lastConnection: '2019-01-03T12:34:56.000Z',
      });
      expect(citizenService.getCitizenHash).toHaveBeenCalledTimes(1);
      expect(citizenService.getCitizenHash).toHaveBeenCalledWith(body);

      expect(citizenService.findByHash).toHaveBeenCalledTimes(1);
      expect(citizenService.findByHash).toHaveBeenCalledWith(hash);

      expect(citizenService.setActive).toHaveBeenCalledTimes(1);
      expect(citizenService.setActive).toHaveBeenCalledWith(hash, false);
    });

    it('Should create a new blocked citizen', async () => {
      // Given
      const body = {
        givenName: 'georges',
        familyName: 'moustaki',
        birthdate: new Date('1934-01-01'),
        gender: 'gender',
        birthPlace: 99,
        birthCountry: 99,
        active: false,
      };
      const hash = 'myCitizenHash';
      citizenService.getCitizenHash.mockReturnValueOnce(hash);
      citizenService.findByHash.mockResolvedValue(false);
      const req = { totp: 'valid' };
      const res = { json: jest.fn() };
      // When
      await citizenController.patchCitizenStatus(body, req, res);
      // Then
      expect(res.json).toHaveBeenCalledTimes(1);
      expect(res.json).toHaveBeenCalledWith({
        active: false,
        lastConnection: null,
      });

      expect(citizenService.getCitizenHash).toHaveBeenCalledTimes(1);
      expect(citizenService.getCitizenHash).toHaveBeenCalledWith(body);

      expect(citizenService.findByHash).toHaveBeenCalledTimes(1);
      expect(citizenService.findByHash).toHaveBeenCalledWith(hash);

      expect(citizenService.createBlockedCitizen).toHaveBeenCalledTimes(1);
      expect(citizenService.createBlockedCitizen).toHaveBeenCalledWith(body);
    });

    it('Should return an error on missing TOTP', async () => {
      // Given
      const body = {
        givenName: 'georges',
        familyName: 'moustaki',
        birthdate: new Date('1934-01-01'),
        gender: 'gender',
        birthPlace: 99,
        birthCountry: 99,
        active: false,
      };
      const req = {};
      const res = { status: jest.fn(), send: jest.fn() };
      res.status.mockReturnValueOnce(res);
      // When
      await citizenController.patchCitizenStatus(body, req, res);
      // Then
      expect(res.status).toHaveBeenCalledTimes(1);
      expect(res.status).toHaveBeenCalledWith(401);

      expect(res.send).toHaveBeenCalledTimes(1);
      expect(res.send).toHaveBeenCalledWith('Code TOTP invalide');
    });

    it('Should return an error on invalid TOTP', async () => {
      // Given
      const body = {
        givenName: 'georges',
        familyName: 'moustaki',
        birthdate: new Date('1934-01-01'),
        gender: 'gender',
        birthPlace: 99,
        birthCountry: 99,
        active: false,
      };
      const req = { totp: 'invalid' };
      const res = { status: jest.fn(), send: jest.fn() };
      res.status.mockReturnValueOnce(res);
      // When
      await citizenController.patchCitizenStatus(body, req, res);
      // Then
      expect(res.status).toHaveBeenCalledTimes(1);
      expect(res.status).toHaveBeenCalledWith(401);

      expect(res.send).toHaveBeenCalledTimes(1);
      expect(res.send).toHaveBeenCalledWith('Code TOTP invalide');
    });
  });
});
