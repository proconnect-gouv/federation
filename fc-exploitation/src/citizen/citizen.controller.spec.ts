import { IIdentity } from '@fc/shared/citizen/interfaces/identity.interface';
import { HttpException, HttpStatus } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { PreferencesService } from '../preferences';
import { CitizenController } from './citizen.controller';
import { CitizenService } from './citizen.service';
import { PatchCitizenActiveDTO } from './dto/patch-citizen-active.dto';

describe('CitizenController', () => {
  let citizenController: CitizenController;
  let service: CitizenService;

  const citizenService = {
    getPivotIdentityHash: jest.fn(),
    findByHash: jest.fn(),
    createBlockedCitizen: jest.fn(),
    generateLegacyAccountId: jest.fn(),
    setActive: jest.fn(),
  };

  const preferencesServiceMock = {
    createLoggerData: jest.fn(),
    createPayloadData: jest.fn(),
    createPayload: jest.fn(),
    setIdpPreferences: jest.fn(),
    findIdpPreferences: jest.fn(),
  };

  const identity: IIdentity = {
    givenName: 'georges',
    familyName: 'moustaki',
    preferredUsername: '',
    birthdate: '1934-01-01',
    gender: 'gender',
    birthPlace: '95277',
    birthCountry: '99100',
  };

  const oidcIdentity = {
    given_name: 'georges',
    family_name: 'moustaki',
    preferred_username: '',
    birthdate: '1934-01-01',
    gender: 'gender',
    birthplace: '95277',
    birthcountry: '99100',
  };

  const body: PatchCitizenActiveDTO = {
    givenName: 'georges',
    familyName: 'moustaki',
    preferredUsername: '',
    birthdate: '1934-01-01',
    gender: 'gender',
    isFrench: true,
    cog: '95277',
    active: false,
    supportId: '1234567891234567',
    toIdentity: () => identity,
    toOidc: () => oidcIdentity,
  };

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [],
      providers: [CitizenController, CitizenService, PreferencesService],
    })
      .overrideProvider(CitizenService)
      .useValue(citizenService)
      .overrideProvider(PreferencesService)
      .useValue(preferencesServiceMock)
      .compile();

    citizenController = await module.get<CitizenController>(CitizenController);

    service = await module.get<CitizenService>(CitizenService);

    jest.resetAllMocks();
  });

  describe('getCitizenStatus', () => {
    const preferencesMock = {
      allowFutureIdp: false,
      idpList: [
        {
          uid: 'idp_uid',
          name: 'idp',
          image: 'idp.png',
          title: 'IDP',
          active: true,
          isChecked: true,
        },
        {
          uid: 'idp_uid',
          name: 'idp',
          image: 'idp.png',
          title: 'IDP',
          active: true,
          isChecked: true,
        },
      ],
    };

    it('Should return the citizen status and last connection date', async () => {
      // Given
      const userIdpSettings = {
        allowFutureIdp: false,
        idpList: [
          {
            uid: 'idp_uid',
            name: 'idp',
            image: 'idp.png',
            title: 'IDP',
            active: true,
            isChecked: true,
          },
          {
            uid: 'idp_uid',
            name: 'idp',
            image: 'idp.png',
            title: 'IDP',
            active: true,
            isChecked: true,
          },
        ],
      };

      citizenService.getPivotIdentityHash.mockReturnValueOnce('foo');
      citizenService.findByHash.mockResolvedValueOnce({
        _id: 'baz',
        id: 'bar',
        identityHash: 'foo',
        active: true,
        updatedAt: '2019-06-01T12:34:56.000Z',
      });

      preferencesServiceMock.findIdpPreferences.mockReturnValueOnce(
        preferencesMock,
      );

      // When
      const result = await citizenController.getCitizenStatus(identity);
      // Then
      expect(result).toEqual({
        userIdpSettings,
        havePreferencesSettings: true,
        active: true,
        accountId: 'bar',
        lastConnection: '2019-06-01T12:34:56.000Z',
      });
    });

    it('Should throw a 404 error if citizen not found', async () => {
      // Given
      citizenService.getPivotIdentityHash.mockReturnValueOnce('foo');
      citizenService.findByHash.mockResolvedValueOnce(false);
      preferencesServiceMock.findIdpPreferences.mockReturnValueOnce(
        preferencesMock,
      );

      // Then
      expect(citizenController.getCitizenStatus(identity)).rejects.toEqual(
        new HttpException('Not found', HttpStatus.NOT_FOUND),
      );
    });
  });

  describe('patchCitizenStatus', () => {
    it('Should update existing citizen', async () => {
      // Given
      const hash = 'myCitizenHash';
      citizenService.getPivotIdentityHash.mockReturnValueOnce(hash);
      citizenService.findByHash.mockResolvedValue({
        id: 'foobar',
        identityHash: hash,
        active: true,
        updatedAt: '2019-01-03T12:34:56.000Z',
      });
      const req = {
        totp: 'valid',
        user: {
          username: 'Toto',
        },
      };
      const res = { json: jest.fn() };
      // When
      await citizenController.patchCitizenStatus(body, req, res);
      // Then
      expect(res.json).toHaveBeenCalledTimes(1);
      expect(res.json).toHaveBeenCalledWith({
        active: false,
        accountId: 'foobar',
        lastConnection: '2019-01-03T12:34:56.000Z',
      });
      expect(citizenService.getPivotIdentityHash).toHaveBeenCalledTimes(1);
      expect(citizenService.getPivotIdentityHash).toHaveBeenCalledWith(
        identity,
      );

      expect(citizenService.findByHash).toHaveBeenCalledTimes(1);
      expect(citizenService.findByHash).toHaveBeenCalledWith(hash);

      expect(citizenService.setActive).toHaveBeenCalledTimes(1);
      expect(citizenService.setActive).toHaveBeenCalledWith(
        hash,
        false,
        body.supportId,
        req.user,
      );
    });

    it('Should create a new blocked citizen', async () => {
      // Given
      const hash = 'myCitizenHash';
      citizenService.getPivotIdentityHash.mockReturnValueOnce(hash);
      citizenService.findByHash.mockResolvedValue(false);
      const req = { totp: 'valid', user: { username: 'Toto' } };
      const res = { json: jest.fn() };
      // When
      await citizenController.patchCitizenStatus(body, req, res);
      // Then
      expect(res.json).toHaveBeenCalledTimes(1);
      expect(res.json).toHaveBeenCalledWith({
        active: false,
        lastConnection: null,
      });

      expect(citizenService.getPivotIdentityHash).toHaveBeenCalledTimes(1);
      expect(citizenService.getPivotIdentityHash).toHaveBeenCalledWith(
        identity,
      );

      expect(citizenService.findByHash).toHaveBeenCalledTimes(1);
      expect(citizenService.findByHash).toHaveBeenCalledWith(hash);

      expect(citizenService.createBlockedCitizen).toHaveBeenCalledTimes(1);
      expect(citizenService.createBlockedCitizen).toHaveBeenCalledWith(
        identity,
        body.supportId,
        req.user,
      );
    });

    it('Should return an error on missing TOTP', async () => {
      // Given
      const req = {};
      const res = { status: jest.fn(), send: jest.fn() };
      res.status.mockReturnValueOnce(res);
      // When
      await citizenController.patchCitizenStatus(body, req, res);
      // Then
      expect(res.status).toHaveBeenCalledTimes(1);
      expect(res.status).toHaveBeenCalledWith(401);

      expect(res.send).toHaveBeenCalledTimes(1);
      expect(res.send).toHaveBeenCalledWith('Code TOTP invalide');
    });

    it('Should return an error on invalid TOTP', async () => {
      // Given
      const req = { totp: 'invalid' };
      const res = { status: jest.fn(), send: jest.fn() };
      res.status.mockReturnValueOnce(res);
      // When
      await citizenController.patchCitizenStatus(body, req, res);
      // Then
      expect(res.status).toHaveBeenCalledTimes(1);
      expect(res.status).toHaveBeenCalledWith(401);

      expect(res.send).toHaveBeenCalledTimes(1);
      expect(res.send).toHaveBeenCalledWith('Code TOTP invalide');
    });
  });
});
