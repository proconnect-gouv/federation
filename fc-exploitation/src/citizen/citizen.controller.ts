import { Roles } from '@fc/shared/authentication/decorator/roles.decorator';
import { IIdentity } from '@fc/shared/citizen/interfaces/identity.interface';
import { IPivotIdentity } from '@fc/shared/citizen/interfaces/pivot-identity.interface';
import { UserRole } from '@fc/shared/user/roles.enum';
import {
  Body,
  Controller,
  HttpException,
  HttpStatus,
  Patch,
  Post,
  Req,
  Res,
  UsePipes,
  ValidationPipe,
} from '@nestjs/common';
import { PreferencesService } from '../preferences';
import { CitizenService } from './citizen.service';
import { CitizenAccountDTO } from './dto/citizen-account.dto';
import { PatchCitizenActiveDTO } from './dto/patch-citizen-active.dto';

@Controller('citizen')
export class CitizenController {
  constructor(
    private readonly citizenService: CitizenService,
    private readonly preferencesService: PreferencesService,
  ) {}

  @Post()
  @Roles(UserRole.OPERATOR)
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async getCitizenStatus(@Body() citizenIdentity: IIdentity) {
    const identityHash: string = this.citizenService.getPivotIdentityHash(
      citizenIdentity as IPivotIdentity,
    );

    const citizenAccount = await this.citizenService.findByHash(identityHash);

    if (!citizenAccount) {
      throw new HttpException('Not found', HttpStatus.NOT_FOUND);
    }

    let userIdpSettings;
    // Retrieve the current or default IDP setting for the Operator to amend
    userIdpSettings = await this.preferencesService.findIdpPreferences(
      citizenIdentity,
    );

    if (!userIdpSettings) {
      userIdpSettings = {};
    }

    return {
      userIdpSettings,
      havePreferencesSettings: true,
      active: citizenAccount.active,
      lastConnection: this.getLastConnection(citizenAccount),
      accountId: citizenAccount.id,
    };
  }

  @Patch()
  @Roles(UserRole.OPERATOR)
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async patchCitizenStatus(
    @Body() citizenActiveStateUpdateRequest: PatchCitizenActiveDTO,
    @Req() req,
    @Res() res,
  ) {
    // Security check
    if (!req.totp || req.totp !== 'valid') {
      return res.status(401).send('Code TOTP invalide');
    }

    const identityToUpdate = citizenActiveStateUpdateRequest.toIdentity();

    // Seek citizen informations
    const identityHash: string = this.citizenService.getPivotIdentityHash(
      identityToUpdate,
    );
    const citizenAccount = await this.citizenService.findByHash(identityHash);

    // If found
    if (citizenAccount) {
      this.citizenService.setActive(
        identityHash,
        citizenActiveStateUpdateRequest.active,
        citizenActiveStateUpdateRequest.supportId,
        req.user,
      );
      return res.json({
        active: citizenActiveStateUpdateRequest.active,
        lastConnection: this.getLastConnection(citizenAccount),
        accountId: citizenAccount.id,
      });
    }

    // Else
    this.citizenService.createBlockedCitizen(
      identityToUpdate,
      citizenActiveStateUpdateRequest.supportId,
      req.user,
    );
    return res.json({ active: false, lastConnection: null });
  }

  private getLastConnection(citizen: CitizenAccountDTO) {
    if (!citizen.active && citizen.lastConnection) {
      return new Date(citizen.lastConnection).toISOString();
    }

    if (citizen.updatedAt) {
      return new Date(citizen.updatedAt).toISOString();
    }

    return null;
  }
}
