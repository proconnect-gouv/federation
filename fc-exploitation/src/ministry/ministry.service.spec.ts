import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken, TypeOrmModule } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ObjectID } from 'mongodb';
import { LoggerService } from '@fc/shared/logger/logger.service';
import { IMinistryDTO } from './interface/ministry.interface';
import { Ministries } from './ministries.mongodb.entity';
import { MinistryService } from './ministry.service';
import { ICrudTrack } from '../interfaces';

describe('MinistryService', () => {
  let ministryService: MinistryService;

  const ministryMock = {
    acronym: 'TST',
    name: 'Test',
  };

  const insertResultMock = {
    insertedId: 'insertedIdMockValue',
  };

  const ministryRepository = {
    find: jest.fn(),
    findOne: jest.fn(),
    update: jest.fn(),
    insert: jest.fn(),
    insertOne: jest.fn(),
    delete: jest.fn(),
  };

  const loggerMock = {
    businessEvent: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      imports: [TypeOrmModule.forFeature([Ministries], 'fc-mongo')],
      providers: [MinistryService, Repository, LoggerService],
    })
      .overrideProvider(getRepositoryToken(Ministries, 'fc-mongo'))
      .useValue(ministryRepository)
      .overrideProvider(LoggerService)
      .useValue(loggerMock)
      .compile();

    ministryService = await module.get<MinistryService>(MinistryService);

    jest.resetAllMocks();

    ministryRepository.findOne.mockResolvedValue(ministryMock);
    ministryRepository.insertOne.mockResolvedValue(insertResultMock);
  });

  it('should be defined', () => {
    expect(ministryService).toBeDefined();
  });

  describe('track', () => {
    it('should call logger.businessEvent', () => {
      // Given
      const logMock = {} as ICrudTrack;
      // When
      // tslint:disable-next-line:no-string-literal
      ministryService['track'](logMock);
      // Then
      expect(loggerMock.businessEvent).toHaveBeenCalledTimes(1);
      expect(loggerMock.businessEvent).toHaveBeenCalledWith(logMock);
    });
  });

  it('should return an existing ministry', async () => {
    const ministry = {
      id: new ObjectID('5ff6d63de1326615c30da492'),
      name: 'Test ministry',
      acronym: 'TM',
      identityProviders: [
        {
          uid: '5ff381802e09a9ac9dcbfb79',
          name: 'fip1',
        },
      ],
    };

    ministryRepository.findOne.mockResolvedValueOnce(ministry);

    const ministryReturn = await ministryService.find(
      '5ff6d63de1326615c30da492',
    );

    expect(ministryRepository.findOne).toHaveBeenCalledTimes(1);
    expect(ministryReturn).toBe(ministry);
  });

  it('should find all ministries', async () => {
    const ministries = [
      {
        id: new ObjectID('5ff6d63de1326615c30da492'),
        name: 'Test ministry',
        acronym: 'TM',
        identityProviders: [
          {
            uid: '5ff381802e09a9ac9dcbfb79',
            name: 'fip1',
          },
        ],
      },
      {
        id: new ObjectID('5ff6d63de1326615c30da493'),
        name: 'Test ministry 2',
        acronym: 'TM2',
        identityProviders: [
          {
            uid: '5ff381802e09a9ac9dcbfb7b',
            name: 'fip2',
          },
        ],
      },
    ];

    ministryRepository.find.mockResolvedValueOnce(ministries);

    const ministriesReturn = await ministryService.findAll();

    expect(ministryRepository.find).toHaveBeenCalledTimes(1);
    expect(ministriesReturn).toBe(ministries);
  });

  it('should create a new ministry', async () => {
    const ministry: IMinistryDTO = {
      name: 'Test ministry',
      acronym: 'TM',
      identityProviders: ['fip1'],
      sort: 1,
    };
    const userMock = 'userMockValue';

    await ministryService.update(ministry, userMock);

    expect(ministryRepository.insertOne).toHaveBeenCalledTimes(1);
  });

  it('should call service.track on create', async () => {
    // Given
    const ministry: IMinistryDTO = {
      name: 'Test ministry',
      acronym: 'TM',
      identityProviders: ['fip1'],
      sort: 1,
    };
    const userMock = 'userMockValue';
    // tslint:disable-next-line:no-string-literal
    ministryService['track'] = jest.fn();

    // When
    await ministryService.update(ministry, userMock);

    // Then
    // tslint:disable-next-line:no-string-literal
    expect(ministryService['track']).toHaveBeenCalledTimes(1);
    // tslint:disable-next-line:no-string-literal
    expect(ministryService['track']).toHaveBeenCalledWith({
      entity: 'ministry',
      action: 'create',
      user: userMock,
      id: insertResultMock.insertedId,
      name: ministry.acronym,
    });
  });

  it('should update a ministry', async () => {
    const ministry: IMinistryDTO = {
      name: 'Test update ministry',
      acronym: 'TUM',
      identityProviders: ['fip1'],
      sort: 1,
    };
    const userMock = 'userMockValue';

    ministryRepository.update.mockResolvedValueOnce({ generatedMaps: [] });
    await ministryService.update(
      ministry,
      userMock,
      '5ff82c4dba9b1db9836c0c62',
    );

    expect(ministryRepository.update).toHaveBeenCalledTimes(1);
  });

  it('should call service.track on update', async () => {
    // Given
    const ministry: IMinistryDTO = {
      name: 'Test update ministry',
      acronym: 'TUM',
      identityProviders: ['fip1'],
      sort: 1,
    };
    const userMock = 'userMockValue';
    // tslint:disable-next-line:no-string-literal
    ministryService['track'] = jest.fn();
    ministryRepository.update.mockResolvedValueOnce({ generatedMaps: [] });

    // When
    await ministryService.update(
      ministry,
      userMock,
      '5ff82c4dba9b1db9836c0c62',
    );

    // Then
    // tslint:disable-next-line:no-string-literal
    expect(ministryService['track']).toHaveBeenCalledTimes(1);
    // tslint:disable-next-line:no-string-literal
    expect(ministryService['track']).toHaveBeenCalledWith({
      entity: 'ministry',
      action: 'update',
      user: userMock,
      name: ministry.acronym,
      id: '5ff82c4dba9b1db9836c0c62',
    });
  });

  it('should delete a ministry', async () => {
    // Given
    const userMock = 'userMockValue';
    ministryRepository.delete.mockResolvedValueOnce({});
    // When
    await ministryService.delete('5ff82c4dba9b1db9836c0c62', userMock);
    // Then
    expect(ministryRepository.delete).toHaveBeenCalledTimes(1);
  });

  it('should call service.track on delete', async () => {
    // Given
    const userMock = 'userMockValue';
    ministryRepository.delete.mockResolvedValueOnce({});
    // tslint:disable-next-line:no-string-literal
    ministryService['track'] = jest.fn();

    // When
    await ministryService.delete('5ff82c4dba9b1db9836c0c62', userMock);
    // Then
    // tslint:disable-next-line:no-string-literal
    expect(ministryService['track']).toHaveBeenCalledTimes(1);
    // tslint:disable-next-line:no-string-literal
    expect(ministryService['track']).toHaveBeenCalledWith({
      entity: 'ministry',
      action: 'delete',
      user: userMock,
      name: ministryMock.acronym,
      id: '5ff82c4dba9b1db9836c0c62',
    });
  });
});
