import { Test, TestingModule } from '@nestjs/testing';
import { PartnerInfoController } from './partner-info.controller';
import { PartnerInfoService } from './partner-info.service';

describe('PartnerController', () => {
  let controller: PartnerInfoController;

  const serviceMock = {
    getPartner: jest.fn(),
  };

  const resMock = {
    redirect: jest.fn(),
    status: jest.fn(),
    locals: {
      APP_ROOT: '/trantor/foundation',
    },
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [PartnerInfoController],
      providers: [PartnerInfoService],
    })
      .overrideProvider(PartnerInfoService)
      .useValue(serviceMock)
      .compile();

    controller = module.get<PartnerInfoController>(PartnerInfoController);
    jest.resetAllMocks();
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('search', () => {
    describe('GET', () => {
      it('should exist', () => {
        expect(controller.search).toBeDefined();
      });

      it('should render the partner info search page', async () => {
        // action
        const result = await controller.search();

        // assertion
        expect(result).toEqual({});
      });
    });

    describe('POST', () => {
      const reqMock = {
        flash: jest.fn(),
        body: {
          email: '',
          key: '',
        },
      };

      it('should exist', () => {
        expect(controller.searchComplete).toBeDefined();
      });

      it('should return an error message if neither the email nor the key are filled', async () => {
        // action
        await controller.searchComplete(reqMock.body, reqMock, resMock);

        // assertion
        expect(reqMock.flash).toBeCalledTimes(1);
        expect(reqMock.flash).toBeCalledWith(
          'globalError',
          'Un email ou une clé doivent être renseignés',
        );
      });

      it('should call getPartner from partnerService if the email is provided', async () => {
        // steup
        reqMock.body.email = 'toto@toto.fr';
        reqMock.body.key = '';

        // action
        await controller.searchComplete(reqMock.body, reqMock, resMock);

        // assertion
        expect(serviceMock.getPartner).toBeCalledTimes(1);
        expect(serviceMock.getPartner).toBeCalledWith(reqMock.body);
      });

      it('should call getPartner from partnerService if the key is provided', async () => {
        // steup
        reqMock.body.email = '';
        reqMock.body.key = 'mySecretKey';

        // action
        await controller.searchComplete(reqMock.body, reqMock, resMock);

        // assertion
        expect(serviceMock.getPartner).toBeCalledTimes(1);
        expect(serviceMock.getPartner).toBeCalledWith(reqMock.body);
      });

      it('should return the partners having given email or key', async () => {
        // steup
        reqMock.body.email = 'toto@toto.fr';
        reqMock.body.key = 'mySecretKey';
        const expectedPartners = [
          {
            email: 'toto@toto.fr',
            registerCode: '12345complex6789one',
            lastConnection: new Date('2019-05-22T14:37:07.145Z'),
            keys: ['thisIsAKey', 'thisIsAnotherKey'],
          },
          {
            email: 'test@test.fr',
            registerCode: 'regiser98765',
            lastConnection: new Date('2019-03-22T14:37:07.145Z'),
            keys: ['thisIsAWonderfullKey', 'thisOneIsAmazing'],
          },
        ];
        serviceMock.getPartner.mockResolvedValueOnce(expectedPartners);

        // action
        const result = await controller.searchComplete(
          reqMock.body,
          reqMock,
          resMock,
        );

        // assertion
        expect(serviceMock.getPartner).toBeCalledTimes(1);
        expect(serviceMock.getPartner).toBeCalledWith(reqMock.body);
        expect(result).toEqual({
          partners: expectedPartners,
        });
      });

      it('should send back an error message if there were a database error', async () => {
        // steup
        reqMock.body.email = 'toto@toto.fr';
        reqMock.body.key = 'mySecretKey';
        serviceMock.getPartner.mockRejectedValueOnce({});

        // action
        await controller.searchComplete(reqMock.body, reqMock, resMock);

        // assertion
        expect(reqMock.flash).toBeCalledTimes(1);
        expect(reqMock.flash).toBeCalledWith(
          'globalError',
          'Il y a eu une erreur au nveau de labase de donnée, merci de réessayer',
        );
        expect(resMock.redirect).toHaveBeenCalledTimes(1);
        expect(resMock.redirect).toHaveBeenCalledWith(
          `${resMock.locals.APP_ROOT}/partner-info/search`,
        );
      });

      it('should send back an error message if the partner is not found in database', async () => {
        // steup
        reqMock.body.email = 'toto@toto.fr';
        reqMock.body.key = 'mySecretKey';
        serviceMock.getPartner.mockResolvedValueOnce([]);

        // action
        await controller.searchComplete(reqMock.body, reqMock, resMock);

        // assertion
        expect(reqMock.flash).toBeCalledTimes(1);
        expect(reqMock.flash).toBeCalledWith(
          'globalError',
          "Le partenaire n'a pas été trouvé en base",
        );
        expect(resMock.redirect).toHaveBeenCalledTimes(1);
        expect(resMock.redirect).toHaveBeenCalledWith(
          `${resMock.locals.APP_ROOT}/partner-info/search`,
        );
      });
    });
  });
});
