import { Repository } from 'typeorm';
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken, TypeOrmModule } from '@nestjs/typeorm';
import { PartnerInfoService } from './partner-info.service';
import { PartnerInfoEntity } from './partner-info.mongodb.entity';

describe('PartnerService', () => {
  let service: PartnerInfoService;

  const partnerRepositoryMock = {
    find: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      imports: [TypeOrmModule.forFeature([PartnerInfoEntity], 'fc-mongo')],
      providers: [PartnerInfoService, Repository],
    })
      .overrideProvider(getRepositoryToken(PartnerInfoEntity, 'fc-mongo'))
      .useValue(partnerRepositoryMock)
      .compile();

    service = module.get<PartnerInfoService>(PartnerInfoService);

    jest.resetAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('getPartner', () => {
    it('should call findByEmail from partnerRepository with a trimmed and lowercased email if the email is provided', async () => {
      // setup
      const partnerEmail = {
        email: 'test@test.fr',
        key: '',
      };
      // tslint:disable-next-line:no-string-literal
      service['findByEmail'] = jest.fn();
      // tslint:disable-next-line:no-string-literal
      service['formatPartners'] = jest.fn();

      // action
      await service.getPartner(partnerEmail);

      // assertion
      // tslint:disable-next-line:no-string-literal
      expect(service['findByEmail']).toHaveBeenCalledTimes(1);
      // tslint:disable-next-line:no-string-literal
      expect(service['findByEmail']).toHaveBeenCalledWith(partnerEmail.email);
    });

    it('should return formatted partners', async () => {
      // setup
      const partnerEmail = {
        email: 'toto@toto.fr',
        key: '',
      };
      const foundEmailPartner = [
        {
          email: 'toto@toto.fr',
          registerCode: '12345complex6789one',
          lastConnection: new Date('2019-05-22T14:37:07.145Z'),
          clients: [
            {
              role: 'admin',
              type: 'particuliers',
              key: 'thisIsAKey',
            },
          ],
        },
      ];
      const formattedEmailPartner = [
        {
          email: 'toto@toto.fr',
          registerCode: '12345complex6789one',
          lastConnection: new Date('2019-05-22T14:37:07.145Z'),
          keys: ['thisIsAKey'],
        },
      ];
      // tslint:disable-next-line:no-string-literal
      service['findByEmail'] = jest.fn().mockResolvedValue(foundEmailPartner);
      // tslint:disable-next-line:no-string-literal
      service['formatPartners'] = jest
        .fn()
        .mockReturnValue(formattedEmailPartner);

      // action
      const result = await service.getPartner(partnerEmail);

      // assertion
      // tslint:disable-next-line:no-string-literal
      expect(service['formatPartners']).toHaveBeenCalledTimes(1);
      // tslint:disable-next-line:no-string-literal
      expect(service['formatPartners']).toHaveBeenCalledWith(foundEmailPartner);
      expect(result).toEqual(formattedEmailPartner);
    });

    it('should call findByKey from partnerRepository with the key if the key is provided', async () => {
      // setup
      const partnerKey = {
        email: '',
        key: 'secretKey',
      };
      // tslint:disable-next-line:no-string-literal
      service['findByKey'] = jest.fn();
      // tslint:disable-next-line:no-string-literal
      service['formatPartners'] = jest.fn();

      // action
      await service.getPartner(partnerKey);

      // assertion
      // tslint:disable-next-line:no-string-literal
      expect(service['findByKey']).toHaveBeenCalledTimes(1);
      // tslint:disable-next-line:no-string-literal
      expect(service['findByKey']).toHaveBeenCalledWith('secretKey');
    });

    it('should return formatted partners', async () => {
      // setup
      const partnerKey = {
        email: '',
        key: 'secretKey',
      };
      const foundKeyPartner = [
        {
          email: 'test@test.fr',
          registerCode: 'regiser98765',
          lastConnection: new Date('2019-03-22T14:37:07.145Z'),
          clients: [
            {
              role: 'admin',
              type: 'particuliers',
              key: 'thisIsAWonderfullKey',
            },
            {
              role: 'admin',
              type: 'particuliers',
              key: 'thisOneIsAmazing',
            },
          ],
        },
      ];
      const formattedKeyPartner = [
        {
          email: 'test@test.fr',
          registerCode: 'regiser98765',
          lastConnection: new Date('2019-03-22T14:37:07.145Z'),
          keys: ['thisIsAWonderfullKey', 'thisOneIsAmazing'],
        },
      ];
      // tslint:disable-next-line:no-string-literal
      service['findByKey'] = jest.fn().mockResolvedValue(foundKeyPartner);
      // tslint:disable-next-line:no-string-literal
      service['formatPartners'] = jest
        .fn()
        .mockReturnValue(formattedKeyPartner);

      // action
      const result = await service.getPartner(partnerKey);

      // assertion
      // tslint:disable-next-line:no-string-literal
      expect(service['formatPartners']).toHaveBeenCalledTimes(1);
      // tslint:disable-next-line:no-string-literal
      expect(service['formatPartners']).toHaveBeenCalledWith(foundKeyPartner);
      expect(result).toEqual(formattedKeyPartner);
    });
  });

  describe('formatPartners', () => {
    const partnersToFormat = [
      {
        email: 'toto@toto.fr',
        registerCode: '12345complex6789one',
        lastConnection: new Date('2019-05-22T14:37:07.145Z'),
        clients: [
          {
            role: 'admin',
            type: 'particuliers',
            key: 'thisIsAKey',
          },
        ],
      },
      {
        email: 'test@test.fr',
        registerCode: 'regiser98765',
        lastConnection: new Date('2019-03-22T14:37:07.145Z'),
        clients: [
          {
            role: 'admin',
            type: 'particuliers',
            key: 'thisIsAWonderfullKey',
          },
          {
            role: 'admin',
            type: 'particuliers',
            key: 'thisOneIsAmazing',
          },
        ],
      },
    ];
    const expectedFormattedPartners = [
      {
        email: 'toto@toto.fr',
        registerCode: '12345complex6789one',
        lastConnection: new Date('2019-05-22T14:37:07.145Z'),
        keys: ['thisIsAKey'],
      },
      {
        email: 'test@test.fr',
        registerCode: 'regiser98765',
        lastConnection: new Date('2019-03-22T14:37:07.145Z'),
        keys: ['thisIsAWonderfullKey', 'thisOneIsAmazing'],
      },
    ];

    it('should return the partners well formatted', () => {
      // action
      // tslint:disable-next-line:no-string-literal
      const result = service['formatPartners'](partnersToFormat);

      // assertion
      expect(result).toEqual(expectedFormattedPartners);
    });
  });

  describe('findByEmail', () => {
    const email = 'toto@toto.fr';
    const expectedEmailPartner = [
      {
        email: 'toto@toto.fr',
        registerCode: '12345complex6789one',
        lastConnection: new Date('2019-05-22T14:37:07.145Z'),
        keys: ['thisIsAKey', 'thisIsAnotherKey'],
      },
    ];

    it('should call partner repository', async () => {
      // setup
      partnerRepositoryMock.find.mockResolvedValueOnce(expectedEmailPartner);

      // action
      // tslint:disable-next-line:no-string-literal
      await service['findByEmail'](email);

      // assertion
      expect(partnerRepositoryMock.find).toHaveBeenCalledTimes(1);
      expect(partnerRepositoryMock.find).toHaveBeenCalledWith({
        where: { email: new RegExp(email) },
        select: ['email', 'registerCode', 'lastConnection', 'clients'],
      });
    });

    it('should return the partner returned by the search by email query', async () => {
      // setup
      partnerRepositoryMock.find.mockResolvedValueOnce(expectedEmailPartner);

      // action
      // tslint:disable-next-line:no-string-literal
      const result = await service['findByEmail'](email);

      // assertion
      expect(result).toEqual(expectedEmailPartner);
    });
  });

  describe('findByKey', () => {
    const key = 'secretKey';
    const expectedKeyPartners = [
      {
        email: 'toto@toto.fr',
        registerCode: '12345complex6789one',
        lastConnection: new Date('2019-05-22T14:37:07.145Z'),
        keys: ['thisIsAKey', 'thisIsAnotherKey'],
      },
      {
        email: 'test@test.fr',
        registerCode: 'regiser98765',
        lastConnection: new Date('2019-03-22T14:37:07.145Z'),
        keys: ['thisIsAWonderfullKey', 'thisOneIsAmazing'],
      },
    ];

    it('should call partner repository', async () => {
      // setup
      partnerRepositoryMock.find.mockResolvedValueOnce(expectedKeyPartners);

      // tslint:disable-next-line:no-string-literal
      await service['findByKey'](key);

      // assertion
      expect(partnerRepositoryMock.find).toHaveBeenCalledTimes(1);
      expect(partnerRepositoryMock.find).toHaveBeenCalledWith({
        where: { 'clients.key': key },
        select: ['email', 'registerCode', 'lastConnection', 'clients'],
      });
    });

    it('should return the partners returned by the search by key query', async () => {
      // setup
      partnerRepositoryMock.find.mockResolvedValueOnce(expectedKeyPartners);

      // action
      // tslint:disable-next-line:no-string-literal
      const result = await service['findByKey'](key);

      // assertion
      expect(result).toEqual(expectedKeyPartners);
    });
  });
});
